<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【置顶】欢迎来到妙木山</title>
    <url>/2023/04/02/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%A6%99%E6%9C%A8%E5%B1%B1/</url>
    <content><![CDATA[<span id="more"></span>
<p><code>:)</code></p>
]]></content>
      <categories>
        <category>站点信息</category>
      </categories>
      <tags>
        <tag>站点建设</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程编程【C++高级编程】</title>
    <url>/2023/09/12/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E3%80%90C++%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%91/</url>
    <content><![CDATA[<h1 id="c-多线程编程">C++ 多线程编程</h1>
<span id="more"></span>
<h2 id="什么是线程进程和线程同步">什么是线程、进程和线程同步？</h2>
<ul>
<li><p><code>线程（Thread）</code>：<strong>线程是在一个进程内执行的独立任务单位</strong>。</p>
<p>一个进程可以拥有多个线程，每个线程都有自己的程序计数器、栈、寄存器和状态。多线程允许在同一时间同时执行多个任务，每个线程独立地执行特定的代码块，但共享进程的资源。</p></li>
<li><p><code>进程（Process）</code>：<strong>进程是计算机中运行的程序的实例</strong>。</p>
<p>一个进程由代码、数据和用于管理资源（如打开的文件、网络连接等）的系统内核数据结构组成。每个进程都是独立执行的，拥有自己的地址空间和系统资源</p></li>
<li><p><code>线程同步（Thread Synchronization）</code>：</p>
<p>多线程环境中，多个线程可能会<strong>并发访问和修改共享的数据</strong>，这会引发竞态条件和数据不一致问题。线程同步用于协调和管理多个线程对共享资源的访问，以确保数据的正确性和一致性。常见的线程同步机制包括互斥量（mutex）、条件变量、原子操作、信号量。</p></li>
</ul>
<h2 id="c-线程库头文件">C++ 线程库头文件<thread></thread></h2>
<p>在C++标准库中，头文件<thread>提供了一些函数和类，用于<strong>创建</strong>、<strong>启动</strong>、<strong>等待</strong>和<strong>管理</strong>线程。</thread></p>
<ul>
<li><p>创建线程：</p>
<p><code>std::thread</code>类的构造函数可以<strong>创建线程</strong>。需要传递一个<strong>可调用对象</strong>作为<strong>线程</strong>的<strong>入口点</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"my thread start "</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_print)</span></span>;</span><br><span class="line">    my_thread.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main 函数执行结束"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">my thread <span class="built_in">start</span></span><br><span class="line">main 函数执行结束</span><br></pre></td></tr></table></figure></li>
<li><p>启动线程:</p>
<p>创建线程后，可以使用<code>std::thread对象</code>的成员函数<code>std::thread::join()</code>来启动线程。<code>join()</code>函数将阻塞当前线程，<strong>直到指定的线程执行完毕</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myThread.<span class="built_in">join</span>();  <span class="comment">// 启动线程，当前线程阻塞直到myThread执行完毕</span></span><br></pre></td></tr></table></figure></li>
<li><p>分离线程：</p>
<p>可以使用<code>std::thread</code>对象的成员函数<code>std::thread::detach()</code>将线程和调用线程分离。分离后的线程将在后台运行，<strong>与调用线程无关</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myThread.<span class="built_in">detach</span>();  <span class="comment">// 将线程和调用线程分离</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 在这里添加线程的具体逻辑</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"线程执行中..."</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这里将会是一个长时间运行的任务</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"线程执行完毕！"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离线程</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序继续在这里执行其他任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"程序继续执行..."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可能会是一些耗时的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序退出，线程可能还没有执行完</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">程序继续执行...</span><br><span class="line">线程执行中...</span><br></pre></td></tr></table></figure></li>
<li><p>等待线程完成：</p>
<p>可以使用<code>std::thread</code>
对象的成员函数<code>std::thread::join()</code>来等待线程的完成。<code>join()</code>函数将阻塞当前线程，直到指定的线程执行完毕。</p></li>
<li><p>获取线程的ID：</p>
<p>可以使用<code>std::thread</code>对象的成员函数<code>std::thread::get_id()</code>获取线程的ID。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::thread::id threadID = myThread.<span class="built_in">get_id</span>();  <span class="comment">// 获取线程的ID</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="互斥和锁">互斥和锁</h2>
<p><code>互斥（Mutex）</code>和<code>锁（Lock）</code>是多线程编程中常用的<strong>同步机制</strong>，用于确保在多个线程中访问<strong>共享资源时的正确性和并发性</strong>。</p>
<p><code>互斥（Mutex）</code>是一种用于<strong>保护共享资源的机制</strong>，它提供了一种互斥访问机制，即<font color="668899>同一时刻只有一个线程可以访问这个资源</font">。通过给共享资源加上<code>互斥锁（Mutex Lock）</code>，可以<strong>防止多个线程同时访问/修改该资源，从而避免数据竞争和不一致性。</strong></font></p>
<p>C++标准库提供了<code>std::mutex</code>作为互斥对象的实现。可以使用<code>std::mutex</code>来创建互斥量，并通过成员函数<code>lock()</code>和<code>unlock()</code>来加锁和解锁互斥量。</p>
<p>当一个线程调用<code>lock()</code>时，如果互斥量没有被其他线程锁定，则成功获取锁定，并且该线程可以继续执行<strong>临界区</strong>代码。而如果互斥量被其他线程锁定，则该线程会在这里阻塞，直到互斥量被解锁。也就是<strong>谁锁谁用</strong>，<strong>被锁待用</strong>。</p>
<blockquote>
<p>临界区是指在程序中访问共享资源的代码片段，需要进行互斥操作来保证线程安全。在进入临界区之前，需要获取互斥锁；在离开临界区时，需要释放互斥锁。</p>
</blockquote>
<p>互斥量的生命周期管理非常重要，确保在所有对共享资源的访问结束后进行解锁，以免造成死锁（Deadlock）情况。通常，可以使用RAII（资源获取即初始化）的原则，通过在作用域内创建一个<code>std::lock_guard</code>对象，自动管理互斥量的锁定和解锁。</p>
<blockquote>
<p><code>std::lock_guard</code> 是 C++
中的一个类模板，用于管理互斥锁（<code>std::mutex</code>）的自动锁定和解锁。</p>
<p>使用 <code>std::lock_guard</code>
可以确保在作用域结束时，互斥锁会被自动解锁，以防止忘记解锁而导致死锁或其他并发问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_shared_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动锁定互斥锁</span></span><br><span class="line">    <span class="comment">// 对共享资源进行更新</span></span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="comment">// 在作用域结束时，std::lock_guard 会自动解锁互斥锁</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 创建多个线程同时更新共享资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">update_shared_data</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</blockquote>
<p>防止竞态条件是多线程编程中的常见问题之一。竞态条件指的是多个线程在访问共享资源时，它们的操作顺序会影响最终结果的正确性。通过使用互斥和锁，我们可以防止多个线程同时执行临界区代码，从而避免竞态条件。</p>
<h2 id="条件变量">条件变量</h2>
<p><code>条件变量（Condition Variable）</code>是多线程编程中用于<strong>线程间通信和同步的一种机制</strong>。它允许<strong>一个或多个线程等待某个特定条件的发生，并在条件满足时被唤醒。</strong></p>
<p>C++标准库提供了<code>std::condition_variable</code>作为条件变量的实现。它通常与互斥量（<code>std::mutex</code>）配合使用，用于实现更复杂的线程间通信和同步。</p>
<p>进行线程间的通信和同步的基本步骤：</p>
<ol type="1">
<li><p>创建一个<code>std::condition_variable</code>对象和一个<code>std::mutex</code>对象，用于管理<code>条件变量</code>和<code>互斥量</code>。</p></li>
<li><p>在等待线程中使用<code>std::unique_lock&lt;std::mutex&gt;</code>与条件变量一起等待某个条件的发生。使用<code>wait()</code>函数使线程等待条件满足，当条件满足时，线程将被唤醒继续执行。</p>
<blockquote>
<p><code>std::unique_lock&lt;std::mutex&gt;</code> 是 C++
中的一个类模板，也用于管理互斥锁（<code>std::mutex</code>）的自动锁定和解锁，与
<code>std::lock_guard</code> 相比，<code>std::unique_lock</code>
更加灵活。</p>
<p><code>std::unique_lock</code> 提供了比 <code>std::lock_guard</code>
更多的功能，例如：</p>
<ol type="1">
<li>可以在锁定时选择不同的锁定策略，如阻塞锁定、尝试锁定、递归锁定等。</li>
<li>可以在锁定的过程中解锁和重新锁定互斥锁，以实现更细粒度的控制。</li>
<li>可以在需要时手动释放锁定，然后再次锁定。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_shared_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 手动锁定互斥锁</span></span><br><span class="line">    <span class="comment">// 对共享资源进行更新</span></span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="comment">// 手动解锁互斥锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在此期间可以执行其他操作，不需要保持互斥锁的锁定状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次手动锁定互斥锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 对共享资源进行进一步操作</span></span><br><span class="line">    shared_data += <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 自动解锁互斥锁（在作用域结束时）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 创建多个线程同时更新共享资源</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(update_shared_data)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(update_shared_data)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 共享资源的值为 6</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>在通知线程中，使用<code>std::unique_lock&lt;std::mutex&gt;</code>与条件变量一起发送通知。使用<code>notify_one()</code>函数唤醒等待条件的某个线程，或者使用<code>notify_all()</code>函数唤醒所有等待条件的线程。</p></li>
<li><p>使用互斥锁（<code>std::mutex</code>）来保护共享数据的访问，以确保线程安全。</p></li>
</ol>
<h2 id="线程池">线程池</h2>
<p><code>线程池</code>是一种用于<strong>管理线程的技术</strong>，它可以有效地<strong>重用</strong>线程并提高程序的性能。通过线程池，我们可以将需要执行的任务提交给线程池，线程池会自动分配可用的线程来执行任务，并管理线程的生命周期。</p>
<p>在C++中，可以使用一些库或者自行实现线程池。常见的线程池实现一般包括以下几个关键概念：
1.
<code>任务队列（Task Queue）</code>：用于存储待执行的任务，可以采用<strong>队列（FIFO）</strong>或者其他数据结构实现。
2.
<code>线程池管理器（Thread Pool Manager）</code>：负责线程池的<strong>初始化</strong>、<strong>维护</strong>和<strong>管理</strong>，包括创建线程、销毁线程、任务调度等。
3.
<code>工作线程（Worker Thread）</code>：<strong>实际执行任务的线程</strong>，它们从任务队列中获取待执行的任务，并执行任务的逻辑。
4.
<code>任务（Task）</code>：需要执行的<strong>具体操作</strong>，可以是函数、类成员函数、Lambda表达式等。</p>
<p>关于并发数据结构，C++标准库提供了一些线程安全的容器，例如
<code>std::vector</code> 的线程安全版本是
<code>std::vector&lt;std::mutex&gt;</code>，<code>std::map</code>
的线程安全版本是
<code>std::map&lt;std::mutex&gt;</code>，<code>std::queue</code>
的线程安全版本是
<code>std::queue&lt;std::mutex&gt;</code>。这些线程安全的容器会在操作时自动保证线程安全，但使用时需要注意保护对容器的修改操作，避免数据竞争和线程间冲突。</p>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; sharedVector; <span class="comment">// 共享资源，用于存储整数</span></span><br><span class="line">std::mutex vectorMutex; <span class="comment">// 用于保护对 sharedVector 的并发访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addToSharedVector</span><span class="params">(<span class="type">int</span> value)</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(vectorMutex)</span></span>; <span class="comment">// 创建 lock_guard 对象，自动获取 vectorMutex 的锁</span></span><br><span class="line">    sharedVector.<span class="built_in">push_back</span>(value); <span class="comment">// 向 sharedVector 中添加元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numOfThreads = <span class="number">4</span>; <span class="comment">// 线程数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numOfElements = <span class="number">100</span>; <span class="comment">// 每个线程中添加的元素个数</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads; <span class="comment">// 存储线程对象的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 numOfThreads 个线程，每个线程向 sharedVector 中添加 numOfElements 个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numOfThreads; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;] {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numOfElements; ++j) {</span><br><span class="line">                <span class="built_in">addToSharedVector</span>(j); <span class="comment">// 调用 addToSharedVector() 函数向 sharedVector 中添加元素</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; thread : threads) {</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 sharedVector 的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Size of sharedVector: "</span> &lt;&lt; sharedVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>threads.emplace_back([&amp;] { ... })</code> 这行代码使用
<code>Lambda 表达式</code>创建了一个线程，并将其添加到
<code>threads</code> 容器中。</p>
<p>Lambda
表达式可以看作是一个匿名函数，它可以在创建它的上下文中捕获变量。在这个例子中，Lambda
表达式的捕获列表 <code>[&amp;]</code>
使用按引用方式捕获了所有可见的变量。</p>
<p>在 Lambda 表达式的主体部分，我们使用了一个循环来调用
<code>addToSharedVector()</code> 函数 <code>numOfElements</code>
次，每次传入不同的整数值
<code>j</code>。这样，每个线程都会执行这个循环，从 0 到
<code>numOfElements-1</code>，并将这些整数值依次添加到共享的
<code>sharedVector</code> 容器中。</p>
<p>通过创建多个线程，并行地进行添加操作，我们可以在
<code>sharedVector</code>
中同时添加多个元素，从而提高程序的执行效率。</p>
</blockquote>
<p>在这个示例中，我们创建了4个线程，并且每个线程向
<code>sharedVector</code> 中添加100个元素。为了保证对
<code>sharedVector</code> 的并发访问的线程安全，我们使用了
<code>std::mutex</code> 来进行互斥保护。</p>
<p>注意，在每次向 <code>sharedVector</code> 添加元素时，我们使用了
<code>std::lock_guard</code> 来自动管理互斥锁的锁定和释放。</p>
<p>最后，我们输出 <code>sharedVector</code> 的大小，可以看到输出结果应为
<code>400</code>，即每个线程成功地添加了100个元素到
<code>sharedVector</code> 中。</p>
<h2 id="异常与错误">异常与错误</h2>
<p>在多线程环境下，正确处理异常和保证异常安全性都是非常重要的。以下是一些异常处理机制和异常安全的编程实践：</p>
<ol type="1">
<li>异常处理机制：
<ul>
<li>在多线程环境中，每个线程都有自己的异常上下文，即每个线程都可以捕获和处理其自己的异常。</li>
<li>在多线程环境中，一个线程抛出的异常不会被其他线程捕获。因此，每个线程应该负责自己的异常处理，并且应该在局部范围内捕获异常并进行适当的处理。</li>
<li>如果一个线程抛出异常，但没有被捕获，则该线程将终止并有可能造成整个程序的崩溃。</li>
</ul></li>
<li>异常安全性：
<ul>
<li>异常安全性是指当发生异常时，程序的状态仍然处于一种有效且一致的状态，而不会导致资源泄漏或数据损坏。</li>
<li>异常安全的编程实践包括基本的三种保证级别：弱异常安全（basic
exception safety）、强异常安全（strong exception
safety）和无异常安全（no-throw guarantee）。</li>
<li>弱异常安全：操作过程中不会破坏程序数据的一致性，但可能有资源泄漏。</li>
<li>强异常安全：即使操作失败，程序的数据和资源状态也不会改变（即保证了异常不会改变程序状态）。</li>
<li>无异常安全：操作过程中不会抛出异常。尽量避免使用可能引发异常的操作，或者在使用前进行适当的异常检查。</li>
</ul></li>
</ol>
<p>在多线程环境中，为了保证异常安全性，可以采取以下实践： - 使用
RAII（Resource Acquisition Is Initialization）技术管理资源。RAII
的基本原则是使用对象的构造函数获取资源，使用对象的析构函数释放资源。通过使用智能指针、互斥量等资源管理工具，可以确保在异常发生时资源得到正确释放。
-
将状态更新和资源释放操作放在适当的位置。在执行可能引发异常的操作之前，先进行状态检查和资源预处理，并使用合适的锁机制来保护共享资源的一致性。
-
在可能发生异常的代码块中使用适当的异常处理机制，以确保异常捕获并处理，同时确保资源的适当释放。</p>
<p>请注意，在多线程环境下，仍然需要注意数据的一致性和线程安全性，并确保在异常处理过程中不会破坏这些。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>高级编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++异常处理【C++语言基础】</title>
    <url>/2023/09/11/C++%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%90C++%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%91/</url>
    <content><![CDATA[<h1 id="c-异常处理">C++ 异常处理</h1>
<span id="more"></span>
<h2 id="什么是异常">什么是异常</h2>
<p>异常是指在程序执行过程中发生的一种<strong>异常情况</strong>或<strong>错误</strong>，它会中断程序的正常执行流程。异常可能是由于<code>外部条件</code>、<code>内部逻辑错误</code>、<code>资源不足</code>等导致的，这些异常情况常常无法在编码阶段事先预知或完全控制。</p>
<p>当异常发生时，程序会抛出（<code>throw</code>）一个异常对象，它可以是任何类型的数据。该异常对象会在程序的调用栈中向上寻找异常处理的代码，直到找到对应的异常处理块（<code>catch</code>
块）来处理异常。如果找不到对应的异常处理块，程序将终止执行并输出错误信息。</p>
<p>异常处理机制的设计目的是在异常发生时，能够对异常进行捕获（catch）和处理，从而使程序在异常情况下仍能够正常运行或给出合理的错误反馈。通过使用异常处理，可以更好地管理程序的错误和异常情况，提高程序的可靠性和容错性。</p>
<p>常见的异常包括但不限于：<code>访问越界</code>、<code>空指针引用</code>、<code>除零错误</code>、<code>文件读写错误</code>等。通过合理地捕获和处理异常，可以有效防止程序崩溃、数据丢失或出现未知行为。</p>
<h2 id="异常的基本语法">异常的基本语法</h2>
<p>C++中异常的基本语法如下：</p>
<h3 id="异常的抛出throw">异常的抛出（Throw）：</h3>
<p><code>throw</code>
关键字用于抛出异常。可以抛出任何类型的数据，包括基本类型、类对象、指针等。语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br></pre></td></tr></table></figure>
<h3 id="异常的捕获catch">异常的捕获（Catch）：</h3>
<p><code>try</code> 块用于包含可能引发异常的代码块，<code>catch</code>
块用于捕获并处理异常。可以捕获特定类型的异常，也可以使用省略号
<code>...</code> 捕获所有类型的异常。语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 可能引发异常的代码</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (异常类型<span class="number">1</span> 参数<span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 处理异常的代码块1</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (异常类型<span class="number">2</span> 参数<span class="number">2</span>) {</span><br><span class="line">    <span class="comment">// 处理异常的代码块2</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (...) {</span><br><span class="line">    <span class="comment">// 处理其他类型异常的代码块</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常">自定义异常：</h3>
<p>可以定义自己的异常类，继承自 <code>std::exception</code>
类或其子类。通常需要重写 <code>what()</code>
方法，用于返回异常的描述信息。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My custom exception occurred."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在代码中抛出自定义异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br></pre></td></tr></table></figure>
<h3 id="异常的传递">异常的传递：</h3>
<p>当异常在一个函数中抛出时，如果在当前函数中没有被捕获，就会将异常传递给函数的调用者，一直传递到能够捕获并处理异常的地方。</p>
<h2 id="异常的层级关系">异常的层级关系</h2>
<p>C++ 中的异常层级关系是通过异常类之间的继承关系来实现的。C++
标准库中定义了一些常见的异常类，如
<code>std::exception</code>、<code>std::runtime_error</code>
等，它们构成了一个异常类的层级结构。</p>
<p><code>std::exception</code> 是 C++
异常类体系的根类，是其他异常类的基类。它定义了一个虚拟成员函数
<code>what()</code>，用于返回异常的描述信息。</p>
<p>其他的异常类如
<code>std::runtime_error</code>、<code>std::logic_error</code>
等，都直接或间接地继承自
<code>std::exception</code>。这些异常类提供了特定类型的异常，例如
<code>std::runtime_error</code>
表示运行时错误，<code>std::logic_error</code> 表示逻辑错误。</p>
<p>开发者也可以自定义自己的异常类，只需<strong>继承</strong>自
<code>std::exception</code>
或其子类，并可以根据需要添加额外的成员变量和方法。通过继承并扩展异常类，可以更好地组织和分类异常，并提供更具体的异常信息。</p>
<p>当抛出异常时，可以使用 <code>catch</code>
块按照异常类的继承关系进行匹配，从而捕获并处理特定类型的异常。如果没有找到匹配的
<code>catch</code> 块，异常将被传递给调用栈的上一层，直到找到合适的
<code>catch</code> 块或程序终止。</p>
<p>通过了解异常类的层级关系，可以更好地组织和处理异常，提高程序的可读性和可维护性。</p>
<h2 id="异常的规范">异常的规范</h2>
<p>在 C++
中，<code>异常规范（Exception Specification）</code>可以用于声明函数可能抛出的异常类型。异常规范包括动态异常规范和异常指定函数。</p>
<ol type="1">
<li>动态异常规范（Dynamic Exception Specification）是在函数声明中使用
throw 关键字指定该函数可能抛出的异常类型。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, std::runtime_error)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述示例中，函数 <code>foo()</code> 被声明为可能抛出
<code>std::exception</code> 和 <code>std::runtime_error</code>
类型的异常。</p>
<p>注意，<strong>动态异常规范在 <code>C++11</code>标准中已被弃用，在
<code>C++17</code>
标准中已被移除</strong>。因为动态异常规范在实践中往往无法准确反映函数的实际异常抛出情况，而且存在一些性能上的开销。建议使用更现代的异常处理方式。</p>
<ol start="2" type="1">
<li>异常指定函数（Exception Specification
Function）用于在函数定义中指定该函数可能抛出的异常类型。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>{</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>上述示例中，函数 <code>foo()</code>
被指定为不允许抛出异常（noexcept），当函数内部发生异常时，会调用
<code>std::terminate</code> 终止程序。<code>noexcept(false)</code>
表示该函数可能抛出异常。</p>
<p>注意，<strong><code>noexcept</code>规范是在 <code>C++11</code>
标准中引入的，并在<code>C++17</code>
标准中进行了更新</strong>。它更加灵活且更精确地指定函数的异常属性，取代了动态异常规范的使用。</p>
<p>总体而言，由于动态异常规范已被弃用，推荐使用现代的异常处理方式，如使用
<code>try-catch</code> 块来捕获异常并进行处理，或使用
<code>noexcept</code>
来指定函数是否允许抛出异常。遵循良好的异常处理实践可以提高代码的可读性、可维护性和健壮性。</p>
<h2 id="常见的异常实例">常见的异常实例</h2>
<h3 id="逻辑异常">逻辑异常</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;exception&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double devide(double x,double y){</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)</span><br><span class="line">        throw logic_error(<span class="string">"除数不能为零"</span>);</span><br><span class="line">    <span class="keyword">return</span> x/y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(){</span><br><span class="line">    double num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        num = devide(<span class="number">1.0</span>,<span class="number">0</span>);</span><br><span class="line">    }catch(logic_error&amp; e){</span><br><span class="line">        cout &lt;&lt; <span class="string">"捕获到逻辑异常:"</span> &lt;&lt; e.what() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">捕获到逻辑异常:除数不能为零</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="无效参数异常">无效参数异常</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PositionNum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">"数字必须是整数"</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        num = <span class="built_in">PositionNum</span>(<span class="number">-10</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (invalid_argument &amp;e)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    {</span><br><span class="line">        num = <span class="built_in">PositionNum</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (invalid_argument &amp;e)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">数字必须是整数</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="索引错误异常">索引错误异常</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVectorElement</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> index)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= vec.<span class="built_in">size</span>()) {</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">"索引超出有效范围"</span>); <span class="comment">// 抛出索引错误异常</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"向量中索引为 "</span> &lt;&lt; index &lt;&lt; <span class="string">" 的元素是："</span> &lt;&lt; vec[index] &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"请输入要访问的元素索引："</span>;</span><br><span class="line">    std::cin &gt;&gt; index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">printVectorElement</span>(vec, index);</span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"捕获到索引错误异常："</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">请输入要访问的元素索引：<span class="number">1000</span></span><br><span class="line">捕获到索引错误异常：索引超出有效范围</span><br></pre></td></tr></table></figure>
<h3 id="动态分配异常">动态分配异常</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000000000</span>]; <span class="comment">// 尝试分配一个非常大的内存块</span></span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"捕获到动态分配异常："</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] ptr; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++，C++语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串处理【C++基础】</title>
    <url>/2023/09/09/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E3%80%90C++%E5%9F%BA%E7%A1%80%E3%80%91/</url>
    <content><![CDATA[<h1 id="字符串处理">字符串处理</h1>
<span id="more"></span>
<h2 id="字符串拼接concatenation">字符串拼接（Concatenation）：</h2>
<ul>
<li>使用<code>"+"</code>运算符可以将两个字符串进行拼接。</li>
<li>使用<code>append()</code>函数可以将一个字符串附加到另一个字符串的末尾。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">"Hello,"</span>;</span><br><span class="line">string str2 = <span class="string">"World!"</span>;</span><br><span class="line"></span><br><span class="line">string str_plus = str1 + str2;</span><br><span class="line">string str_append = str1.<span class="built_in">append</span>(str2);</span><br><span class="line">cout &lt;&lt; str_plus &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str_append &lt;&lt;  endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello,World<span class="variable">!</span></span><br><span class="line"><span class="variable">Hello,World!</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串长度length">字符串长度（Length）：</h2>
<ul>
<li>使用<code>length()</code>函数可以获取字符串的长度。</li>
<li>使用<code>size()</code>函数也可以获取字符串的长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">length</span>();</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串比较comparison">字符串比较（Comparison）：</h2>
<ul>
<li><p>使用<code>==</code>运算符可以比较两个字符串是否相等。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">"Hello"</span>;</span><br><span class="line">string str2 = <span class="string">"hello"</span>;</span><br><span class="line">string str3 = <span class="string">"Hello"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str1 == str2 ? <span class="string">"Same\n"</span> : <span class="string">"Different\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str1 == str3 ? <span class="string">"Same\n"</span> : <span class="string">"Different\n"</span>);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Different</span><br><span class="line">Same</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>compare()</code>函数可以比较两个字符串的大小关系。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str1 = <span class="string">"ABCD"</span>;</span><br><span class="line">string str2 = <span class="string">"ABCd"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str1.<span class="built_in">compare</span>(str2) ? <span class="string">"Longer\n"</span> : <span class="string">"Shorter\n"</span>);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Longer</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="子串查找substring-searching">子串查找（Substring
Searching）：</h2>
<ul>
<li><p>使用<code>find()</code>函数可以在字符串中查找指定子串的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">string substr = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(substr);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>rfind()</code>函数可以从字符串末尾开始查找指定子串的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">string substr = <span class="string">"l"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(substr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">rfind</span>(substr) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子串提取substring-extraction">子串提取（Substring
Extraction）：</h2>
<ul>
<li><p>使用<code>substr(start,end) or substr(position)</code>函数(<code>[start,end)</code>
or
<code>[positon,end)</code>)可以从字符串中提取指定位置和长度的子串,<code>end</code>默认为字符串末尾后一位。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">string str = "Hello,World!";</span><br><span class="line"></span><br><span class="line">string substr1 = str.substr(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">string substr2 = str.substr(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; substr1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; substr2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">,World!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串分割string-splitting">字符串分割（String
Splitting）：</h2>
<ul>
<li><p>使用<code>find_first_of()</code>和<code>substr()</code>函数可以实现字符串的分割。</p>
<p><code>find_first_of()</code>
是一个字符串成员函数，用于在字符串中查找第一个与给定字符序列中的任何字符匹配的字符的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = str.<span class="built_in">find_first_of</span>(<span class="string">"Wor"</span>);</span><br><span class="line">cout &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">string substr1 = str.<span class="built_in">substr</span>(<span class="number">0</span>,index);</span><br><span class="line">string substr2 = str.<span class="built_in">substr</span>(index);</span><br><span class="line">cout &lt;&lt; substr1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; substr2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">Hell</span><br><span class="line">o,World!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串替换string-replacement">字符串替换（String
Replacement）：</h2>
<ul>
<li><p>使用`<code>replace()</code>函数可以将字符串中的指定子串替换为另一个字符串。</p>
<p><code>replace()</code>
函数有多个重载版本，根据不同的参数类型和个数，可以实现不同的字符串替换操作。以下是其中一些常用的重载版本：</p>
<ol type="1">
<li><p>替换指定位置的子串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">string substr = <span class="string">"Wo"</span>;</span><br><span class="line">string new_str = <span class="string">"wor"</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">find</span>(substr), new_str.<span class="built_in">length</span>(), new_str);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello,World<span class="variable">!</span></span><br><span class="line"><span class="variable">Hello,world!</span></span><br></pre></td></tr></table></figure></li>
<li><p>替换指定位置的子串，或插入/删除内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string substr = <span class="string">"Wor"</span>;</span><br><span class="line">string new_str = <span class="string">"wor"</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(str.<span class="built_in">find</span>(substr), substr.<span class="built_in">length</span>(), new_str, <span class="number">0</span>, new_str.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello,World<span class="variable">!</span></span><br><span class="line"><span class="variable">Hello,world!</span></span><br></pre></td></tr></table></figure></li>
<li><p>替换指定位置的子串，或插入/删除内容（C风格字符串作为参数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>替换指定位置的子串，或插入/删除内容（C风格字符串作为参数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<h2 id="字符串大小写转换case-conversion">字符串大小写转换（Case
Conversion）：</h2>
<ul>
<li><p>使用<code>tolower()</code>函数可以将字符串转换为小写形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">ToLower</span><span class="params">(string str)</span></span>{</span><br><span class="line">    string temp = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : temp)</span><br><span class="line">    {</span><br><span class="line">        ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">    </span><br><span class="line">    string newstr = <span class="built_in">ToLower</span>(str);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; newstr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello,World<span class="variable">!</span></span><br><span class="line"><span class="variable">hello,world!</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>toupper()</code>函数可以将字符串转换为大写形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">ToUpper</span><span class="params">(string str)</span></span>{</span><br><span class="line">    string temp = str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : temp)</span><br><span class="line">    {</span><br><span class="line">        ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str = <span class="string">"Hello,World!"</span>;</span><br><span class="line">    </span><br><span class="line">    string newstr = <span class="built_in">ToUpper</span>(str);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; newstr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello,World<span class="variable">!</span></span><br><span class="line"><span class="variable">HELLO,WORLD!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符串与数字的相互转换">字符串与数字的相互转换：</h2>
<ul>
<li><p>使用<code>stoi()</code>函数可以将字符串转换为整数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str_num = <span class="string">"12345"</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(str_num);</span><br><span class="line">cout &lt;&lt; num;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>stof()</code>函数可以将字符串转换为浮点数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str_num = <span class="string">"12345.33"</span>;</span><br><span class="line"><span class="type">double</span> num = <span class="built_in">stof</span>(str_num);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt;num;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">12345</span>.<span class="number">33</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>to_string()</code>函数可以将数字转换为字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> fnum = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(num) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(fnum) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">3</span>.<span class="number">140000</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++，C++语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL容器类【C++基础】</title>
    <url>/2023/09/09/STL%E5%AE%B9%E5%99%A8%E7%B1%BB%E3%80%90C++%E5%9F%BA%E7%A1%80%E3%80%91/</url>
    <content><![CDATA[<h1 id="stl容器类">STL容器类</h1>
<span id="more"></span>
<p>STL（标准模板库）提供了一组通用的数据结构和算法，其中包含了很多容器类。C++的STL容器类包括：</p>
<ol type="1">
<li><code>vector（向量）</code>：动态数组，支持随机访问和动态大小调整。</li>
<li><code>list（链表）</code>：双向链表，支持快速插入和删除。</li>
<li><code>deque（双端队列）</code>：双向队列，支持快速在两端插入和删除。</li>
<li><code>queue（队列）</code>：先进先出（FIFO）队列，支持在一端插入，在另一端删除。</li>
<li><code>stack（栈）</code>：后进先出（LIFO）栈，支持在一端插入和删除。</li>
<li><code>set（集合）</code>：有序集合，每个元素都唯一，支持插入、删除和查找操作。</li>
<li><code>map（映射）</code>：由键和值成对组成的集合，键唯一且有序，支持插入、删除和查找操作。</li>
<li><code>unordered_set（无序集合</code>）：无序集合，每个元素都唯一，支持插入、删除和查找操作，查找速度较快。</li>
<li><code>unordered_map（无序映射）</code>：由键和值成对组成的无序集合，键唯一，支持插入、删除和查找操作，查找速度较快。</li>
</ol>
<p>这些容器类提供了不同的功能和性能特点，可以根据需求选择适合的容器类来存储和操作数据。</p>
<h2 id="vector">vector</h2>
<p>动态数组，支持随机访问和动态大小调整。</p>
<h3 id="构造方法">构造方法</h3>
<ol type="1">
<li><p>默认构造方法：创建一个空的 <code>vector</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v</span><br></pre></td></tr></table></figure></li>
<li><p>带有元素数量和初始值的构造方法：创建一个包含指定数量元素的
<code>vector</code>，每个元素都被初始化为指定的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>带有迭代器范围的构造方法：使用迭代器表示的范围内的元素来创建一个
<code>vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; sourceVector {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(sourceVector.begin(), sourceVector.end())</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝构造方法：使用另一个 <code>vector</code>
对象的副本来创建一个新的 <code>vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; sourceVector {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(sourceVector)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>移动构造方法：使用另一个 <code>vector</code>
对象的内容来创建一个新的
<code>vector</code>，同时移动原始对象的内容到新对象中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; sourceVector {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(std::move(sourceVector))</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>std::move()</code> 是 C++
标准库中的一个函数模板，它用于将对象的状态从一个对象移动到另一个对象，而无需执行深拷贝。这个函数在移动语义中起着重要的作用。</p></li>
</ol>
<h3 id="成员函数">成员函数</h3>
<ul>
<li><p><code>push_back()</code>：向 <code>vector</code>
的末尾添加一个元素。<code>void push_back(const T&amp; value)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>};</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>pop_back()</code>：从 <code>vector</code>
的末尾删除一个元素。<code>void pop_back()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>size()</code>：返回 <code>vector</code>
中元素的数量。<code>size_type size() const</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>empty()</code>：检查 <code>vector</code>
是否为空。<code>bool empty() const</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,v.<span class="built_in">empty</span>()?<span class="string">"empty\n"</span>:<span class="string">"unempty\n"</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,v.<span class="built_in">empty</span>()?<span class="string">"empty\n"</span>:<span class="string">"unempty\n"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">empty</span><br><span class="line">unempty</span><br></pre></td></tr></table></figure></li>
<li><p><code>at()</code>：访问指定索引处的元素，并进行边界检查。<code>const T&amp; at(size_type index) const</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>clear()</code>：移除 <code>vector</code>
中的所有元素。<code>void clear()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,v.<span class="built_in">empty</span>()?<span class="string">"empty\n"</span>:<span class="string">"unempty\n"</span>);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,v.<span class="built_in">empty</span>()?<span class="string">"empty\n"</span>:<span class="string">"unempty\n"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">unempty</span><br><span class="line">empty</span><br></pre></td></tr></table></figure></li>
<li><p><code>insert()</code>：在指定位置插入一个或多个元素。<code>iterator insert(iterator position, const T&amp; value)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>};</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>erase()</code>:
移除指定位置的元素。<code>iterator erase(iterator position)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">Disp</span>(v);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>resize()</code>:
改变<code>vector</code>的大小。<code>void resize(size_type count)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Current size: "</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增大向量的大小为 5，并使用默认值 0 初始化新的元素</span></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"New size after resizing: "</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出向量中的元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"Vector elements: "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : myVector) {</span><br><span class="line">	std::cout &lt;&lt; element &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Current size: <span class="number">3</span></span><br><span class="line">New size after resizing: <span class="number">5</span></span><br><span class="line">Vector elements: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>reserve()</code>：提前分配足够的内存空间以容纳指定数量的元素。<code>void reserve(size_type new_cap)</code></p>
<p>当知道向量可能会包含一定数量的元素时，可以使用 <code>reserve()</code>
成员函数来预先分配足够的内存空间，以避免不必要的重新分配和复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Current capacity: "</span> &lt;&lt; myVector.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预分配足够的空间以容纳 10 个元素</span></span><br><span class="line">    myVector.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"New capacity after reserving: "</span> &lt;&lt; myVector.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向向量中添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) {</span><br><span class="line">        myVector.<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Vector elements: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : myVector) {</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Current capacity: <span class="number">0</span></span><br><span class="line">New capacity after reserving: <span class="number">10</span></span><br><span class="line">Vector elements: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="list">list</h2>
<p>双向链表，支持快速插入和删除。</p>
<h3 id="构造函数">构造函数：</h3>
<ul>
<li><p>默认构造函数：<code>list()</code></p></li>
<li><p>带有初始元素的构造函数：<code>list(std::initializer_list&lt;T&gt; il)</code>
或者 <code>list(size_type count, const T&amp; value)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(myList1);</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList2</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(myList2);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>范围构造函数：<code>template &lt;class InputIterator&gt; list(InputIterator first, InputIterator last)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(myList1);</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">next</span>(myList1.<span class="built_in">begin</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="built_in">advance</span>(it,<span class="number">3</span>);</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList2</span><span class="params">(myList1.begin(),it)</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(myList2);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>std::next()</code> 是 C++ 标准库中的一个函数模板，位于
<code>&lt;iterator&gt;</code>
头文件中。它用于获取迭代器的下一个位置，并将其返回。</p>
<p><code>std::advance()</code> 是 C++ 标准库中的一个函数模板，位于
<code>&lt;iterator&gt;</code>
头文件中。它用于将迭代器向前或向后移动指定的步数。</p></li>
<li><p>拷贝构造函数：<code>list(const list&amp; other)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">myList2</span><span class="params">(myList1)</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(myList2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员函数与vector有重复的">成员函数(与vector有重复的)</h3>
<ul>
<li><code>front()</code>：返回list中第一个元素的引用。</li>
<li><code>back()</code>：返回list中最后一个元素的引用。</li>
</ul>
<h2 id="deque">deque</h2>
<p>双向队列，支持快速在两端插入和删除。</p>
<h3 id="构造函数-1">构造函数：</h3>
<ol type="1">
<li>默认构造函数：<code>deque()</code> 创建一个空的deque容器。</li>
<li>带有大小参数的构造函数：<code>deque(size_type count, const T&amp; value = T())</code>
创建一个包含count个值为value的元素的deque容器。</li>
<li>范围构造函数：<code>deque(InputIterator first, InputIterator last)</code>
创建一个包含[first,
last)范围内元素的deque容器，其中first和last分别为指向范围起始和结束位置的迭代器。</li>
</ol>
<h3 id="成员函数-1">成员函数：</h3>
<ol type="1">
<li>大小和容量操作：
<ul>
<li><code>size()</code>：返回deque中元素的个数。</li>
<li><code>empty()</code>：判断deque是否为空。</li>
<li><code>max_size()</code>：返回deque能够容纳的最大元素数量。</li>
</ul></li>
<li>迭代器相关操作：
<ul>
<li><code>begin()</code>：返回指向deque第一个元素的迭代器。</li>
<li><code>end()</code>：返回指向deque末尾元素的下一个位置的迭代器。</li>
<li><code>rbegin()</code>：返回指向deque末尾元素的逆向迭代器。</li>
<li><code>rend()</code>：返回指向deque第一个元素的前一个位置的逆向迭代器。</li>
</ul></li>
<li>元素访问：
<ul>
<li><code>front()</code>：返回deque中第一个元素的引用。</li>
<li><code>back()</code>：返回deque中最后一个元素的引用。</li>
<li><code>operator</code>：访问指定位置上的元素。</li>
</ul></li>
<li>修改容器内容：
<ul>
<li><code>assign(InputIterator first, InputIterator last)</code>：用[first,
last)范围内的元素替换deque的内容。</li>
<li><code>push_back(const T&amp; value)</code>：将value添加到deque的末尾。</li>
<li><code>pop_back()</code>：删除deque的最后一个元素。</li>
<li><code>push_front(const T&amp; value)</code>：将value添加到deque的开头。</li>
<li><code>pop_front()</code>：删除deque的第一个元素。</li>
<li><code>insert(iterator pos, const T&amp; value)</code>：在pos位置之前插入value。</li>
<li><code>erase(iterator pos)</code>：删除pos位置处的元素。</li>
<li><code>clear()</code>：清空deque的内容。</li>
</ul></li>
</ol>
<h2 id="stack">stack</h2>
<p>后进先出（<code>LIFO</code>）栈，支持在一端插入和删除。</p>
<h3 id="构造函数-2">构造函数：</h3>
<ol type="1">
<li>默认构造函数：<code>stack()</code> 创建一个空的stack容器。</li>
<li>拷贝构造函数：<code>stack(const stack&amp; other)</code>
根据另一个stack容器other创建一个新的stack容器，包含相同的元素。</li>
</ol>
<h3 id="成员函数-2">成员函数：</h3>
<ol type="1">
<li>大小和容量操作：
<ul>
<li><code>size()</code>：返回stack中元素的个数。</li>
<li><code>empty()</code>：判断stack是否为空。</li>
</ul></li>
<li>元素访问：
<ul>
<li><code>top()</code>：返回stack顶部元素的引用。</li>
</ul></li>
<li>修改容器内容：
<ul>
<li><code>push(const T&amp; value)</code>：将value添加到stack的顶部。</li>
<li><code>pop()</code>：移除stack顶部的元素。</li>
</ul></li>
</ol>
<h2 id="setunordered_set">set/unordered_set</h2>
<p>有序集合，每个元素都唯一，支持插入、删除和查找操作。</p>
<p>无序集合，每个元素都唯一，支持插入、删除和查找操作。</p>
<h3 id="构造函数-3">构造函数：</h3>
<ol type="1">
<li><p>默认构造函数：<code>set()</code>
创建一个空的set容器，默认使用元素类型的默认比较函数进行排序。</p></li>
<li><p>范围构造函数：set(InputIterator first, InputIterator last)
创建一个包含[first,
last)范围内唯一元素的set容器，其中first和last分别为指向范围起始和结束位置的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
<li><p>拷贝构造函数：set(const set&amp; other)
根据另一个set容器other创建一个新的set容器，包含相同的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line">    <span class="built_in">Disp</span>(s);</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">Disp</span>(s1);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="成员函数-3">成员函数：</h3>
<ol type="1">
<li><p>大小和容量操作：</p>
<ul>
<li><code>size()</code>：返回set中元素的个数。</li>
<li><code>empty()</code>：判断set是否为空。</li>
</ul></li>
<li><p>插入和删除元素：</p>
<ul>
<li><p><code>insert(const T&amp; value)</code>：将value插入到set中，如果已存在于set中，则不会插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"><span class="built_in">Disp</span>(mySet);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Disp</span>(mySet);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>erase(const T&amp; value)</code>：从set中删除与value相等的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>clear()</code>：清空set的内容。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>查找元素：</p>
<ul>
<li><p><code>find(const T&amp; value)</code>：返回指向set中与value相等的元素的迭代器，如果找不到则返回end()迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> it1 = s.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">cout &lt; *it1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>count(const T&amp; value)</code>：返回set中与value相等的元素的个数，即0或1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>upper_bound(const T&amp; value)</code>：返回指向set中第一个大于value的元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line"><span class="built_in">Disp</span>(s);</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">upper_bound</span>(<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>lower_bound(const T&amp; value)</code>：返回指向set中第一个大于或等于value的元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>};</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line">    <span class="built_in">Disp</span>(s);</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">lower_bound</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>迭代器相关操作：</p>
<ul>
<li><code>begin()</code>：返回指向set中第一个元素的迭代器。</li>
<li><code>end()</code>：返回指向set中最后一个元素的下一个位置的迭代器。</li>
<li><code>rbegin()</code>：返回指向set中最后一个元素的逆向迭代器。</li>
<li><code>rend()</code>：返回指向set中第一个元素的前一个位置的逆向迭代器。</li>
</ul></li>
</ol>
<h2 id="mapunordered_map">map/unordered_map</h2>
<p><code>map（映射）</code>：由键和值成对组成的集合，键唯一且有序，支持插入、删除和查找操作。<code>unordered_set（无序集合）</code>：无序集合，每个元素都唯一，支持插入、删除和查找操作，查找速度较快。</p>
<h3 id="构造函数-4">构造函数：</h3>
<ol type="1">
<li>默认构造函数：<code>map()</code>
创建一个空的map容器，默认使用键类型的默认比较函数进行排序。</li>
<li>范围构造函数：<code>map(InputIterator first, InputIterator last)</code>
创建一个包含[first,
last)范围内键值对的map容器，其中的每个键值对都是唯一的。</li>
<li>拷贝构造函数：<code>map(const map&amp; other)</code>
根据另一个map容器other创建一个新的map容器，包含相同的键值对。</li>
</ol>
<h3 id="成员函数-4">成员函数：</h3>
<ol type="1">
<li><p>大小和容量操作：</p>
<ul>
<li><code>size()</code>：返回map中键值对的个数。</li>
<li><code>empty()</code>：判断map是否为空。</li>
</ul></li>
<li><p>插入和删除元素：</p>
<ul>
<li><p><code>insert(const value_type&amp; value)</code>：插入一个键值对value到map中，如果已存在相同的键，则键值对不会插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Disp</span><span class="params">(map&lt;Key, Value&gt; Map)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> Mypair : Map)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; Mypair.first &lt;&lt; <span class="string">":"</span> &lt;&lt; Mypair.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">    Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;(<span class="string">'a'</span>,<span class="number">10</span>));</span><br><span class="line">    Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;(<span class="string">'b'</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Disp</span>(Map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li><p><code>erase(const key_type&amp; key)</code>：从map中删除指定键的键值对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;(<span class="string">'a'</span>,<span class="number">10</span>));</span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>,<span class="type">int</span>&gt;(<span class="string">'b'</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">erase</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Disp</span>(Map);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">a:10</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>clear()</code>：清空map的内容。</p></li>
</ul></li>
<li><p>查找元素：</p>
<ul>
<li><p><code>find(const key_type&amp; key)</code>：返回指向map中与key相等的键值对的迭代器，如果找不到则返回end()迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'a'</span>, <span class="number">10</span>));</span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'b'</span>, <span class="number">32</span>));</span><br><span class="line"><span class="keyword">auto</span> it = Map.<span class="built_in">find</span>(<span class="string">'a'</span>);</span><br><span class="line">cout &lt;&lt; (*it).first &lt;&lt;  <span class="string">":"</span> &lt;&lt; (*it).second &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">a:10</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>count(const key_type&amp; key)</code>：返回map中与key相等的键的个数，即0或1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'a'</span>, <span class="number">10</span>));</span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'b'</span>, <span class="number">32</span>));</span><br><span class="line">cout &lt;&lt; Map.<span class="built_in">count</span>(<span class="string">'a'</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>访问元素：</p>
<ul>
<li><p><code>operator[](const key_type&amp; key)</code>：通过键访问对应的值，如果键不存在，则会创建一个新键值对并返回对应的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; Map;</span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'a'</span>, <span class="number">10</span>));</span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">'b'</span>, <span class="number">32</span>));</span><br><span class="line"><span class="built_in">Disp</span>(Map);</span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; Map[<span class="string">'a'</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; Map[<span class="string">'c'</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Disp</span>(Map);</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">a:10</span></span><br><span class="line"><span class="function"><span class="title">b</span>:32</span></span><br><span class="line"><span class="function">10</span></span><br><span class="line"><span class="function">0</span></span><br><span class="line"><span class="function"><span class="title">a</span>:10</span></span><br><span class="line"><span class="function"><span class="title">b</span>:32</span></span><br><span class="line"><span class="function"><span class="title">c</span>:0</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>迭代器相关操作：</p>
<ul>
<li><code>begin()</code>：返回指向map中第一个键值对的迭代器。</li>
<li><code>end()</code>：返回指向map中最后一个键值对的下一个位置的迭代器。</li>
<li><code>first</code>：访问键对值的<code>Key</code>。</li>
<li><code>second</code>：访问键对值的<code>Value</code></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>C++，C++语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出</title>
    <url>/2023/09/08/C++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="c输入输出">C++输入输出</h1>
<span id="more"></span>
<h2 id="流对象">流对象</h2>
<p>C++包含4个预定义的流对象：</p>
<ul>
<li>标准输入流对象:<code>cin</code></li>
<li>标准输出流对象:<code>cout</code></li>
<li>非缓冲型的标准出错流:<code>cerr</code></li>
<li>缓冲型的标准出错流:<code>clog</code></li>
</ul>
<p>区别：</p>
<p>标准出错流<code>cerr</code>,<code>clog</code>不可被重定义，只可以被输出到显示器。</p>
<h2 id="常用的流类库文件说明">常用的流类库文件说明</h2>
<ul>
<li><code>ios</code>:流基类，抽象类，需包含<code>oistream</code></li>
<li><code>istream</code>:通用输入流和其他输入流类的基类，需包含<code>iostream</code></li>
<li><code>ifstream</code>:输入文件流类，需包含<code>fstream</code></li>
<li><code>ostream</code>:通用输出流和其他输出流类的基类，需包含<code>iostream</code></li>
<li><code>fostream</code>:输出文件流，需包含<code>fstream</code></li>
<li><code>iostream</code>:通用I/O流类和其他I/O流的基类，需包含<code>iostream</code></li>
<li><code>fstream</code>:I/O文件流类，需包含<code>fstream</code></li>
</ul>
<h2 id="预定义类型的格式化输入输出">预定义类型的格式化输入输出</h2>
<p>C++提供了两种格式的控制方法</p>
<ul>
<li><code>ios</code>类中的有关格式控制的成员函数镜像格式控制</li>
<li>使用被称为操作符的特殊类型函数进行格式控制</li>
</ul>
<h3 id="常用成员函数">常用成员函数</h3>
<table>
<thead>
<tr class="header">
<th>成员函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>precision(n)</code></td>
<td>设置实数的精度为n位(有效数字，而不是小数点后几位)</td>
</tr>
<tr class="even">
<td><code>width(n)</code></td>
<td>设置字段宽度为n位</td>
</tr>
<tr class="odd">
<td><code>fill(c)</code></td>
<td>设置填充<code>c</code>字符</td>
</tr>
<tr class="even">
<td><code>setf()</code></td>
<td>设置输出的格式状态</td>
</tr>
<tr class="odd">
<td><code>unsetf()</code></td>
<td>终止已设置的输出格式状态，在括号中应指定内容</td>
</tr>
</tbody>
</table>
<h4 id="precision">precision()</h4>
<p>精度位数。例如，如果要将浮点数保留两位小数，则可以使用<code>setprecision(2)</code>。</p>
<h4 id="width">width()</h4>
<p>设置位宽，默认为空格填充，可以用<code>fill()</code>来指定填充的字符，注意只对下一次流输出有效！</p>
<h4 id="setf">setf()</h4>
<p><code>setf()</code> 是 <code>std::ios_base</code>
类的一个成员函数，用于设置流对象的各种标志位（flags）。这些标志位决定了流对象的不同行为，如显示格式、对齐方式等。</p>
<p><code>setf()</code> 函数的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmtflags setf (fmtflags flags);</span><br></pre></td></tr></table></figure>
<p>其中，<code>flags</code>
参数是一个位掩码，用于设置各种标志位。可以使用
<code>std::ios_base::fmtflags</code> 类型的枚举值进行设置，如
<code>std::ios_base::hex</code>、<code>std::ios_base::scientific</code>
等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios_base::hex, std::ios_base::basefield); <span class="comment">// 将进制输出为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">unsetf</span>(std::ios_base::hex); <span class="comment">// 取消十六进制标志位</span></span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; std::endl; <span class="comment">// 默认以十进制输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>a</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊操作符">特殊操作符</h3>
<ul>
<li><p>不带形参的操作符</p>
<ol type="1">
<li><code>dec</code>：以十进制的格式输入或者输出整型数</li>
<li><code>hex</code>：以十六进制的格式输入或者输出整型数</li>
<li><code>oct</code>：以八进制的格式输入或者输出整型数</li>
<li><code>ws</code>：在输入流中提取空字符</li>
<li><code>endl</code>：插入一个换行符并刷新输出流，仅用于输出。</li>
<li><code>ends</code>：插入一个空字符<code>\0</code>，通常用来结束一个字符串，仅用于输出</li>
<li><code>flush</code>：刷新一个输出流，仅用于输出</li>
</ol></li>
<li><p>带形参的操作符 ,<code>&lt;iomanip&gt;</code></p>
<ol type="1">
<li><p><code>setprecision(n)</code>：同<code>precision(n)</code></p></li>
<li><p><code>setw(n)</code>：同<code>width(n)</code></p></li>
<li><p><code>setfill(c)</code>：同<code>fill(c)</code></p></li>
<li><p><code>setiosflags()</code>:同<code>setf()</code></p></li>
<li><p><code>resetiosflags</code>：同<code>unsetf()</code></p></li>
</ol></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++，C++语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串常用函数【语言基础】</title>
    <url>/2023/09/07/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E3%80%90%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E3%80%91/</url>
    <content><![CDATA[<h1 id="python字符串常用函数语言基础">Python字符串常用函数【语言基础】</h1>
<span id="more"></span>
<h2 id="检查类">检查类</h2>
<ul>
<li><code>isalnum()</code>：检查字符串是否只存在字母和数字</li>
<li><code>isalpha()</code>：检查字符串是否只存在字母</li>
<li><code>isdigit()</code>： 检查字符串是否只存在数字</li>
<li><code>isnumeric()</code>：检查字符串是否只存在数字</li>
<li><code>islower()</code>： 检查字符串是否只包含小写字母</li>
<li><code>isspace()</code>： 检查字符串只存在空格</li>
</ul>
<h2 id="修改类">修改类</h2>
<ul>
<li><p><code>capitalize()</code>：将字符串的首字母大写</p></li>
<li><p><code>casefold()</code>：将字符串转化为小写字母</p></li>
<li><p><code>lower()</code>： 将字符串转化为小写字母</p></li>
<li><p><code>upper()</code>：将字符串转化为大写字母</p></li>
<li><p><code>center(width,fillchar)</code>：将字符串居中width宽度对齐，空白区域用<code>fillchar</code>填充</p></li>
<li><p><code>ljust(width,fillchar)</code>：
将字符串左对齐width宽度对齐，空白区域用<code>fillchar</code>填充</p></li>
<li><p><code>rjust(wifth,fillchar</code>：
将字符串有对齐width宽度对齐，空白区域用<code>fillchar</code>填充</p></li>
<li><p><code>encode(encoding)</code>：
将字符串转化为指定的编码格式</p></li>
<li><p><code>strip(char)</code>：将左右的指定字符<code>char</code>去除，默认空格</p></li>
<li><p><code>lstrip(char)</code>：将左的指定字符<code>char</code>去除，默认空格</p></li>
<li><p><code>rstrip(char)</code>：将右的指定字符<code>char</code>去除，默认空格</p></li>
<li><p><code>replace(substr,newsubstr)</code>：将<code>substr</code>替换成<code>newsubstr</code></p></li>
<li><p><code>join(list)</code>：将字符串列表拼接为字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str_list = [<span class="string">"Hello"</span>,<span class="string">","</span>,<span class="string">"World!"</span>,<span class="string">'1266'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"_"</span>.join(str_list)) <span class="comment"># 将字符串列表组合成字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Hello_,_World!_1266</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="寻找统计类">寻找统计类</h2>
<ul>
<li><code>count(substr,start,end)</code>：统计子串在字符串<code>start</code>到<code>end</code>之间<code>substr</code>的出现频次，默认从头到尾。</li>
<li><code>find(substr,start,end)</code>：返回子串第一次出现的索引</li>
<li><code>index(substr,start,end)</code>：同上</li>
<li><code>rfind(substr,start,end)</code>：返回子串最后一次出现的索引</li>
<li><code>rindex(substr,start,end)</code>：同上</li>
</ul>
]]></content>
      <categories>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>STL（标准模板库）概述【C++】</title>
    <url>/2023/08/01/STL%EF%BC%88%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%89%E6%A6%82%E8%BF%B0%E3%80%90C-%E3%80%91/</url>
    <content><![CDATA[<h1 id="stl概述">STL概述</h1>
<span id="more"></span>
<p>当涉及到C++ STL（<strong>Standard Template
Library</strong>）时，这是指C++标准库中的一部分，它提供了一组<strong>通用的模板类和函数</strong>，用于实现常见的数据结构和算法操作。<strong>STL的设计主要基于泛型编程</strong>，通过使用模板来实现通用性。</p>
<p>STL主要由以下三个组件组成：</p>
<ol type="1">
<li><p>容器（Containers）：容器是用于存储和管理数据的模板类。STL提供了多种容器，每个容器都有自己的特点和用途，开发者可以根据需求选择合适的容器。常见的容器包括：</p>
<ul>
<li>向量（<strong>vector</strong>）：用于动态数组，可随机访问。</li>
<li>列表（<strong>lis</strong>t）：双向链表，支持高效插入和删除。</li>
<li>双端队列（<strong>deque</strong>）：两端可插入和删除的队列。</li>
<li>集合（<strong>set</strong>）：有序、不重复的元素集合。</li>
<li>映射（<strong>map</strong>）：键-值对的集合，按照键进行排序存储。</li>
<li>栈（<strong>stack</strong>）：后进先出（LIFO）的数据结构。</li>
<li>队列（<strong>queue</strong>）：先进先出（FIFO）的数据结构。</li>
</ul>
<p>在使用容器时，开发者可以利用它们提供的方法来存储、访问和修改数据。</p></li>
<li><p>算法（Algorithms）：算法是一组模板函数，用于在数据上执行各种操作。STL提供了很多常见的算法，包括：</p>
<ul>
<li>排序：如快速排序、归并排序、堆排序等。</li>
<li>查找：如线性查找、二分查找等。</li>
<li>替代和修改：如拷贝、替换、移除等。</li>
<li>数值操作：如累加、内积、最大最小值查找等。</li>
<li>合并和分割：如合并排序、分割容器等。</li>
</ul>
<p>这些算法独立于具体的容器类型，可以在不同的容器上使用，提高了代码的可重用性和灵活性。开发者可以根据需要选择合适的算法来处理数据。</p></li>
<li><p>迭代器（Iterators）：迭代器提供了一种统一的访问容器元素的方式。它类似于指针，可以用于遍历和访问容器中的元素。STL定义了多种类型的迭代器，包括：</p>
<ul>
<li>输入迭代器（Input Iterators）：允许从容器中读取数据。</li>
<li>输出迭代器（Output Iterators）：允许向容器中写入数据。</li>
<li>正向迭代器（Forward Iterators）：可以向前遍历容器中的元素。</li>
<li>双向迭代器（Bidirectional
Iterators）：可以双向遍历容器中的元素。</li>
<li>随机访问迭代器（Random-access
Iterators）：可以以任意顺序访问容器中的元素。</li>
</ul>
<p>迭代器使得开发者可以通过相同的接口和方式来操作不同类型的容器，提高了代码的通用性和可复用性。</p></li>
</ol>
<p>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>模板【C++】</title>
    <url>/2023/07/29/%E6%A8%A1%E6%9D%BF%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="模板">模板</h1>
<span id="more"></span>
<p>模板是C++中的一种特殊机制，它允许在编写代码时定义通用的函数或类，以适应多种不同的数据类型。</p>
<p>使用模板能够编写灵活的代码，不需要为每种数据类型都编写独立的函数或类。相反，可以定义一个通用的模板，在编译时根据实际使用的数据类型生成具体的代码。</p>
<p>使用模板的语法主要是通过使用尖括号<code>&lt;&gt;</code>来指定模板参数。模板参数可以是类型参数，也可以是非类型参数（如整数、字符等）</p>
<blockquote>
<p>泛型编程是一种编程范式，旨在编写可适用于多种数据类型的代码。它是一种在不指定具体类型的情况下编写代码的方式，通过参数化类型实现通用性。</p>
<p>泛型编程的目的是实现代码的重用和灵活性，避免为每种数据类型编写独立的代码。通过使用泛型，可以编写可以适用于不同类型数据的通用算法和数据结构，提高代码的可维护性和可扩展性。</p>
</blockquote>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数的定义或者实现</span><br></pre></td></tr></table></figure>
<ul>
<li><code>template</code>：声明创建模板</li>
<li><code>typename</code>：表示器后面的符号是一种数据类型，可以用<code>class</code>代替。</li>
<li><code>T</code>：同样的数据类型。</li>
</ul>
<p>可以使用<code>typeid(type).name()</code>方法来查看推导出的类型。</p>
<h2 id="函数模板">函数模板</h2>
<p>函数模板允许定义一个通用的函数，可以接受不同类型的参数。例如，可以使用函数模板来实现通用的加法函数，无论是整数、浮点数还是其他类型的数据都可以进行相加操作。</p>
<p>简单的数据交换函数的模板:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myswap</span><span class="params">(T&amp; A, T&amp; B)</span> </span>{</span><br><span class="line">	T temp = A;</span><br><span class="line">	A = B;</span><br><span class="line">	B = temp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数模板的注意事项">函数模板的注意事项</h3>
<ol type="1">
<li><p>自动类型的推导，必须推导出<strong>一致的数据类型</strong>才能使用。</p>
<p>就比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> c = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="built_in">Myswap</span>(a,b); <span class="comment">//有效，T被同时推导成int </span></span><br><span class="line"><span class="built_in">Myswap</span>(c,d); <span class="comment">//有效，T被同时推导成double</span></span><br><span class="line"><span class="built_in">Myswap</span>(a,c); <span class="comment">//无效，T被推导成int 和 double,类型不一致</span></span><br></pre></td></tr></table></figure></li>
<li><p>模板必须确定
<code>T</code>的数据类型才能使用，也就是说<code>T</code>必须被使用或者被显式的确定类型！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>{</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 错误，由于T未被使用，无法确定类型</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//正确，T被显式的确定为int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="普通函数与函数模板的区别">普通函数与函数模板的区别</h3>
<ol type="1">
<li><p>普通函数会发生自动类型转换，也就是<strong>隐式类型转换</strong></p>
<blockquote>
<p>隐式类型转换（Implicit type
conversion），也称为隐式类型转换、自动类型转换，指的是在某些情况下，编译器会自动将一种数据类型转换为另一种数据类型，而无需显式地进行类型转换操作。</p>
</blockquote></li>
<li><p>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换。</p></li>
<li><p>如果显式的确定参数类型，会发生隐式类型转换。</p></li>
</ol>
<h3 id="普通函数与函数的模板的调用规则">普通函数与函数的模板的调用规则</h3>
<p>前提：函数模板可以发生重载！</p>
<ol type="1">
<li><p>如果函数模板和普通函数都可以实现，优先调用<strong>普通函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myswap</span><span class="params">(T&amp; A, T&amp; B)</span> </span>{</span><br><span class="line">	T temp = A;</span><br><span class="line">	A = B;</span><br><span class="line">	B = temp;</span><br><span class="line">	cout &lt;&lt; <span class="string">"函数模板被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myswap</span><span class="params">(<span class="type">int</span>&amp; A, <span class="type">int</span>&amp; B)</span> </span>{</span><br><span class="line">	<span class="type">int</span> temp = A;</span><br><span class="line">	A = B;</span><br><span class="line">	B = temp;</span><br><span class="line">	cout &lt;&lt; <span class="string">"普通函数被调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Myswap</span>(a, b); <span class="comment">// 普通函数被调用</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过空模板参数来强制调用函数模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">My&lt;&gt;<span class="built_in">swap</span>(a,b); <span class="comment">// 调用的函数模板</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果函数模板可以产生更好的匹配，优先调用函数模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>  c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">Myswap</span>(c1,c2); <span class="comment">// 虽然可以使用隐式类型转换的调用普通函数，但是函数模板只需要类型推导就可以了，优先选择模板</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="模板的局限性">模板的局限性</h3>
<p><code>T</code> 类型对于自定义的类型的操作有一定的局限性</p>
<p>可以用<strong>特定的类型</strong>提供<strong>具体化</strong>的模板,或者在类中进行运算符的重载</p>
<p>简而言之，重载函数模板的自定义类型的版本。</p>
<h2 id="类模板">类模板</h2>
<p>类模板允许定义一个通用的类，可以适用于不同的数据类型。可以在类模板中定义成员变量、成员函数等，并在使用时指定实际的数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NameType,<span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">// 类模板可以使用默认的参数类型</span></span><br><span class="line"><span class="keyword">class</span> Person {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType Name;</span><br><span class="line">	AgeType Age;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) {};</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NameType, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showInfo</span>()</span><br><span class="line">{</span><br><span class="line">	cout &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; Name &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"xiunneg"</span>,<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="类模板与函数模板的区别">类模板与函数模板的区别</h3>
<ol type="1">
<li>类模板没有自动类型推导</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<h3 id="类模板中的成员函数的调用时机">类模板中的成员函数的调用时机</h3>
<p>在普通类中，成员函数在一开始就已经创建了，而<strong>类模板的成员函数是在调用的时候才创建</strong>的。</p>
<h3 id="类模板对象做参数">类模板对象做参数</h3>
<ol type="1">
<li><p>指定传入的类型 --显式确定对象的数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt;&amp; p)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数模板化 -- 将对象中的参数变为模板进行传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NameTyep,<span class="keyword">typename</span> AgeType&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Person&lt;NameType,AgeType&gt;&amp; p)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>整个类模板化 -- 将整个对象类型 模板化进行传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; p)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类模板的继承">类模板的继承</h3>
<ol type="1">
<li><p>当子类继承的父类是一个类模板的时候，子类在声明时，要指定父类中<code>T</code>的类型。如果不指定，编译器将无法分配内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> Person&lt;<span class="type">int</span>&gt;{};</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要灵活的指出父类中的<code>T</code>类型，子类也需要变为类模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> Person&lt;T1&gt; {</span><br><span class="line">    T1 Name;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类模板的分文件">类模板的分文件</h3>
<ol type="1">
<li>直接包含<code>.cpp</code>文件</li>
<li>声明和实现写在同一个文件中，后缀为<code>.hpp</code></li>
</ol>
<h3 id="类模板和友元">类模板和友元</h3>
<ol type="1">
<li>类内实现：直接在类中声明友元</li>
<li>类外实现：需要提前声明全局函数，否则编译器不知到全局函数的存在</li>
</ol>
]]></content>
      <categories>
        <category>C++，C++语言基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型编程</tag>
      </tags>
  </entry>
  <entry>
    <title>文件读写操作【C++】</title>
    <url>/2023/07/26/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="文件的读写操作">文件的读写操作</h1>
<h2 id="为什么要进行文件的读写操作">为什么要进行文件的读写操作？</h2>
<p>程序运行时会产生我们想要长期利用的数据，但是程序结束之后，所产生的数据也会随之消失，所以文件读写就是问了让数据进行数据持久化的操作。</p>
<p>在C++中，对文件进行操作需要包含<code>&lt;fstream&gt;</code>头文件。</p>
<span id="more"></span>
<h2 id="文件的类型与操作的类型">文件的类型与操作的类型</h2>
<p>文件的类型：</p>
<ol type="1">
<li><strong>文本文件</strong>：文件以<code>ASCII</code>码的形式进行存储在计算机中。</li>
<li><strong>二进制文件</strong>：
文件以文本形式的二进制形式存储在计算机。</li>
</ol>
<p>操作的类型：</p>
<ol type="1">
<li><code>ofstream</code>：写操作</li>
<li><code>ifstream</code>：读操作</li>
<li><code>fstream</code>： 读写操作</li>
</ol>
<h2 id="写操作">写操作</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() = <span class="keyword">default</span>;	</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	std::ofstream ofs; <span class="comment">// 创建流对象</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>,std::ios::out);<span class="comment">//打开文件</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">"This string is a test string!"</span>;<span class="comment">// 写数据</span></span><br><span class="line">	ofs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中<code>open()</code>函数接受两个参数，第一个参数是文件路径，第二个参数是打开的方式。</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">打开方式的参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>std::ios::binary</code></td>
<td>以二进制方式打开文件</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::ios::ate</code></td>
<td>打开文件后立即将写入位置设置为文件末尾</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::ios::in</code></td>
<td>(<strong>input</strong>)文件以只读方式打开（默认模式）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>std::ios::out</code></td>
<td>(<strong>output</strong>)文件以只写方式打开。如果文件不存在，则创建新文件。<strong>如果文件存在，则清除现有内容</strong>。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std::ios::app</code></td>
<td>(<strong>append</strong>)文件以只写方式打开，并将写入位置设置为文件末尾（追加模式）。如果文件不存在，则创建新文件</td>
</tr>
</tbody>
</table>
<p>这些打开模式可以使用按位或操作符（<code>|</code>）组合在一起，以实现多个模式的组合。例如，<code>std::ios::in | std::ios::binary</code>
表示以二进制只读方式打开文件。</p>
<h2 id="读文件">读文件</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">()</span> </span>{</span><br><span class="line">	std::ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, std::ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) {</span><br><span class="line">		std::cout &lt;&lt; <span class="string">"Failure!\n"</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Method1 以空格为界，依次读取</span></span><br><span class="line">	<span class="comment">/*char buf[1024] = { 0 };</span></span><br><span class="line"><span class="comment">	while (ifs &gt;&gt; buf) {</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; buf &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Method2 以行为界，依次读取</span></span><br><span class="line">	<span class="comment">/*char buf[1024] = { 0 };</span></span><br><span class="line"><span class="comment">	while (ifs.getline(buf, sizeof(buf))) {</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; buf &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Method3 以行为界，依次读取,getline()是属于&lt;string&gt;头文件</span></span><br><span class="line">	<span class="comment">/*std::string buf;</span></span><br><span class="line"><span class="comment">	while (getline(ifs,buf)) {</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; buf &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Method4 逐个字符的读取</span></span><br><span class="line">	<span class="comment">/*char c;</span></span><br><span class="line"><span class="comment">	while ((c = ifs.get()) != EOF) {</span></span><br><span class="line"><span class="comment">		std::cout &lt;&lt; c;</span></span><br><span class="line"><span class="comment">	}*/</span></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="写二进制文件">写二进制文件</h2>
<p>二进制写文件主要利用流对象调用成员函数<code>ofstream&amp; write(const char* buffer, streamsize count);</code>。</p>
<ul>
<li><code>ofstream&amp;</code>：返回类型是一个引用，指向
<code>ofstream</code> 对象，用于实现链式调用。</li>
<li><code>write</code>：函数名，表示要执行写入操作。</li>
<li><code>const char* buffer</code>：这是一个指向字符类型
(<code>char</code>) 的指针，指向要写入到文件的数据的地址。</li>
<li><code>streamsize count</code>：这是一个整数，表示要写入的数据的大小（以字节为单位）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BWrite</span><span class="params">()</span> </span>{</span><br><span class="line">	sstd::ofstream ofs;</span><br><span class="line">	Person p = { <span class="string">"xiunneg"</span>,<span class="number">20</span> };</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">"Btest.txt"</span>, std::ios::binary | std::ios::out);</span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>(const char*)&amp;p</code> 是将 <code>p</code>
对象的内存地址转换为 <code>const char*</code> 类型的指针。这是因为
<code>write()</code> 函数的参数需要一个指向字符类型的指针。</p>
<p><code>sizeof(Person)</code> 返回 <code>Person</code>
对象的大小（以字节为单位）</p>
<h2 id="读二进制文件">读二进制文件</h2>
<p>二进制读文件主要利用流对象调用成员函数<code>ifstream&amp; read(char* buffer, streamsize count);</code>。</p>
<ul>
<li><code>ifstream&amp;</code>：返回类型是一个引用，指向
<code>ifstream</code> 对象，用于实现链式调用。</li>
<li><code>read</code>：函数名，表示要执行读取操作。</li>
<li><code>char* buffer</code>：这是一个指向字符类型 (<code>char</code>)
的指针，用于接收从文件中读取的数据。</li>
<li><code>streamsize count</code>：这是一个整数，表示要读取的数据的大小（以字节为单位）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BRead</span><span class="params">()</span> </span>{</span><br><span class="line">	std::ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">"Btest.txt"</span>, std::ios::binary | std::ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) <span class="keyword">return</span>;</span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">	std::cout &lt;&lt; p.Name &lt;&lt; std::endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>多态【C++】</title>
    <url>/2023/07/26/%E5%A4%9A%E6%80%81%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="多态">多态</h1>
<h2 id="什么是多态">什么是多态？</h2>
<p><code>多态（Polymorphism）</code>是面向对象编程中的一个重要概念，它允许以统一的方式处理不同类型的对象，即一个对象可以表现出多种形态。</p>
<p>在多态中，通过继承和函数重写，派生类可以重写基类的成员函数，使得同一函数名在不同的类中具有不同的实现。然后，通过基类的指针或引用指向派生类的对象，可以在运行时动态地选择调用哪个类的成员函数，而不需要在编译时就确定。</p>
<p>多态分为两类：</p>
<ul>
<li>静态多态</li>
<li>动态多态</li>
</ul>
<span id="more"></span>
<h2 id="静态多态">静态多态</h2>
<p>静态多态性通过<strong>函数重载</strong>和<strong>模板机制</strong>实现，它在编译时根据参数的类型来确定调用哪个函数或模板实例。</p>
<p><strong>静态多态性在编译时就确定了函数调用的具体实现。</strong></p>
<h2 id="动态多态">动态多态</h2>
<p><strong>动态多态（动态多态性，Dynamic Polymorphism）</strong>
动态多态性通过<strong>继承、虚函数和运行时多态实现</strong>。</p>
<p>派生类可以<strong>重写</strong>基类的虚函数，当使用基类的指针或引用指向派生类的对象时，根据指针或引用的<strong>实际</strong>类型来调用相应的函数。</p>
<p>动态多态性在运行时确定了函数调用的具体实现</p>
<h2 id="静态多态与动态多态的区别">静态多态与动态多态的区别</h2>
<p>静态多态（Static Polymorphism）和动态多态（Dynamic
Polymorphism）是多态的两种不同形式，它们在实现机制和运行时行为上有一些区别。</p>
<ol type="1">
<li>实现机制：
<ul>
<li><p>静态多态：静态多态性通过<strong>函数重载</strong>和<strong>模板机制</strong>实现。</p>
<p>函数重载允许在同一作用域内定义多个同名函数，但它们的参数类型或参数个数不同。</p>
<p>在编译时，根据函数调用时<strong>提供的参数类型（函数的签名）</strong>来确定具体调用哪个函数，编译器会进行静态绑定。</p></li>
<li><p>动态多态：动态多态性通过继承和虚函数机制实现。</p>
<p>基类可以<strong>声明虚函数</strong>，派生类可以<strong>重写（覆盖）</strong>基类的虚函数。</p>
<p>在运行时，通过基类的指针或引用指向派生类的对象时，根据对象的实际类型来确定调用哪个函数，这是由编译器和运行时系统共同实现的动态绑定。</p></li>
</ul></li>
<li>调用时机：
<ul>
<li>静态多态：函数重载的解析发生在<strong>编译时</strong>，根据参数的类型和数量确定具体调用哪个函数。编译器通过静态类型进行函数调用的决策。</li>
<li>动态多态：虚函数的调用发生在<strong>运行时</strong>，根据指针或引用的实际类型确定调用的具体函数。运行时系统在运行时根据对象的动态类型进行函数调用的决策。</li>
</ul></li>
<li>继承关系：
<ul>
<li>静态多态：函数重载和模板机制没有直接依赖于继承关系。</li>
<li>动态多态：动态多态性<strong>通过继承和虚函数机制实现</strong>。基类声明了虚函数，派生类可以重写（覆盖）基类的虚函数，运用继承关系来实现多态性。</li>
</ul></li>
<li>运行时开销：
<ul>
<li>静态多态：由于在编译时确定了函数的具体调用，静态多态性没有运行时开销。函数重载和模板的函数展开是在编译阶段完成的。</li>
<li>动态多态：动态多态性需要在运行时进行函数调用的决策，因此相对于静态多态性，会带来一定的运行时开销，包括虚函数指针和虚表的查找。</li>
</ul></li>
</ol>
<h2 id="多态的底层原理">多态的底层原理</h2>
<p>多态的底层原理涉及两个核心概念：<code>虚函数表（vtable）</code>和<code>虚函数指针（vptr）</code>。</p>
<p>当一个类中包含虚函数时，编译器会为该类创建一个虚函数表（vtable）。</p>
<p><strong>虚函数表是一个存储了虚函数地址的表格</strong>，每个虚函数在表格中占据一个位置。<strong>这个表格是类的静态数据成员</strong>，与类的每个对象实例无关。</p>
<p>此外，编译器还会在<strong>类的每个对象实例中添加一个指向虚函数表的指针</strong>，即<strong>虚函数指针（vptr）</strong>。这个指针在对象的内存布局中的位置可能有所不同，但<strong>通常位于对象的起始位置或者附加在该对象的内存上</strong>。</p>
<p>当创建一个对象实例时，编译器会为虚函数表分配内存，并将虚函数地址填充到相应的位置上。同时，<strong>虚函数指针会被设置为指向该对象对应的虚函数表</strong>。</p>
<p>在<strong>使用对象指针或者引用调用虚函数</strong>时，编译器<strong>通过虚函数指针从虚函数表中获取对应的函数地址</strong>。这个过程被称为<strong>动态绑定（dynamic
binding）或者后期绑定（late
binding)</strong>。通过动态绑定，程序能够根据对象的实际类型来调用正确的函数实现，而不仅仅是根据指针或引用的类型。</p>
<p>总结起来，多态的底层原理可以概括为以下几个步骤： 1.
编译器为包含虚函数的类创建虚函数表，其中存储了虚函数的地址。 2.
每个对象实例中添加一个指向对应虚函数表的虚函数指针。 3.
调用虚函数时，通过虚函数指针获取对应的虚函数地址。 4.
根据虚函数地址调用正确的函数实现，实现动态绑定。</p>
<p>这种机制使得代码能够根据对象的实际类型来选择调用适当的函数实现，实现了多态性的特性。</p>
<h2 id="父类指针指向子类对象">父类指针指向子类对象</h2>
<p>可以通过父类指针来告诉编译器所指定的子类对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Animal makes a sound!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Cat says: Meow!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Dog says: Woof!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Animal* animal;</span><br><span class="line"></span><br><span class="line">    Cat cat;</span><br><span class="line">    Dog dog;</span><br><span class="line"></span><br><span class="line">    animal = &amp;cat;</span><br><span class="line">    animal-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Cat says: Meow!</span></span><br><span class="line"></span><br><span class="line">    animal = &amp;dog;</span><br><span class="line">    animal-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="父类引用指向子类对象">父类引用指向子类对象</h2>
<p>将以上案例中的主函数修改成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Cat cat;</span><br><span class="line">    Dog dog;</span><br><span class="line"></span><br><span class="line">    Animal&amp; animal1 = cat;</span><br><span class="line">    animal1.<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Cat says: Meow!</span></span><br><span class="line"></span><br><span class="line">    Animal&amp; animal2 = dog;</span><br><span class="line">    animal2.<span class="built_in">makeSound</span>(); <span class="comment">// 输出：Dog says: Woof!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="纯虚函数和抽象类">纯虚函数和抽象类</h2>
<p>继承的出现使父类中的函数出现了一个问题，那就是一般程序调用的并不是父类中的函数，主要都是重写子类中的同名函数，所以父类中的函数一般是没有意义的，所以父类中的函数一般都会写成<strong>纯虚函数</strong>。</p>
<blockquote>
<p>纯虚函数（Pure Virtual
Function）是一个在基类中声明的虚函数,但没有提供默认的函数实现。纯虚函数的声明使用
<code>=0</code>
来指示，它告诉编译器无法在基类中对该函数提供具体的实现，而是要求派生类对该函数进行实现。</p>
<p>纯虚函数通常用于定义抽象类的接口，它是一种约定，要求派生类必须提供该函数的具体实现来满足基类的接口要求。通过这种方式，基类可以定义一组函数接口，但不提供默认实现，将具体的实现留给派生类去完成。</p>
</blockquote>
<p>纯虚函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> returnType <span class="title">functionName</span><span class="params">(parameters)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>只要有了纯虚函数的类，就是<strong>抽象类</strong>。</p>
<blockquote>
<p>抽象类（Abstract
Class）是一个包含纯虚函数的类，无法直接实例化，只能被其他类继承和使用。抽象类用于定义一个接口和基础行为，而不为这些行为提供具体实现。</p>
<p>抽象类的主要目的是作为其他相关类的基类，它定义了一组接口和纯虚函数，要求派生类必须实现这些接口和纯虚函数，从而完成特定的功能。</p>
</blockquote>
<h2 id="虚析构和纯虚析构">虚析构和纯虚析构</h2>
<p><code>虚析构函数（Virtual Destructor）</code>和<code>纯虚析构函数（Pure Virtual Destructor）</code>是在面向对象编程中用于对对象进行销毁和释放资源的特殊函数。</p>
<p>虚析构函数是在<strong>基类中声明为虚函数的析构函数</strong>。当通过<strong>基类的指针删除对象</strong>时，如果基类的析构函数没有声明为虚函数，可能<strong>会导致派生类的析构函数不被调用</strong>，从而造成资源泄露。通过将基类的析构函数声明为虚函数，可以确保在通过<strong>基类指针删除对象时，会调用正确的析构函数序列。</strong></p>
<p><strong>最大的作用就是让编译器正确的调用析构函数去析构对象。</strong></p>
<p>适用于子类在堆区开辟数据的类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base destructor called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived destructor called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj;  <span class="comment">// 输出：Derived destructor called. Base destructor called.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>继承【C++】</title>
    <url>/2023/07/26/%E7%BB%A7%E6%89%BF%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="继承">继承</h1>
<h2 id="什么是继承">什么是继承</h2>
<p>在C++中，继承是一种对象-oriented（面向对象）编程的特性，它允许你创建一个新的类（称为子类或派生类），并从一个现有的类（称为父类或基类）中<strong>继承属性和方法</strong>。</p>
<p>通过继承，子类可以继承父类的数据成员和成员函数，并且还可以添加自己的数据成员和成员函数。这意味着子类可以重用父类的代码，并且可以通过添加新的功能来扩展它。</p>
<span id="more"></span>
<p>继承可以分为不同的类型：</p>
<ul>
<li>公有继承（public inheritance）</li>
<li>私有继承（private inheritance）</li>
<li>保护继承（protected inheritance）</li>
</ul>
<p>这些不同的类型决定了子类对父类成员的访问权限。</p>
<h2 id="公有继承">公有继承</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>公有继承（public inheritance）是C++中最常见的一种继承方式。</p>
<p>在公有继承中，子类继承了父类的所有<strong>公有成员</strong>和<strong>保护成员</strong>。这意味着子类可以访问父类的公有成员和保护成员，但不能访问<strong>父类的私有成员</strong>。</p>
<h2 id="保护继承">保护继承</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">protected</span> A{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>保护继承（protected inheritance）是C++中另一种继承方式。</p>
<p>在保护继承中，子类继承了父类的<strong>所有保护成员和公有成员</strong>。这意味着子类可以访问父类的保护成员，但不能直接访问父类的公有成员或私有成员。</p>
<h2 id="私有继承">私有继承</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">protected</span> A{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>私有继承（private inheritance）是C++中一种继承方式。</p>
<p>在私有继承中，子类继承了父类的所有<strong>公有成员和保护成员</strong>，但将它们都作为自己的<strong>私有成员</strong>，即对外不可见。</p>
<h2 id="继承的对象模型">继承的对象模型</h2>
<p>父类中的所有属性，子类都会继承下来，只是访问的权限不同。</p>
<p>可以通过VS自带的开发人员工具来看类的模型。</p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 类的文件夹</span><br><span class="line">cl /d1 reportSingleClassLayout(ClassName) (ClaaFile.cpp)</span><br></pre></td></tr></table></figure>
<p><img src="https://img.nickyam.com/file/c6da369a2f38a882c3446.png"></p>
<h3 id="构造和析构的顺序">构造和析构的顺序</h3>
<p>一个原则：<strong>谁是父类谁先构造，谁是子类谁先析构</strong>。</p>
<h2 id="子类中的同名成员">子类中的同名成员</h2>
<p>如果在子类中有与父类中存在一个同名的成员，那么编译器会怎样选择成员呢？</p>
<p>如果直接用<code>.</code>运算符来进行访问，编译器就会用子类中的成员</p>
<p>想要访问父类中的同名成员，就要用<code>::</code>域运算符来指定域。</p>
<p>注意：如果子类中出现了与父类中的同名函数，子类会自动的隐藏父类中的所有同名函数，这时候想要访问父类中的同名函数
，只能用<code>::</code>域运算符。</p>
<h2 id="多继承">多继承</h2>
<p>C++支持多继承的方式，但是不建议使用，可以会出现同名函数的混乱问题,所以<strong>最好不要认两个爹</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class Son : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2{};</span><br></pre></td></tr></table></figure>
<h3 id="菱形继承">菱形继承</h3>
<p>菱形继承，又称钻石继承，是多继承的一种实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {   <span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"动物正在进食"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal {   <span class="comment">// 派生类 Cat 继承自 Animal</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">meow</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"猫在喵喵叫"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal {   <span class="comment">// 派生类 Dog 继承自 Animal</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"狗在汪汪叫"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> : <span class="keyword">public</span> Cat, <span class="keyword">public</span> Dog {   <span class="comment">// 多重继承，继承自 Cat 和 Dog</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  Pet pet;</span><br><span class="line">  pet.<span class="built_in">eat</span>();   <span class="comment">// 方法存在二义性，编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>菱形继承引入了一个二义性问题，编译器无法确定在访问共享基类成员时应该选择哪个继承路径。</p>
<p>比如：<code>Pet</code> 类对象无法直接调用 <code>eat()</code>
方法，因为存在二义性。编译器无法判断应该从 <code>Cat</code> 还是
<code>Dog</code> 继承的 <code>eat()</code> 方法。</p>
<p>为了解决菱形继承带来的问题，可以使用<code>虚继承（virtual inheritance）</code>。通过在共享基类前面使用
<code>virtual</code>
关键字，可以确保只有一份共享基类的实例。修改上面的示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {   <span class="comment">// 基类 Animal</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"动物正在进食"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Animal {   <span class="comment">// 派生类 Cat 继承自 Animal，虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">meow</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"猫在喵喵叫"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Animal {   <span class="comment">// 派生类 Dog 继承自 Animal，虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"狗在汪汪叫"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> : <span class="keyword">public</span> Cat, <span class="keyword">public</span> Dog {   <span class="comment">// 多重继承，继承自 Cat 和 Dog</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  Pet pet;</span><br><span class="line">  pet.<span class="built_in">eat</span>();   <span class="comment">// 正常调用共享基类的成员函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符的重载【C++】</title>
    <url>/2023/07/25/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="运算符重载">运算符重载</h1>
<h2 id="什么是运算符重载">什么是运算符重载？</h2>
<p>对于内置的数据类型，编译器知道如何运算，但是自定义的数据类型编译器不知道如何进行运算，这时就要重载运算符来告诉编译器运算的规则。</p>
<p>对已有的运算符进行重新的定义，赋予其功能，以适应不同的数据类型。</p>
<p>要进行重载时，使用<code>operator</code>来进行符号的重载。</p>
<p>重载函数可以是成员函数，也可以是全局函数。</p>
<p>运算符的重载也可以发送函数的重载。</p>
<span id="more"></span>
<h2 id="重载加号运算符">重载加号运算符</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Cuboid Cuboid::<span class="keyword">operator</span>+(Cuboid&amp; other)</span><br><span class="line">{</span><br><span class="line">	Cuboid new_Cuboid = <span class="built_in">Cuboid</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	new_Cuboid.Len = <span class="keyword">this</span>-&gt;Len + other.Len;</span><br><span class="line">	new_Cuboid.Wid = <span class="keyword">this</span>-&gt;Wid + other.Wid;</span><br><span class="line">	<span class="keyword">return</span> new_Cuboid;</span><br><span class="line">}</span><br><span class="line">Cuboid Cuboid::<span class="keyword">operator</span>+(<span class="type">int</span> addend)</span><br><span class="line">{</span><br><span class="line">	Cuboid new_Cuboid = <span class="built_in">Cuboid</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	new_Cuboid.Len = <span class="keyword">this</span>-&gt;Len + addend;</span><br><span class="line">	new_Cuboid.Wid = <span class="keyword">this</span>-&gt;Wid + addend;</span><br><span class="line">	<span class="keyword">return</span> new_Cuboid;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>this</code>是加号的左值，<code>other</code>是加号的右值，其本质是调用函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c3 = c1.<span class="keyword">operator</span> +(c2);</span><br></pre></td></tr></table></figure>
<h2 id="重载左移运算符">重载左移运算符</h2>
<p>一般不在成员函数中重载左移运算符，因为无法实现<code>cout</code>在左侧，所以在全局函数中定义了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; cout, Cuboid cuboid)</span><br><span class="line">{</span><br><span class="line">	cout &lt;&lt; cuboid.<span class="built_in">getLen</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; cuboid.<span class="built_in">getWid</span>();</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>std::ostream</code>是C++标准库中用于输出的基类。它定义了一些成员函数，如<code>operator&lt;&lt;</code>，用于将数据输出到输出流中。<code>std::ostream</code>是一个抽象类，不能直接实例化，但可以通过派生出的类（如<code>std::cout</code>）来使用</p>
</blockquote>
<p>返回<code>std::ostream&amp;</code>是为了之后能用<code>&lt;&lt;</code>来输出别的内容（链式思想）。</p>
<h2 id="重载递增运算符">重载递增运算符</h2>
<h3 id="前置递增">前置递增</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Cuboid&amp; Cuboid::<span class="keyword">operator</span>++()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;Len++;</span><br><span class="line">	<span class="keyword">this</span>-&gt;Wid++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注意是返回<strong>引用类型</strong>，否则无法对原数据的修改。</p>
<h3 id="后置递增">后置递增</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Cuboid Cuboid::<span class="keyword">operator</span>++(<span class="type">int</span>) <span class="comment">// 后置递增</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//先记录当前的结果</span></span><br><span class="line">	<span class="function">Cuboid <span class="title">cur_Cuboid</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;Len++;</span><br><span class="line">	<span class="keyword">this</span>-&gt;Wid;</span><br><span class="line">	<span class="keyword">return</span> cur_Cuboid;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>注意后置递增返回的是<strong>值</strong>,且为了区分前置递增，只能用<code>int占位符</code>进行函数重载，编译器会解读成后置递增。</p>
<h2 id="重载赋值运算符">重载赋值运算符</h2>
<p>在C++中，当我们定义一个类时，如果没有显式地重载赋值运算符（<code>operator=</code>），编译器会为我们自动生成一个默认的赋值运算符。</p>
<p>默认的赋值运算符执行逐个成员的赋值操作，将一个对象的值复制到另一个对象中。对于简单的成员变量，这通常是有效的。但对于包含动态内存分配的成员，比如指针或动态数组，仅仅进行浅拷贝赋值是不够安全的。因为可能会导致<strong>堆区内存的重复释放</strong>，而导致程序崩溃。</p>
<p>因此，当类中存在动态内存分配的成员变量时，<strong>我们需要显式地重载赋值运算符来确保正确地进行对象的赋值操作</strong>。重载赋值运算符可以执行<strong>深拷贝</strong>，即逐个复制成员变量或执行其他自定义的赋值操作。</p>
<p>重载赋值运算符的常见形式是将成员变量从一个对象赋值给另一个对象，利用深拷贝来确保对象内存的正确复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Cuboid&amp; Cuboid::<span class="keyword">operator</span>=(<span class="type">const</span> Cuboid&amp; other)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 检查自我赋值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) {</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放已分配的内存</span></span><br><span class="line">	<span class="keyword">delete</span> LenPointer;</span><br><span class="line">	<span class="keyword">delete</span> WidPointer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行深拷贝</span></span><br><span class="line">	LenPointer = <span class="keyword">new</span> <span class="built_in">int</span>(*other.LenPointer);</span><br><span class="line">	WidPointer = <span class="keyword">new</span> <span class="built_in">int</span>(*other.WidPointer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意，指针对象要实例化,分配地址</span></span><br><span class="line"><span class="comment">//LenPointer = new int(len);</span></span><br><span class="line"><span class="comment">//WidPointer = new int(wid);</span></span><br></pre></td></tr></table></figure>
<h2 id="重载关系运算符">重载关系运算符</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> Cuboid::<span class="keyword">operator</span>==(<span class="type">const</span> Cuboid&amp; other)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">return</span> (<span class="keyword">this</span>-&gt;Len == other.Len &amp;&amp; <span class="keyword">this</span>-&gt;Wid == other.Wid);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Cuboid::<span class="keyword">operator</span>!=(<span class="type">const</span> Cuboid&amp; other)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> !(<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>== (other));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="重载函数调用运算符仿函数">重载函数调用运算符（仿函数）</h2>
<p>因为调用十分相似函数，得名仿函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cuboid::operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> wid)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//重设长宽</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;Len = len;</span><br><span class="line">	<span class="keyword">this</span>-&gt;Wid = wid;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数对象">匿名函数对象</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Cuboid</span>()(<span class="number">100</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>用之即弃的对象。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>友元【C++】</title>
    <url>/2023/07/25/%E5%8F%8B%E5%85%83%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="友元">友元</h1>
<h2 id="什么是友元friend">什么是友元(Friend)</h2>
<p><code>友元（Friend）</code>是C++中的一种特殊关系，它允许<strong>某个类或函数</strong>访问另一个类的私有成员。通过将一个类或函数声明为另一个类的友元，就可以在友元类或函数中<strong>直接</strong>访问该类的私有成员。</p>
<p>友元关系是一种单向的关系，不具有传递性。</p>
<span id="more"></span>
<h2 id="友元的实现">友元的实现</h2>
<h3 id="全局函数做友元">全局函数做友元</h3>
<p>只要将全局函数用<code>friend</code>关键字声明在类中即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getData</span><span class="params">(TestClass* Cpoint)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) {};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getData</span><span class="params">(TestClass* Cpoint)</span> </span>{cout &lt;&lt; Cpoint-&gt;data &lt;&lt; endl;}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">TestClass <span class="title">tc</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">getData</span>(&amp;tc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="类做友元">类做友元</h3>
<p>将类用<code>friend</code>关键字声明在类中时，友元中的函数可以访问私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getData</span><span class="params">(TestClass* Cpoint)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) {};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestClass* Cpoint;</span><br><span class="line">    <span class="built_in">FriendClass</span>(TestClss* cpoint) : <span class="built_in">Cpoint</span>(cpoint) {cout &lt;&lt; Cpoint-&gt;data &lt;&lt; endl;};</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h3 id="成员函数做友元">成员函数做友元</h3>
<p>只要像之前定义全局函数做友元时一样将函数声明在类中，但是这时要加上函数所在的<strong>域</strong>：<code>friend functype classname::funcname(params)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TestClass* point;</span><br><span class="line">	<span class="built_in">FriendClass</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> {</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">FriendClass::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data_private;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> data_public;</span><br><span class="line">	<span class="built_in">TestClass</span>(<span class="type">int</span> value);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TestClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于有嵌套的关系，所以建议提前声明类。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象的基础与对象特性【C++】</title>
    <url>/2023/07/25/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%E3%80%90C++%E3%80%91/</url>
    <content><![CDATA[<h1 id="类与面向对象">类与面向对象</h1>
<p><strong>C++</strong>面向对象的三大特性：<code>封装</code>、<code>继承</code>、<code>多态</code>。<br>
&gt;
面向对象(Object-Oriented)是一种软件开发的方法论，它将程序中的数据和操作数据的逻辑封装在一起，以形成对象的概念，对象可以互相之间进行交互和通信。</p>
<span id="more"></span>
<h2 id="名词解释">名词解释</h2>
<h3 id="什么是类">什么是类？</h3>
<p>类(<code>Class</code>):
类是对象的抽象，它定义了一个对象的<strong>属性</strong>和<strong>方法</strong>。类可以看作是<strong>创建对象的模板或蓝图</strong>。</p>
<h4 id="struct-和-class-之间的区别">struct 和 class 之间的区别</h4>
<p>struct 和 class 之间的区别
在许多编程语言中，包括C++和C#等，都支持使用<code>struct</code>和<code>class</code>来定义数据结构和数据类型。下面是<code>struct</code>和<code>class</code>之间的主要区别：</p>
<ol type="1">
<li>成员的默认访问权限：
<code>class</code>是私有，<code>struct</code>公有。</li>
<li>继承能力：
<code>class</code>支持继承，<code>struct</code>不支持继承。</li>
<li>分配方式：
<code>class</code>是引用类型数据（堆区），<code>struct</code>是值类型数据（栈区）。</li>
<li>默认的拷贝方法：<code>class</code>是浅拷贝，<code>struct</code>逐成员拷贝。</li>
</ol>
<h3 id="什么是对象">什么是对象？</h3>
<p>对象(<code>Object</code>)是****类的实例<strong>，它是</strong>具体的<strong>、</strong>实际存在**的数据实体，具有类所定义的属性和方法。</p>
<h3 id="什么是封装">什么是封装？</h3>
<p>封装(<code>Encapsulation</code>):
封装是将<strong>数据</strong>和<strong>操作数据的方法</strong>绑定在一起，通过<strong>限制对数据的访问</strong>，确保数据的<strong>完整性</strong>和<strong>安全性</strong>。</p>
<h3 id="什么是继承">什么是继承？</h3>
<p>继承(<code>Inheritance</code>):
继承<strong>允许一个类继承另一个类</strong>的特性和行为，从而实现代码的重用和扩展</p>
<h3 id="什么是多态">什么是多态？</h3>
<p>多态(<code>Polymorphism</code>):
多态允许使用<strong>统一的接口</strong>来操作<strong>不同类型的对象</strong>，提供了代码的灵活性和可维护性。</p>
<h2 id="封装">封装</h2>
<p>在面向对象编程中，封装可以帮助保护数据和方法的访问权限，确保对数据的访问和操作符合预期并符合设计意图。</p>
<h3 id="访问权限">访问权限</h3>
<p>权限的控制有三种： 1. <code>public</code> 公共权限<br>
公开访问表示成员（属性或方法）对<strong>所有对象和其他类</strong>可见，并且可以被直接访问和调用。
2. <code>private</code> 私有权限<br>
私有访问表示成员<strong>仅对所属类内部</strong>可见，其他类无法直接访问私有成员。私有成员只能被类内部的方法所使用。
3. <code>protected</code> 保护权限<br>
保护访问类似于私有访问，但<strong>对于继承关系中的子类</strong>是可见的。即子类可以访问基类的保护成员，但其他类无法直接访问。但是仅仅也只是保护权限的内容。</p>
<h3 id="私有权限">私有权限</h3>
<p>在将成员设置为私有时，一般会写一些公共方法来对私有成员进行读写的操作，即<code>get()</code>和<code>set()</code>方法。</p>
<p>这样就可以对数据的读写性进行控制，只要不写私有成员<code>get</code>或<code>set</code>方法就可以了。</p>
<p>这样还可以对数据的输入进行控制，只要在<code>set()</code>中添加判断逻辑，就可以控制数据的有效范围。</p>
<h3 id="如何判断两个对象是否相等">如何判断两个对象是否相等</h3>
<p>有两种方法：</p>
<ol type="1">
<li>定义全局函数（不建议）</li>
<li>定义成员函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">student::isEqual</span><span class="params">(student stu)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> stu.<span class="built_in">getName</span>() == <span class="keyword">this</span>-&gt;Name &amp;&amp; stu.<span class="built_in">getGender</span>() == <span class="keyword">this</span>-&gt;Gender &amp;&amp; stu.<span class="built_in">getAge</span>() == <span class="keyword">this</span>-&gt;Age;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="对象的初始化和清理">对象的初始化和清理</h2>
<h3 id="构造函数">构造函数</h3>
<p>在实例化对象的时候自动的调用。</p>
<p>如果不写构造函数，对象会默认创建对象的默认的无参构造函数。</p>
<p>函数名与类名相同。</p>
<h4 id="构造函数的分类">构造函数的分类</h4>
<p>按参数分：</p>
<ol type="1">
<li>无参构造</li>
<li>有参构造</li>
</ol>
<p>按调用的分类：</p>
<ol type="1">
<li><p>拷贝构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">student</span>(<span class="type">const</span> student &amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="function">student <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>const</code>是因为不能改变原先对象的值</p>
<p><code>&amp;</code>引用是因为防止递归调用</p></li>
<li><p>显式构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">student s1 = <span class="built_in">student</span>(<span class="string">"xiunneg"</span>,student::GENDER::Male, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p><code>student("xiunneg",student::GENDER::Male, 13);</code>是一个<code>匿名对象</code>。</p></li>
<li><p>隐式构造（不建议，仅仅适用于单个参数的构造）</p></li>
</ol>
<h4 id="拷贝构造注意事项">拷贝构造注意事项</h4>
<p>当对象被以值的形式传递时会调用到拷贝构造函数。。</p>
<h3 id="析构函数">析构函数</h3>
<p>用于对象的销毁前会自动调用来销毁对象。</p>
<p>函数名为：<code>~类名()</code></p>
<h3 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h3>
<p>浅拷贝： 简单的赋值拷贝操作</p>
<p>深拷贝： 在堆区重新申请空间，进行拷贝操作</p>
<p>这两种拷贝的区别就是对于指针类型的数据的操作。</p>
<p>以下用<code>A</code>对象指源对象，<code>B</code>对象指通过拷贝构造<code>A</code>对象而得到的对象。</p>
<p>浅拷贝对于指针类型的复制只会复制指针的值，不会拷贝指针指向的值，就是说两个对象中的指针成员所指向的是同一个内存空间，通过<code>A</code>对象可以修改通过浅拷贝复制构造出的<code>B</code>对象的值。</p>
<p>深拷贝要求将指针的数据类型重新分配内存地址，再去赋值，这样就在修改<code>B</code>对象时不会修改<code>A</code>对象的数据了，因为指针指的不是同一块内存地址了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Person::Person</span><span class="params">(<span class="type">const</span> Person &amp;other)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *data = *(other.data);</span><br><span class="line">    cout &lt;&lt; <span class="string">"深拷贝"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Person::Person</span><span class="params">(<span class="type">const</span> Person &amp;other)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    data = other.data;</span><br><span class="line">    cout &lt;&lt; <span class="string">"浅拷贝"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表">初始化列表</h3>
<p>用于初始化属性的语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> A;</span><br><span class="line">    <span class="type">int</span> B;</span><br><span class="line">    <span class="type">int</span> C;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Class</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c) : <span class="built_in">A</span>(a),<span class="built_in">B</span>(b),<span class="built_in">C</span>(c) {};</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="对象成员">对象成员</h3>
<p>类的成员也可以是别的类的对象。</p>
<p>那么它们的构造函数和析构函数的调用顺序是怎样的呢？</p>
<p>遵循一个原则，<strong>谁在外部谁先构造，谁在内部谁先析构</strong>。</p>
<h3 id="静态成员">静态成员</h3>
<p>被关键词<code>static</code>修饰过变量或者函数被称为静态成员，它们有以下特点：</p>
<ol type="1">
<li><strong>静态成员属性</strong>：它是属于类本身的属性，而不是属于实例化对象的属性，也就是说所有的实例化对象共有这个成员，所有的对象实例的这个值是一样的。</li>
<li><strong>静态成员函数</strong>：它无法访问非静态成员属性，也无法使用<code>this</code>指针。静态成员函数可以通过类名来直接调用，不需要通过类的实例。</li>
<li><strong>静态成员的访问控制</strong>：静态成员遵循类的访问控制规则。私有的静态成员只能被类内的函数访问，公有的静态成员可以被任何使用类的代码访问。</li>
</ol>
<p>静态成员一般不会通过实例来访问，都是使用类名来进行访问：<code>classname::static member</code>。</p>
<h2 id="c对象模型">C++对象模型</h2>
<h3 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h3>
<p>空对象的占用内存空间是1，是因为编译器会将空对象分配一个字节空间，为了区分对象占内存的位置。</p>
<p>对象的内存空间中只会存储对象中的非静态的成员属性和虚函数表，函数成员存储在类的代码段中。</p>
<p><strong>静态成员属性</strong>在类内部声明，在类的代码段中进行定义和初始化，并且存储在全局数据区（Global
Data Segment）</p>
<h3 id="this指针">this指针</h3>
<p><code>this指针</code>的本质是<code>classname* const this</code>，是一个指针常量。</p>
<p>一个非静态成员函数只会生成一份函数实例，也就是多个同类型的对象会去调用同一个函数实例，那如果区分调用的对象就成了一个问题。</p>
<p><code>this指针</code>可以解决这个问题。</p>
<p><code>this指针</code>是C++
提供的特殊对象指针，this指针指向被调用的成员函数所属的对象。</p>
<p>用处如下：</p>
<ul>
<li>当函数的参数与类的属性同名时，需要通过<code>this</code>来区分。</li>
<li>在类的非静态成员函数返回对象本身时，可使用<code>return *this</code>，同时函数的返回类型也要写成类对象的引用类型<code>Person&amp; func(Person p1) {return *this}</code>，否则返回的是一个新的值，利用是函数可以链式调用。</li>
</ul>
<h3 id="const修饰的成员函数">const修饰的成员函数</h3>
<ul>
<li><p>常函数</p>
<p>成员函数后加<code>const</code>后我们称这个函数为<strong>常函数</strong>。其本质是修饰了<code>this</code>指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Testfunc</span><span class="params">()</span> <span class="type">const</span> </span>{};</span><br><span class="line"></span><br><span class="line">classname* <span class="type">const</span> <span class="keyword">this</span> ----&gt; <span class="type">const</span> classname* <span class="type">const</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>被设置为常函数后，函数的内部不能修改成员属性，也就是设置了该函数为<strong>只读</strong>。</p>
<p>如果想要在常函数中修改属性，只要在想要修改的对象前用<code>mutable</code>修饰即可。</p></li>
<li><p>常对象</p>
<p>声明对象前加<code>const</code>称该对象为常对象</p>
<p>常对象只能调用常函数。</p></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C++语言学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium爬取实战【爬虫】</title>
    <url>/2023/07/23/Selenium%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="selenium爬取实战">Selenium爬取实战</h1>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>安装好了<code>Chrome</code>并且配置好了<code>ChromeDriver</code></li>
<li>安装好了<code>Python3</code></li>
<li>安装好了<code>Selenium</code>以及相关的包，并且保证正确打开<code>Chrome</code></li>
</ul>
<span id="more"></span>
<h2 id="爬取目标">爬取目标</h2>
<p>爬虫示例网站：<code>https://spa2.scrape.center/</code>。</p>
<p>这个网站使用了Ajax渲染，但是仔细观察URL的构成可以发现，详情页和列表页的URL都变为了<code>Base64</code>的格式，这代表我们不能够通过构造URL来爬取各个页面的内容了，因为加密参数<code>token</code>每次都会变化。</p>
<p>所以这个时候使用<code>selenium</code>来模拟浏览器来绕过构造URL的过程，直接获取<code>JavaScript</code>渲染完成之后的页面源代码就可以了。</p>
<h2 id="代码编写">代码编写</h2>
<h3 id="爬取列表页">爬取列表页</h3>
<h4 id="页面分析">页面分析</h4>
<p>列表页的URL没有进行加密，URL构造为：<code>https://spa2.scrape.center/page/{page}</code></p>
<h4 id="实现">实现</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志输出格式</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,<span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa2.scrape.center/page/{page}'</span>    <span class="comment"># 列表页的URL构造</span></span><br><span class="line">TIME_OUT = <span class="number">10</span>                                           <span class="comment"># 延时</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span>                                         <span class="comment"># 总页数</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()                            <span class="comment"># 将浏览器初始化为Chorme浏览器</span></span><br><span class="line">wait = WebDriverWait(browser,TIME_OUT)                  <span class="comment"># 显示设置延时   </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="爬取列表页-1">爬取列表页</h3>
<h4 id="页面">页面</h4>
<p><img src="https://img.nickyam.com/file/e9a396c4c3de9eb232ecb.png"></p>
<p>页面的详情页列表如图所示，所以用CSS选择器去选择。</p>
<h4 id="实现-1">实现</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_page</span>(<span class="params">url,condition,locator</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    爬取的通用函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url (_type_): 待爬取的页面URL</span></span><br><span class="line"><span class="string">        condition (_type_): 页面加载成功的判断条件</span></span><br><span class="line"><span class="string">        locator (_type_): 定位器，是一个元组，通过配置查询条件和参数来查找节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">'scraping %s'</span>,url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(url)</span><br><span class="line">        wait.until(condition(locator))</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        logging.error(<span class="string">'error occured while scraping %s'</span>,url,exe_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_Index</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        page (_type_): 页面的秩</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page) <span class="comment"># 构造详情页的URL</span></span><br><span class="line">    scrape_page(url=url,condition=EC.visibility_of_all_elements_located,locator=(By.CLASS_NAME,<span class="string">'#index .item'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="解析列表页">解析列表页</h3>
<h4 id="实现-2">实现</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_index</span>():</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    分割URL的加密参数</span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        str: 解析之后的URL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    elements = browser.find_elements(by=By.CSS_SELECTOR,value=<span class="string">'#index .item .name'</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        href=element.get_attribute(<span class="string">'href'</span>)</span><br><span class="line">        <span class="keyword">yield</span> urljoin(INDEX_URL,href)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    爬取的主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">            scrape_Index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            logging.info(<span class="string">'detail urls %s'</span>,<span class="built_in">list</span>(detail_urls))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br></pre></td></tr></table></figure>
<p>这个直接遍历了所有的页码，依次爬取了每一个列表页的URL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-07-23 12:12:08,395 - INFO : scraping https://spa2.scrape.center/page/1</span><br><span class="line">2023-07-23 12:12:10,579 - INFO : detail urls ['https://spa2.scrape.center/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx', 'https://spa2.scrape.center/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIy',</span><br><span class="line">...</span><br><span class="line">2023-07-23 12:12:20,003 - INFO : scraping https://spa2.scrape.center/page/10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到爬取了那些加密的URL。</p>
<h3 id="爬取详情页">爬取详情页</h3>
<p>基于同样的逻辑，在等待加载完之后，调用爬取详情页的函数就可以了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    调用scrape_page()来爬取详情页的信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url (str): 详情页的URL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># h2的节点是调用名称对应的节点</span></span><br><span class="line">    scrape_page(url=url, condition=EC.visibility_of_all_elements_located,</span><br><span class="line">                locator=(By.CSS_SELECTOR, <span class="string">'h2'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>():</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    爬取详情页</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = browser.current_url</span><br><span class="line">    name = browser.find_element(by=By.TAG_NAME, value=<span class="string">'h2'</span>)</span><br><span class="line">    categories = [element.text <span class="keyword">for</span> element <span class="keyword">in</span> browser.find_elements(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">'.categories button span'</span>)]</span><br><span class="line">    cover = browser.find_element(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">'.cover'</span>).get_attribute(<span class="string">'src'</span>)</span><br><span class="line">    score = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'score'</span>).text</span><br><span class="line">    drama = browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">'.drama p'</span>).text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="string">'url'</span>: url,</span><br><span class="line">        <span class="string">'name'</span>: name,</span><br><span class="line">        <span class="string">'categories'</span>: categories,</span><br><span class="line">        <span class="string">'cover'</span>: cover,</span><br><span class="line">        <span class="string">'score'</span>: score,</span><br><span class="line">        <span class="string">'drama'</span>: drama</span><br><span class="line">    }</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="改写main">改写main</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    爬取的主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">            scrape_Index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            <span class="comment"># logging.info('detail urls %s', list(detail_urls))</span></span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">'get detail url %s'</span>, detail_url)</span><br><span class="line">                scrape_detail(detail_url)</span><br><span class="line">                detail_data = parse_detail()</span><br><span class="line">                logging.info(<span class="string">'detail data %s'</span>, detail_data)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br></pre></td></tr></table></figure>
<h2 id="存储到mongodb">存储到MongoDB</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'Selenium'</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">'movies'</span></span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    将JSON数据存储到MongoDB</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data (dict): 爬取的数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    collection.update_one({<span class="string">'name'</span>: data.get(<span class="string">'name'</span>)},</span><br><span class="line">                          {<span class="string">'$set'</span>: data}, upsert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>改写main()</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    爬取的主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">            scrape_Index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            <span class="comment"># logging.info('detail urls %s', list(detail_urls))</span></span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">'get detail url %s'</span>, detail_url)</span><br><span class="line">                scrape_detail(detail_url)</span><br><span class="line">                detail_data = parse_detail()</span><br><span class="line">                save_data(detail_data)</span><br><span class="line">                logging.info(<span class="string">'detail data saved successful!'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完整代码">完整代码</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># 设置日志输出格式</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa2.scrape.center/page/{page}'</span>    <span class="comment"># 列表页的URL构造</span></span><br><span class="line">TIME_OUT = <span class="number">10</span>                                           <span class="comment"># 延时</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span>                                         <span class="comment"># 总页数</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'Selenium'</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">'movies'</span></span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浏览器初始化为Chorme浏览器</span></span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">wait = WebDriverWait(browser, TIME_OUT)                  <span class="comment"># 显示设置延时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_page</span>(<span class="params">url, condition, locator</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    爬取的通用函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url (str): 待爬取的页面URL</span></span><br><span class="line"><span class="string">        condition (bool): 页面加载成功的判断条件</span></span><br><span class="line"><span class="string">                            一般是EC.visibility_of_all_elements_located。</span></span><br><span class="line"><span class="string">                            EC.visibility_of_all_elements_located 是 Selenium 中的一个条件，用于等待页面上所有元素都可见。</span></span><br><span class="line"><span class="string">                            或者是EC.visibility_of_elements_located</span></span><br><span class="line"><span class="string">                            EC.visibility_of_elements_located 是 Selenium 中的一个条件，用于等待页面上至少一个元素可见。</span></span><br><span class="line"><span class="string">        locator (tuple): 定位器，是一个元组，通过配置查询条件和参数来查找节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">'scraping %s'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(url)  <span class="comment"># 获取页面</span></span><br><span class="line">        wait.until(condition(locator))  <span class="comment"># 延时等待</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        logging.error(<span class="string">'error occured while scraping %s'</span>, url, exe_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_Index</span>(<span class="params">page</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    爬取详情页</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        page (int): 页面的秩</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page=page)  <span class="comment"># 构造详情页的URL</span></span><br><span class="line">    scrape_page(url=url, condition=EC.visibility_of_all_elements_located,</span><br><span class="line">                locator=(By.CSS_SELECTOR, <span class="string">'#index .item'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_index</span>():</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    分割URL的加密参数</span></span><br><span class="line"><span class="string">    Yields:</span></span><br><span class="line"><span class="string">        str: 解析之后的URL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    elements = browser.find_elements(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">'#index .item .name'</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        href = element.get_attribute(<span class="string">'href'</span>)</span><br><span class="line">        <span class="keyword">yield</span> urljoin(INDEX_URL, href)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    调用scrape_page()来爬取详情页的信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url (str): 详情页的URL</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># h2的节点是调用名称对应的节点</span></span><br><span class="line">    scrape_page(url=url, condition=EC.visibility_of_all_elements_located,</span><br><span class="line">                locator=(By.CSS_SELECTOR, <span class="string">'h2'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>():</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    爬取详情页</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = browser.current_url</span><br><span class="line">    name = browser.find_element(by=By.TAG_NAME, value=<span class="string">'h2'</span>).text</span><br><span class="line">    categories = [element.text <span class="keyword">for</span> element <span class="keyword">in</span> browser.find_elements(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">'.categories button span'</span>)]</span><br><span class="line">    cover = browser.find_element(</span><br><span class="line">        by=By.CSS_SELECTOR, value=<span class="string">'.cover'</span>).get_attribute(<span class="string">'src'</span>)</span><br><span class="line">    score = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'score'</span>).text</span><br><span class="line">    drama = browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">'.drama p'</span>).text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="string">'url'</span>: url,</span><br><span class="line">        <span class="string">'name'</span>: name,</span><br><span class="line">        <span class="string">'categories'</span>: categories,</span><br><span class="line">        <span class="string">'cover'</span>: cover,</span><br><span class="line">        <span class="string">'score'</span>: score,</span><br><span class="line">        <span class="string">'drama'</span>: drama</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">"""_summary_</span></span><br><span class="line"><span class="string">    将JSON数据存储到MongoDB</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        data (dict): 爬取的数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    collection.update_one({<span class="string">'name'</span>: data.get(<span class="string">'name'</span>)},</span><br><span class="line">                          {<span class="string">'$set'</span>: data}, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    爬取的主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">            scrape_Index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            <span class="comment"># logging.info('detail urls %s', list(detail_urls))</span></span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">'get detail url %s'</span>, detail_url)</span><br><span class="line">                scrape_detail(detail_url)</span><br><span class="line">                detail_data = parse_detail()</span><br><span class="line">                save_data(detail_data)</span><br><span class="line">                logging.info(<span class="string">'detail data saved successful!'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'seccessful!'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python3爬虫基础,爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript动态渲染页面爬取</title>
    <url>/2023/07/22/JavaScript%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%88%AC%E5%8F%96%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="javascript动态渲染页面爬取">JavaScript动态渲染页面爬取</h1>
<h2 id="复杂的页面动态渲染爬取难题">复杂的页面动态渲染爬取难题</h2>
<p><code>Ajax</code>数据的分析和爬取方式，其实也是<code>JavaAScript</code>动态渲染页面的一种情形，通过直接分析<code>Ajax</code></p>
<p>，可以让<code>requests</code>和<code>urllib</code>也可以来爬取数据。</p>
<p>但是<code>Ajax</code>也只是<code>JavaAScript</code>的一种动态渲染方式的一种而已，还有很多的页面渲染的方式。</p>
<p>有些时候<code>Ajax</code>接口也有很多的加密参数，让分析<code>Ajax</code>来爬取数据时也有很多的困难。</p>
<p><strong>为了解决这些问题，可以直接模拟浏览器运行，再去爬取数据</strong>。</p>
<p>这样就可以实现在浏览器中看到的是什么，爬到的就是什么，实现<strong>所见即所爬</strong>。</p>
<span id="more"></span>
<h2 id="如何获取加密的ajax数据">如何获取加密的<code>Ajax</code>数据</h2>
<p>在实战中<code>Ajax</code>的接口一般都是有加密参数的，如<code>token</code>、<code>sign</code>之类的，只有在使用正确的参数数据才能获得数据。</p>
<p>获得这些加密参数的方法有两种：</p>
<ul>
<li>分析逻辑，找到构造逻辑。（非常难！）</li>
<li>直接以浏览器的方式运行，因为浏览器里是可以看到这个数据的。</li>
</ul>
<p>而<code>Selenium</code>这个工具就可以完成第二种操作。</p>
<h2 id="selenium简介">Selenium简介</h2>
<p><code>Selenium</code>是一个自动化测试工具，使用它可以驱动浏览器完成特定的操作。</p>
<p>可以使用它来获取浏览器当前呈现页面的源代码。</p>
<p>对于用<code>JavaScript</code>动态渲染的页面来说，这种爬取方式非常有效。</p>
<h3 id="准备工作">准备工作</h3>
<p>确保安装好了<code>Chrome</code>浏览器,配置好<code>ChromeDriver</code>，注意要保持版本一致,让后将<code>ChromeDriver.exe</code>移到<code>Python</code>中的<code>Scripts</code>目录</p>
<blockquote>
<p>官方安装地址：<a href="https://www.google.cn/chrome/index.html">Google Chrome
网络浏览器</a>（最新版本可能没有对应的<code>ChromeDriver</code>） <a href="https://www.slimjet.com/chrome/google-chrome-old-version.php">低版本Chrome镜像站</a>
<a href="http://chromedriver.storage.googleapis.com/index.html">ChromeDriver下载地址</a></p>
</blockquote>
<p>安装好<code>Selenium</code>库</p>
<p><code>pip install selenium</code></p>
<p>更多的操作可以参照官方文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/">Selenium
with Python中文翻译文档 — Selenium-Python中文文档 2 documentation
(selenium-python-zh.readthedocs.io)</a></p>
<h3 id="基本用法">基本用法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 导入selenium库中的webdriver模块，用于驱动浏览器进行自动化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="comment"># 导入selenium库中的By模块，用于指定元素定位方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="comment"># 导入selenium库中的Keys模块，用于模拟键盘操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="comment"># 导入selenium库中的EC模块，用于等待条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="comment"># 导入selenium库中的WebDriverWait模块，用于等待页面元素加载</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 创建一个Chrome浏览器的实例，用于自动化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">'https://baidu.com'</span>)</span><br><span class="line">    <span class="comment"># 使用浏览器打开网页https://baidu.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># browser.find_element_by('kw') 方法已更新为以下方式</span></span><br><span class="line">    <span class="built_in">input</span> = browser.find_element(By.ID, <span class="string">'kw'</span>)</span><br><span class="line">    <span class="comment"># 使用By.ID定位方式，找到id为'kw'的输入框元素，并将其赋值给input变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span>.send_keys(<span class="string">'Python'</span>)</span><br><span class="line">    <span class="comment"># 在输入框中输入关键字'Python'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span>.send_keys(Keys.ENTER)</span><br><span class="line">    <span class="comment"># 模拟键盘按下Enter键，提交搜索</span></span><br><span class="line"></span><br><span class="line">    wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 设置一个最长等待时间为10秒的WebDriverWait对象，用于等待页面元素出现</span></span><br><span class="line"></span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID, <span class="string">'content_left'</span>)))</span><br><span class="line">    <span class="comment"># 等待直到'id'为'content_left'的元素出现在页面中，即等待搜索结果加载完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(browser.current_url)</span><br><span class="line">    <span class="comment"># 打印当前页面的URL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">    <span class="comment"># 打印当前页面的所有cookie信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(browser.page_source)</span><br><span class="line">    <span class="comment"># 打印当前页面的源代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br><span class="line">    <span class="comment"># 关闭浏览器窗口</span></span><br></pre></td></tr></table></figure>
<p>这个基本实例演示了如何调用<code>Chrome</code>来浏览百度的页面并且搜索Python的操作，之后会跳转到搜索结果的页面。</p>
<p>用<code>selenium</code>来操作<code>Chrome</code>浏览器来加载网页，可以直接拿到JavsScript渲染的结果。</p>
<h2 id="selenium的使用">Selenium的使用</h2>
<h3 id="初始化浏览器对象">初始化浏览器对象</h3>
<p><code>Selenium</code>支持的浏览器非常多</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser_Chrome = webdriver.Chrome()</span><br><span class="line">browser_Safari = webdriver.Safari()</span><br><span class="line">browser_Edge = webdriver.Edge()</span><br><span class="line">browser_Firefox = webdriver.Firefox()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后就会调用相应的浏览器</p>
<h3 id="访问页面">访问页面</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">browser_Chrome.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser_Chrome.page_source)</span><br><span class="line">browser_Chrome.close()</span><br></pre></td></tr></table></figure>
<p>在初始化浏览器对象之后，使用<code>get()</code>方法可以驱动浏览器打开页面，并且可以通过<code>.page_source</code>来获取网页的源码。</p>
<h3 id="查找节点">查找节点</h3>
<p><code>selenium</code>也可以驱动浏览器完成各种操作，比如填充表单、模拟点击，但是进行操作之前就要先知道要操作的地方在哪，所以查找节点在哪就比较重要了。</p>
<h4 id="单个节点">单个节点</h4>
<p>比如想要查找淘宝的搜索框，就要先分析页面的源代码了。</p>
<p>在淘宝网页打开开发者模式，查看搜索框元素:</p>
<p><img src="https://img.nickyam.com/file/d3ed1829937835568ac07.png"></p>
<p>可以发现搜索框的<code>id</code>属性是<code>q</code>,<code>name</code>属性也是<code>q</code>，还有其他的一些属性。</p>
<p>可以通过<code>find_element(by,vulue)</code>多种方式来获取发现它们：</p>
<ul>
<li>通过<code>属性</code>来获取</li>
<li>通过<code>XPath</code>,``来获取</li>
<li>通过<code>CSS选择器</code>来获取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">browser_Chrome = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">input_1 = browser_Chrome.find_element(by=By.ID, value=<span class="string">'q'</span>)</span><br><span class="line">input_2 = browser_Chrome.find_element(by=By.CSS_SELECTOR, value=<span class="string">'#q'</span>)</span><br><span class="line">input_3 = browser_Chrome.find_element(by=By.XPATH, value=<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line"><span class="built_in">print</span>(input_1, input_2, input_3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session="24c49d20dc6e6892801487df51baf88c", element="423A8256F92CB6C6F85B6A9222EF1489_element_2")&gt; </span><br><span class="line"> &lt;selenium.webdriver.remote.webelement.WebElement (session="24c49d20dc6e6892801487df51baf88c", element="423A8256F92CB6C6F85B6A9222EF1489_element_2")&gt; </span><br><span class="line"> &lt;selenium.webdriver.remote.webelement.WebElement (session="24c49d20dc6e6892801487df51baf88c", element="423A8256F92CB6C6F85B6A9222EF1489_element_2")&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到都获取了搜索框的对象</p>
<h4 id="多个节点">多个节点</h4>
<p>使用方法<code>find_elements(by,value)</code>可以获取页面中的多个节点，放回是一个列表，对象的类型都是<code>selenium.webdriver.remote.webelement.WebElement</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> = browser_Chrome.find_elements(by=By.CSS_SELECTOR,value=<span class="string">'.service-bd li'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure>
<h3 id="与节点进行交互">与节点进行交互</h3>
<p><code>selenium</code>同时也可以驱动浏览器与网页进行交互，比如<code>send_keys()</code>输入文字，用<code>clear()</code>来清空文字，<code>click()</code>来点击按钮。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://taobao.com'</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element(by=By.ID, value=<span class="string">'q'</span>)</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">'Huawei'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">input</span>.clear()</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">'Logic'</span>)</span><br><span class="line">button = browser.find_element(by=By.CLASS_NAME,value=<span class="string">'btn-search'</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>
<p>这段程序会打开淘宝的页面，之后会在搜索框中输入Huawei，一秒之后会清空后会输入Logic，然后会点击搜索按钮。</p>
<h3 id="动作链">动作链</h3>
<p>还有一些操作，它们没有特定的执行对象，比如鼠标拖拽、键盘按键等这些操作需要用到另一种方式来执行，那就是动作链（<code>ActionChains</code>）。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># 导入selenium库中的webdriver模块，用于驱动浏览器进行自动化操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="comment"># 导入selenium库中的By模块，用于指定元素定位方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="comment"># 导入selenium库中的ActionChains模块，用于模拟鼠标操作</span></span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">"detach"</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 创建ChromeOptions对象，用于设置浏览器选项</span></span><br><span class="line"><span class="comment"># add_experimental_option方法可以用于设置实验性选项，这里设置"detach"为True，表示不自动关闭浏览器窗口</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"><span class="comment"># 创建一个Chrome浏览器的实例，并使用设置的选项进行配置</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line"><span class="comment"># 设置目标网页的URL，这里是一个菜鸟网站的拖拽示例页面</span></span><br><span class="line"></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="comment"># 使用浏览器打开指定的URL页面</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="comment"># 切换到名为'iframeResult'的网页框架中，因为拖拽元素在该框架内</span></span><br><span class="line"></span><br><span class="line">source = browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">'#draggable'</span>)</span><br><span class="line"><span class="comment"># 通过CSS选择器定位拖拽元素，返回一个WebElement对象，并将其赋值给source变量</span></span><br><span class="line"></span><br><span class="line">target = browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">'#droppable'</span>)</span><br><span class="line"><span class="comment"># 通过CSS选择器定位目标元素，返回一个WebElement对象，并将其赋值给target变量</span></span><br><span class="line"></span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line"><span class="comment"># 创建ActionChains对象，用于模拟鼠标操作</span></span><br><span class="line"></span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line"><span class="comment"># 使用drag_and_drop方法模拟鼠标拖拽操作，将source元素拖拽到target元素上</span></span><br><span class="line"></span><br><span class="line">actions.perform()</span><br><span class="line"><span class="comment"># 执行ActionChains中的操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="运行javascript">运行JavaScript</h3>
<p>还有一些操作<code>selenium</code>没有提供操作的API，比如下拉进度条，这种情况需要模拟运行JavaScript，用<code>execute_script</code>来实现。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">"detach"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0,document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码会让浏览器打开知乎的页面，然后下拉到底部，之后弹出警告框。</p>
<h3 id="获取节点的信息">获取节点的信息</h3>
<p>通过<code>page_source</code>属性获取了页面的源代码之后，就可以使用解析库来解析网页的解析从中获取信息了。</p>
<ol type="1">
<li><p>获取属性</p>
<p>使用<code>get_attribute()</code>方法获取节点的属性</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">"detach"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://spa2.scrape.center/'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'logo-image'</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.get_attribute(<span class="string">'src'</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session="c43dc64a285e943c6fc6b4dffe8cfd07", element="396816979FD7F3F7A89A9FC86D2FF265_element_3")&gt;</span><br><span class="line">https://spa2.scrape.center/img/logo.a508a8f0.png</span><br></pre></td></tr></table></figure></li>
<li><p>获取文本值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">"detach"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://spa2.scrape.center/'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = browser.find_element(by=By.CLASS_NAME,value=<span class="string">'logo-title'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.text)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scrape</span><br></pre></td></tr></table></figure></li>
<li><p>获取ID、位置、标签名和大小</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">"detach"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://spa2.scrape.center/'</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element(by=By.CLASS_NAME,value=<span class="string">'logo-title'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.tag_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.size)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F7DFF88A66646E84B4F59B183A5EE9F4_element_4</span><br><span class="line">span</span><br><span class="line">{'height': 40, 'width': 77}</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="切换frame">切换Frame</h3>
<p>网页中有一种节点叫做<code>iframe</code></p>
<blockquote>
<p>当涉及到在网页内嵌入其他网页或文档时，iframe（内嵌框架）是一种常用的HTML元素。它允许开发人员将一个网页嵌入到另一个网页中，创建一个内联的窗口。</p>
<p>以下是iframe的基本语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"URL"</span> <span class="attr">width</span>=<span class="string">"宽度"</span> <span class="attr">height</span>=<span class="string">"高度"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>src</code>：指定要嵌入的网页的URL。可以是外部网页，也可以是相对于当前网页的内部网页。</li>
<li><code>width</code>：指定iframe的宽度，可以使用像素或百分比。</li>
<li><code>height</code>：指定iframe的高度，同样可以使用像素或百分比。</li>
</ul>
<p>通过设置适当的宽度和高度，你可以控制iframe的尺寸。这样，嵌入的网页将以预定义的大小显示在父网页中。</p>
</blockquote>
<p><code>selenium</code>默认打开的是父Frame，如果这个页面有子页面的话，用<code>switch_to.frame()</code>方法可以切换页面。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">'detach'</span>, <span class="literal">True</span>)</span><br><span class="line">url = <span class="string">'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'No Logo'</span>)</span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'logo'</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No Logo</span><br><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session="27aca41206b95bac361def8e033ad660", element="578B75883B58A4C5F1CE79366B3D5500_element_11")&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="等待">等待</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式等待</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">implicitly_wait</span>():</span><br><span class="line">    browser = webdriver.Chrome()</span><br><span class="line">    browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">    browser.get(<span class="string">'https://spa2.scrape.center/'</span>)</span><br><span class="line">    <span class="built_in">input</span> = browser.find_element(by=By.CLASS_NAME, value=<span class="string">'logo-image'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示等待</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wait</span>():</span><br><span class="line">    browser = webdriver.Chrome()</span><br><span class="line">    browser.get(<span class="string">'https://taobao.com/'</span>)</span><br><span class="line">    wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">input</span> = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>)))</span><br><span class="line">    button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">input</span>,button)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>隐式等待是执行测试时如果没有在DOM中找到节点，将会继续等待，超出设定的时间后会抛出找不到节点的异常。</p>
<p>但是隐式等待只规定了规定的时间，但是页面的加载时间也会受往网络因素的限制。</p>
<p>所以显示等待会指定要查找的节点和最长的等待时间。如果在规定的时间内加载出了要查找的节点，就返回这个节点，如果超出了时间还未加载出来，就会抛出超时异常。</p>
<p>显示等待首先引入了<code>WebDriverWait</code>对象，指定最长等待时间为10s，并赋值给<code>wait</code>变量。</p>
<p><code>until</code>传入等待条件。</p>
<p><code>presence_of_element_located()</code>代表节点出现,其参数时一个元组<code>(By.ID, 'q')</code>,表示节点id为p。这样做的效果是如果节点ID为q的节点在1-s内加载出来了，就返回节点，超出时间就会，抛出异常。</p>
<p><code>element_to_be_clickale</code>代表按钮可点击，所以查找按钮要查找CSS选择器<code>.btn-search</code>的按钮，如果10s内它是可点击的，也就是这个按钮加载出来了，就返回该节点，超出10s就会返回异常。</p>
<p>更多尝试参照官方文档。</p>
<h3 id="前进与后退">前进与后退</h3>
<p><code>forward()</code>也是使页面前进，<code>back()</code>会使页面回退。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com'</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.bilibili.com'</span>)</span><br><span class="line"></span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure>
<h3 id="cookies">Cookies</h3>
<p><code>Selenium</code>可以对<code>Cookies</code>继续添加、获取、删除。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.add_cookie({<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'germey'</span>})</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[{'domain': 'www.zhihu.com', 'httpOnly': False, 'name': 'KLBRSID', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'fb3eda1aa35a9ed9f88f346a7a3ebe83|1690034393|1690034391'}, {'domain': '.zhihu.com', 'expiry': 1721570392, 'httpOnly': False, 'name': 'Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '1690034393'}, {'domain': '.zhihu.com', 'httpOnly': False, 'name': 'Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '1690034393'}, {'domain': '.zhihu.com', 'expiry': 1724594392, 'httpOnly': False, 'name': 'd_c0', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'AFAXDT6NHxePTlrdiFNdX5JOaIROCTM5IAE=|1690034391'}, {'domain': '.zhihu.com', 'httpOnly': False, 'name': '_xsrf', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '8f3aad49-42e8-49c6-855b-20baf9f6856b'}, {'domain': '.zhihu.com', 'expiry': 1724594392, 'httpOnly': False, 'name': '_zap', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '6aa41b50-3148-40c4-9a21-8ba28590f314'}]</span><br><span class="line">[{'domain': '.www.zhihu.com', 'httpOnly': False, 'name': 'name', 'path': '/', 'sameSite': 'Lax', 'secure': True, 'value': 'germey'}, {'domain': 'www.zhihu.com', 'httpOnly': False, 'name': 'KLBRSID', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'fb3eda1aa35a9ed9f88f346a7a3ebe83|1690034393|1690034391'}, {'domain': '.zhihu.com', 'expiry': 1721570392, 'httpOnly': False, 'name': 'Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '1690034393'}, {'domain': '.zhihu.com', 'httpOnly': False, 'name': 'Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '1690034393'}, {'domain': '.zhihu.com', 'expiry': 1724594392, 'httpOnly': False, 'name': 'd_c0', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'AFAXDT6NHxePTlrdiFNdX5JOaIROCTM5IAE=|1690034391'}, {'domain': 'www.zhihu.com', 'httpOnly': False, 'name': 'SESSIONID', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': 'OuJsIxv19DcvQyFBu8oHvvjV0sNLyaT52BcsPHuIa2d'}, {'domain': '.zhihu.com', 'httpOnly': False, 'name': '_xsrf', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '8f3aad49-42e8-49c6-855b-20baf9f6856b'}, {'domain': '.zhihu.com', 'expiry': 1724594392, 'httpOnly': False, 'name': '_zap', 'path': '/', 'sameSite': 'Lax', 'secure': False, 'value': '6aa41b50-3148-40c4-9a21-8ba28590f314'}]</span><br><span class="line">[]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="选项卡管理">选项卡管理</h3>
<p><code>Selenium</code>也可以对选项卡进行操作。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>) <span class="comment"># 新开页面</span></span><br><span class="line"><span class="built_in">print</span>(browser.window_handles) <span class="comment"># 页面的多个选项卡是列表</span></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>]) <span class="comment"># switch_to转化到新页面</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.python.org/'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">['C052838A03EEFCB58CF1B6163CFCD135', '9080FFD32E5016C380402E89E8B2597C']</span><br></pre></td></tr></table></figure>
<p>这段代码会先打开百度的页面，之后会打开一个新的选项卡，然后打开淘宝，之后回到百度的页面，转到python官网。</p>
<h3 id="异常">异常</h3>
<p>参照官方文档</p>
<h3 id="反屏蔽">反屏蔽</h3>
<p>有些网站会对<code>Selenium</code>进行屏蔽。</p>
<p>检测的基本原理是接触当前浏览器窗口下的<code>window.navigator</code>对象中是否包含<code>webdriver</code>的属性，正常使用浏览器的时候属性<code>undefined</code>，一旦使用了<code>Selenium</code>后就会变成<code>webdriver</code>属性.</p>
<p>在<code>Selenium</code>中，可以使用CDP(Chrome Devtools Protocol
开发工具协议)解决这个问题，利用它可以将每次页面刚加载的时候就会执行<code>JavaScript</code>语句，将<code>webdriver</code>的属性置空。</p>
<p>这里的执行的方法是<code>Page.addScriptToEvaluateOnNewDocument</code>，将语句传入其中即可。</p>
<p>还可以加入几个选项来隐藏<code>WebDriver</code>提示条和自动化扩展信息</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">'useAutomationExtension'</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">'Page.addScriptToEvaluateOnNewDocument'</span>, {</span><br><span class="line">    <span class="string">'source'</span>: <span class="string">'Object.defineProperty(navigator,"webdriver",{get:() =&gt; undefined})'</span></span><br><span class="line">})</span><br><span class="line">browser.get(<span class="string">'https://antispider1.scrape.center/'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="无头模式">无头模式</h3>
<p>无头模式下，在网站运行的时候就不会弹出窗口，从而减少干扰，同时减少资源的占用。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.set_window_size(<span class="number">1366</span>,<span class="number">768</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">browser.get_screenshot_as_file(<span class="string">'preview.png'</span>) <span class="comment"># 截取当前页面</span></span><br></pre></td></tr></table></figure>
<p>无头模式下，页面就不会弹出来了，代码会继续运行，</p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>aiohtttp的使用【异步爬虫】</title>
    <url>/2023/07/20/aiohttp%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="aiohttp异步爬取实战">aiohttp异步爬取实战</h1>
<h2 id="爬取对象">爬取对象</h2>
<p>这次要实战爬取一个数据量比较大的网站<code>https://spa5.scrape.center/</code></p>
<p><a href="#完整代码">完整代码</a></p>
<span id="more"></span>
<h2 id="网页分析">网页分析</h2>
<p>这是一个图书网站，有几千本图书的信息，网站的数据是由JavaScript渲染出来的，数据可以由Ajax接口获取。</p>
<p><a href="">Ajax数据爬取链接</a></p>
<p><a href="">Ajax实战</a></p>
<p>要成为的目标：</p>
<ul>
<li><p>使用<code>aiohttp</code>爬取全站的图书数据</p></li>
<li><p>将数据通过异步的方式保存到Monga数据库</p>
<p><a href="">MongoDB数据量</a></p></li>
</ul>
<h2 id="准备工作">准备工作</h2>
<ul>
<li><p><code>Python3.6</code>及以上</p></li>
<li><p>了解Ajax爬取的基本原理和模拟方法</p></li>
<li><p>了解异步爬虫的基本原理和<code>asyncio</code>库的基本用法</p></li>
<li><p>了解<code>aiohttp</code>的基本方法</p></li>
<li><p>安装并成功运行<code>MongoDB</code>数据库，而且安装异步爬虫库<code>motor</code></p>
<p><code>Mango</code>的异步存储，离不开<code>Mango</code>存储库<code>motor</code>，在终端输入即可</p>
<p><code>pip install motor</code></p></li>
</ul>
<h2 id="页面源码分析">页面源码分析</h2>
<p>在开发者模式中查看XDR（Ajax）的数据。</p>
<p><img src="https://img.nickyam.com/file/4230a0b7c3b1e89f21c35.png"></p>
<p>可以看到详情页的请求接口为：<code>https://spa5.scrape.center/?limit=18&amp;offset=0</code>。</p>
<ul>
<li><code>limit</code>:表示每页最多由18个数据。</li>
<li><code>offset</code>:表示详情页的序号</li>
</ul>
<p>在Ajax返回的数据中<code>results</code>字段包含当前页面里的18本图书信息，比较重要的信息就是<code>id</code>属性，在之后访问每本书的详情页时由需要<code>id</code>来构造URL。</p>
<p>点进一个图书的详情页，可以看到详情页的URL为：<code>[Scrape | Book](https://spa5.scrape.center/detail/7952978)</code></p>
<p>所以可以看到URL的结构为<code>https://spa5.scrape.center/detail/id</code></p>
<p>再对图书的详情页分析，在开发者工具查看XHR包</p>
<p><img src="https://img.nickyam.com/file/05c5dc0563c4c90de084d.png"></p>
<p>可以看到Ajax返回的数据就是图书的数据。</p>
<h2 id="实现思路">实现思路</h2>
<h3 id="完善的思路但是实现的难度大">完善的思路，但是实现的难度大</h3>
<p>完善的异步爬虫应该能够充分利用资源进行全速爬取，实现的思路就是维护一个<code>动态变化的爬取队列</code>，每产生一个新的<code>task</code>，就将其放入爬取队列中，与专门的<code>爬虫消费者</code>从此队列中获取<code>task</code>并爬取，能够做到在最大的并发量的前提下充分利用等待时间进行额外的爬取处理。</p>
<h3 id="简单的思路">简单的思路</h3>
<ol type="1">
<li>首先爬取列表页</li>
<li>其次爬取详情页</li>
</ol>
<p>难点在于并发执行，所以可以将爬取拆分为如下的两个阶段。</p>
<ul>
<li>首先，异步爬取所有的列表页，可以将所有列表页的爬取任务集合到一起，并将其声明为由<code>task</code>组成的列表</li>
<li>之后，将上一步爬取的列表页的所有内容并解析，将所有图书的id信息组合成所有详情页的爬取任务集合，并将其声明为<code>task</code>组成的列表，解析异步爬取，同时爬取结果也以异步方式存储到<code>MongoDB</code>数据库。</li>
</ul>
<h2 id="代码编写">代码编写</h2>
<h3 id="基本配置">基本配置</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""基本配置"""</span></span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa5.scrape.center/api/book/?limit=18&amp;offset={offset}'</span></span><br><span class="line">DETAIL_URL = <span class="string">'https://spa5.scrape.center/detail/api/book/{id}'</span></span><br><span class="line"></span><br><span class="line">PAGE_SIZE = <span class="number">18</span></span><br><span class="line">PAGE_NUMBER = <span class="number">502</span></span><br><span class="line">CONCURRENCY = <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置了一些参数：</p>
<ul>
<li>日志配置</li>
<li><code>INDEX_URL</code>:列表页的URL的构造</li>
<li><code>DETAIL_URL</code>:详情页的URL构造</li>
<li><code>PAGE_SIZE</code>:每页的数据量</li>
<li><code>PAGE_NUMBER</code>:详情页的数量</li>
<li><code>CONCURRENCY</code>:最大并发量</li>
</ul>
<h3 id="爬取列表页">爬取列表页</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""爬取列表页"""</span></span><br><span class="line"></span><br><span class="line">semaphore = asyncio.Semaphore(CONCURRENCY)</span><br><span class="line">session = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_api</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logging.info(<span class="string">'scraping %s'</span>,url)</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> response.json()</span><br><span class="line">        <span class="keyword">except</span> aiohttp.ClientError:</span><br><span class="line">            logging.error(<span class="string">'error occurred while scraping %s'</span>,url,exc_info=<span class="literal">True</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> session</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_index(page))</span><br><span class="line">                          <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, PAGE_SIZE + <span class="number">1</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)</span><br><span class="line">    logging.info(<span class="string">'results %s'</span>, json.dumps(results, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>运行以下__main__函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>
<h3 id="爬取详情页">爬取详情页</h3>
<p>改写<code>main()</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> session</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_index(page))</span><br><span class="line">                          <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, PAGE_SIZE + <span class="number">1</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)</span><br><span class="line">    <span class="comment"># logging.info('results %s', json.dumps(results, ensure_ascii=False, indent=2))</span></span><br><span class="line">    ids = []</span><br><span class="line">    <span class="keyword">for</span> index_data <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> index_data: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">'results'</span>):</span><br><span class="line">            ids.append(item.get(<span class="string">'id'</span>))</span><br><span class="line">    scrape_detail_tasks = [asyncio.ensure_future(scrape_detail(<span class="built_in">id</span>)) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> ids]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(scrape_detail_tasks)</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br></pre></td></tr></table></figure>
<p>添加爬取详情页的函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""爬取详情页"""</span></span><br><span class="line"><span class="keyword">from</span> motor.motor_asyncio <span class="keyword">import</span> AsyncIOMotorClient</span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'books'</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">'books'</span></span><br><span class="line"></span><br><span class="line">client = AsyncIOMotorClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    logging.info(<span class="string">'saving data %s'</span>, data)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> collection.update_one({</span><br><span class="line">            <span class="string">'id'</span>: data.get(<span class="string">'id'</span>)</span><br><span class="line">        }, {</span><br><span class="line">            <span class="string">'$set'</span>: data</span><br><span class="line">        }, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    data = <span class="keyword">await</span> scrape_api(url)</span><br><span class="line">    <span class="keyword">await</span> save_data(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用支持异步操作的<code>motor</code>中的<code>AsyncIOMotorClient</code>来进行异步的数据存储。</p>
<p><a id="完整代码"></a></p>
<h2 id="完整代码">完整代码</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> motor.motor_asyncio <span class="keyword">import</span> AsyncIOMotorClient</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="string">"""基本配置"""</span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa5.scrape.center/api/book/?limit=18&amp;offset={offset}'</span></span><br><span class="line">DETAIL_URL = <span class="string">'https://spa5.scrape.center/api/book/{id}'</span></span><br><span class="line"></span><br><span class="line">PAGE_SIZE = <span class="number">18</span></span><br><span class="line">PAGE_NUMBER = <span class="number">502</span></span><br><span class="line">CONCURRENCY = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'books'</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">'books'</span></span><br><span class="line"></span><br><span class="line">client = AsyncIOMotorClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="string">"""爬取列表页"""</span></span><br><span class="line"></span><br><span class="line">semaphore = asyncio.Semaphore(CONCURRENCY)</span><br><span class="line">session = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_api</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logging.info(<span class="string">'scraping %s'</span>, url)</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> response.json()</span><br><span class="line">        <span class="keyword">except</span> aiohttp.ClientError:</span><br><span class="line">            logging.error(<span class="string">'error occurred while scraping %s'</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_index</span>(<span class="params">page</span>):</span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(offset=page)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> scrape_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""爬取详情页"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    logging.info(<span class="string">'saving data %s'</span>, data)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> collection.update_one({</span><br><span class="line">            <span class="string">'id'</span>: data.get(<span class="string">'id'</span>)</span><br><span class="line">        }, {</span><br><span class="line">            <span class="string">'$set'</span>: data</span><br><span class="line">        }, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    data = <span class="keyword">await</span> scrape_api(url)</span><br><span class="line">    <span class="keyword">await</span> save_data(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> session</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_index(page))</span><br><span class="line">                          <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, PAGE_NUMBER + <span class="number">1</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)</span><br><span class="line">    <span class="comment"># logging.info('results %s', json.dumps(results, ensure_ascii=False, indent=2))</span></span><br><span class="line">    ids = []</span><br><span class="line">    <span class="keyword">for</span> index_data <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> index_data: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">'results'</span>):</span><br><span class="line">            ids.append(item.get(<span class="string">'id'</span>))</span><br><span class="line">    scrape_detail_tasks = [asyncio.ensure_future(scrape_detail(<span class="built_in">id</span>)) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> ids]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(scrape_detail_tasks)</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Cost time:'</span>,end-start)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>异步爬虫</tag>
        <tag>aiphttp</tag>
      </tags>
  </entry>
  <entry>
    <title>aiohtttp的使用【异步爬虫】</title>
    <url>/2023/07/20/aiohtttp%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="aiohttp的使用">aiohttp的使用</h1>
<p>本篇博客介绍<code>aiohttp</code>的简单使用。</p>
<span id="more"></span>
<h2 id="aiohttp概述">aiohttp概述</h2>
<p>博客源地址：<a href="https://helloxiunneg.com.cn/2023/07/20/aiohtttp%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E3%80%91/#more">修能的博客</a></p>
<p><code>asyncio</code>模块，其内部实现了对<code>TCP</code>、<code>UDP</code>和<code>SSL</code>协议的异步操作支持，但是对于<code>http</code>的请求就只能用<code>aiohttp</code>库了。</p>
<p><code>aiohttp</code>是基于<code>asyncio</code>的异步<code>http</code>网络模块，它即提供了服务端，同时也提供了客户端。</p>
<p>服务端可以用来搭建一个支持异步处理的服务器，用途是处理请求并返回响应。</p>
<p>客户端时用来发起请求的，类似于<code>requests</code>库发起的一个<code>http</code>请求然后获得响应，区别是<code>aiohttp</code>时异步的，<code>requests</code>是同步的。</p>
<p>爬虫主要了解客户端的使用。</p>
<h2 id="实例">实例</h2>
<p>这是一个简单的<code>aiohttp</code>请求：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text(), response.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html, status = <span class="keyword">await</span> fetch(session, <span class="string">'https://helloxiunneg.com.cn'</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'html:<span class="subst">{html[:<span class="number">100</span>]}</span>...'</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'status:<span class="subst">{status}</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="comment">#     loop.run_until_complete(main())</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Python3.6及以上写法"""</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html:&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-CN"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset="UTF-8"&gt;</span><br><span class="line">&lt;meta name="viewport" content...</span><br><span class="line">status:200</span><br></pre></td></tr></table></figure>
<p>这里使用<code>aiohttp</code>爬取我的个人博客，获得网页源码和状态码。</p>
<p>可以看到<code>aiohttp</code>的请求的要求有以下几点：</p>
<ul>
<li><p>必须同时引入<code>aiohttp</code>和<code>acyncio</code>，原因是要实现异步爬取，需要用到协程，协程则需要借助于<code>asyncio</code>里面的事件循环才能执行，而且需要很多的基础的异步爬取。</p></li>
<li><p>每一个异步方法的前面都要统一加上<code>async</code>来修饰。</p></li>
<li><p><code>with as</code>语句同样需要加<code>async</code>修饰，<code>with as</code>用来声明一个上下文的管理器，帮助我们自动分配和释放资源。</p></li>
<li><p>对于一些返回协程对象的操作，前面需要<code>await</code>来修饰，通过查看<code>API</code>来确定是否返回的是协程对象，或者有查询函数。</p>
<blockquote>
<p>在Python中，可以使用<code>inspect</code>模块的<code>iscoroutinefunction</code>函数来确定一个函数是否是协程函数。该函数接受一个函数对象作为参数，并返回一个布尔值，表示该函数是否是一个协程函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(inspect.iscoroutinefunction(my_coroutine))  <span class="comment"># 输出 True</span></span><br><span class="line"><span class="built_in">print</span>(inspect.iscoroutinefunction(my_function))  <span class="comment"># 输出 False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>要运行异步方法就必须将其置入事件循环中，用<code>run_until_complete()</code>执行。</p>
<blockquote>
<p>Python3.6之后直接使用<code>asyncio.run()</code>即可自动在函数中启动事件循环，不必要显式的声明事件循环。</p>
</blockquote></li>
</ul>
<h2 id="url的参数的设置">URL的参数的设置</h2>
<p>如果想要构造URL,要使用<code>params</code>参数，<code>params</code>参数接受一个字典。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    params = {<span class="string">'name'</span>: <span class="string">'xiunneg'</span>, <span class="string">'age'</span>: <span class="number">20</span>}</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">'https://www.httpbin.org/get'</span>,params=params) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "args": {</span><br><span class="line">    "age": "20", </span><br><span class="line">    "name": "xiunneg"</span><br><span class="line">  }, </span><br><span class="line">  "headers": {</span><br><span class="line">    "Accept": "*/*", </span><br><span class="line">    "Accept-Encoding": "gzip, deflate", </span><br><span class="line">    "Host": "www.httpbin.org", </span><br><span class="line">    "User-Agent": "Python/3.11 aiohttp/3.8.4", </span><br><span class="line">    "X-Amzn-Trace-Id": "Root=1-64b8d131-34acfbef29c1c67919b22c89"</span><br><span class="line">  }, </span><br><span class="line">  "origin": "110.52.208.183", </span><br><span class="line">  "url": "https://www.httpbin.org/get?name=xiunneg&amp;age=20"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="其他的请求类型">其他的请求类型</h3>
<p>与<code>requests</code>库的格式差不多</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">session.post(url,data)</span><br><span class="line">session.put(url,data)</span><br><span class="line">session.delete(url,data)</span><br></pre></td></tr></table></figure>
<p><code>data</code>大部分都是字典</p>
<h2 id="响应">响应</h2>
<p>响应用如下方法分别获取其中的状态码、响应体、响应头、响应体JSON。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = {<span class="string">'name'</span>: <span class="string">'xiunneg'</span>,<span class="string">'age'</span>: <span class="number">20</span>}</span><br><span class="line">    url = <span class="string">'https://www.httpbin.org/post'</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.post(url=url,data=data) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'status:'</span>, response.status)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'headers:'</span>, response.headers)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'body:'</span>, <span class="keyword">await</span> response.text())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'bytes:'</span>, <span class="keyword">await</span> response.read())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'json:'</span>, <span class="keyword">await</span> response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status: 200</span><br><span class="line">headers: &lt;CIMultiDictProxy('Date': 'Thu, 20 Jul 2023 06:31:58 GMT', 'Content-Type': 'application/json', 'Content-Length': '513', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line">...</span><br><span class="line">json: {'args': {}, 'data': '', 'files': {}, 'form': {'age': '20', 'name': 'xiunneg'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '19', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'www.httpbin.org', 'User-Agent': 'Python/3.11 aiohttp/3.8.4', 'X-Amzn-Trace-Id': 'Root=1-64b8d4ce-39457e203c21115f155acf33'}, 'json': None, 'origin': '110.52.208.183', 'url': 'https://www.httpbin.org/post'}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="超时设置">超时设置</h2>
<p>借助<code>ClientTimeout</code>对象设置超时。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url = <span class="string">'https://www.httpbin.org/get'</span></span><br><span class="line">    timeout = aiohttp.ClientTimeout(total=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=timeout) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'status:'</span>, response.status)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>如果超时会报<code>TimeoutError</code>错误。</p>
<h2 id="并发限制">并发限制</h2>
<p><code>aiohttp</code>的并发量是很大的，所以为了防止把网站爬挂掉，所以要对并发进行限制。</p>
<p>使用<code>Semaphore</code>来控制并发量。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">CONCURRENCY = <span class="number">100</span></span><br><span class="line">URL = <span class="string">'https://www.baidu.com'</span></span><br><span class="line"></span><br><span class="line">semaphere = asyncio.Semaphore(CONCURRENCY)</span><br><span class="line">session = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_api</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphere:</span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'scraping'</span>, count, URL)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(URL) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> session</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_api()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'All Cost:'</span>, end - start)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scraping 1 https://www.baidu.com</span><br><span class="line">scraping 2 https://www.baidu.com</span><br><span class="line">scraping 3 https://www.baidu.com</span><br><span class="line">...</span><br><span class="line">scraping 9998 https://www.baidu.com</span><br><span class="line">scraping 9999 https://www.baidu.com</span><br><span class="line">scraping 10000 https://www.baidu.com</span><br><span class="line">All Cost: 105.09542608261108</span><br></pre></td></tr></table></figure>
<h3 id="await-asyncio.gatherscrape_index_tasks">await
asyncio.gather(*scrape_index_tasks)</h3>
<p><code>await asyncio.gather(*scrape_index_tasks)</code>
是一种同时运行多个协程任务并等待它们全部完成的方式。</p>
<p><code>gather()</code>
是<code>asyncio</code>提供的一个函数，它接受一组协程对象作为参数，并返回一个新的协程对象。当此新的协程对象被调用时，它会同时运行所有的协程任务，并等待它们全部完成或者其中任何一个抛出异常。</p>
<p>在这个示例中，<code>scrape_index_tasks</code>是一个协程任务的列表，这些任务会在<code>gather()</code>函数中同时运行。通过使用
<code>*</code>
来展开列表，我们将列表中的每个元素作为单独的参数传递给<code>gather()</code>函数。</p>
<p>然后，通过<code>await</code>关键字来等待<code>gather()</code>函数返回的协程对象完成。这意味着程序会暂停在这一行，直到所有的协程任务都完成或者其中一个抛出异常。</p>
<p>总的来说，<code>await asyncio.gather(*scrape_index_tasks)</code>这一行代码的作用是并发运行
<code>scrape_index_tasks</code>
列表中的所有协程任务，并在它们全部完成后继续执行下一行代码。</p>
<h2 id="总结">总结</h2>
<p>推荐查阅<a href="https://docs.aiohttp.org/">官方文档</a>：<code>https://docs.aiohttp.org/</code></p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>异步爬虫</tag>
        <tag>aiphttp</tag>
      </tags>
  </entry>
  <entry>
    <title>异步爬虫【爬虫】</title>
    <url>/2023/07/18/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="异步爬虫">异步爬虫</h1>
<p>爬虫是<code>IO密集型任务</code>，在发出一个请求之后，程序必须等到网站放回响应，程序才能接着运行，如果等待的时间很长的话，爬虫程序也会在一直在等待，什么是也不做，就会浪费时间。</p>
<p>异步爬虫可以解决这个问题。</p>
<span id="more"></span>
<h2 id="协程的基本原理">协程的基本原理</h2>
<p>要实现异步爬虫，一个重点就是<code>协程</code>(<code>coroutine</code>)</p>
<h3 id="示例">示例</h3>
<p>来看看这个网站：<code>https://www.httpbin.org/delay/5</code>，这个连接需要先等待5秒钟才能得到结果，因为这时服务器强制得到5秒才能响应。</p>
<p>如果用<code>requests库</code>来访问这个网站10次，来查看相应的时间。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">TOTAL_NUMBER = <span class="number">10</span></span><br><span class="line">URL = <span class="string">'https://www.httpbin.org/delay/5'</span></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,TOTAL_NUMBER+<span class="number">1</span>):</span><br><span class="line">    logging.info(<span class="string">'sraping %s'</span>,URL)</span><br><span class="line">    response = requests.get(URL)</span><br><span class="line">end_time = time.time()</span><br><span class="line">logging.info(<span class="string">'total time %s second'</span>,end_time - start_time)</span><br></pre></td></tr></table></figure>
<p>普通使用的<code>requests.get()</code>是单线程，在爬取之前先记录时间，爬取之后再记录一次时间，最后输出总时间。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">00</span>,<span class="number">051</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">11</span>,<span class="number">939</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">25</span>,<span class="number">818</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">36</span>,<span class="number">742</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">46</span>,<span class="number">669</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">19</span>:<span class="number">53</span>,<span class="number">518</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">20</span>:<span class="number">53</span>,<span class="number">680</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">06</span>,<span class="number">351</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">17</span>,<span class="number">378</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">21</span>:<span class="number">25</span>,<span class="number">885</span> - INFO : sraping https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">19</span>:<span class="number">22</span>:<span class="number">15</span>,<span class="number">833</span> - INFO : total <span class="built_in">time</span> <span class="number">195</span>.<span class="number">7818102836609</span> second</span><br></pre></td></tr></table></figure>
<p>可以看到爬取就用了195秒的时间。</p>
<p>要是用多进程或多线程来爬取，时间会减短很多。</p>
<h3 id="协程基础知识">协程基础知识</h3>
<ul>
<li><p>阻塞</p>
<p><strong>阻塞状态</strong>是指程序未得到所需的计算资源时被挂起的状态。</p>
<p>程序在完成某个操作完成之前，自身是不能完成别的任务。</p></li>
<li><p>非阻塞</p>
<p><strong>非阻塞状态</strong>是指程序在等待某操作的时候，本身不被阻塞，可以干其他的事情，则这个程序是非阻塞的。</p></li>
<li><p>同步</p>
<p>不同程序单元为了共同完成某个任务，在执行过程中需要<strong>靠某种通信方式保持协调一致</strong></p>
<p>此时这些程序单元是同步执行的。</p></li>
<li><p>异步</p>
<p>为了完成某个任务，有时不同的程序单元之间<strong>无须通信协调也能完成任务</strong>。</p>
<p><strong>异步意味着无序</strong>。</p></li>
<li><p>多进程</p>
<p>就是利用处理器的多核优势，在<strong>同一时间并行执行多个任务</strong>，大大提高执行的效率。</p></li>
<li><p><strong>协程</strong></p>
<p>一种运行在<code>用户态</code>的轻量级线程</p>
<p>协程拥有自己的寄存器上下文和栈。</p>
<p>协程在调度切换的时候，将寄存器上下文和栈保存到其他地方，等切回来是在恢复先前保存的寄存器上下文和栈。因此，协程能够保留上一次调用时的状态。</p>
<p>协程的本质是一个<strong>单线程</strong>,相对于多线程来说，它没有<strong>上下文切换的开销</strong>，没有<code>原子操作锁定</code>及<code>同步</code>的开销，编程模型也比较简单。</p>
<blockquote>
<p>原子操作锁定（Atomic Operation
Locking）是一种同步机制，用于确保在多线程或并发环境下对共享资源的原子性访问。原子操作是指在执行过程中不可中断的操作，要么完全执行，要么完全不执行，不存在部分执行的情况。</p>
<p>使用原子操作锁定可以解决并发环境下的竞争条件问题，确保共享资源的正确访问。它通常用于对变量进行读取、写入或修改操作，以确保线程的操作不会相互干扰或产生意外结果。</p>
<p>在编程中，原子操作锁定通常由特殊的锁或原子操作指令来实现。这些机制可以保证一个线程在执行原子操作时不会被其他线程中断或干扰。常见的原子操作锁定机制包括互斥锁（Mutex）、自旋锁（Spin
Lock）以及原子操作指令（Atomic Instructions）等。</p>
</blockquote></li>
</ul>
<h3 id="协程的用法">协程的用法</h3>
<p>从<code>Python3.4</code>开始，Python中加入了协程的概念。</p>
<p>在<code>Python3.5</code>中有增加了<code>async</code>和<code>await</code>，使得协程到的实现更为方便。</p>
<p><code>asyncio库</code>是Python协程最常用的库。</p>
<p>想要学好协程，必须了解一下的概念：</p>
<ul>
<li><p><code>event_loop</code>:事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足发生条件是就会调用对应的处理方法。</p></li>
<li><p><code>coroutine</code>:协程，Python中常指代<code>协程对象类型</code>,把协程对象注册到是事件循环中，他会把事件循环调用。</p>
<p>使用<code>async</code>关键字来定义一个方法，这个方法在调用时不会立即执行，而是会返回一个<code>协程对象</code>。</p></li>
<li><p><code>task</code>:任务，这是对协程对象的进一步包装，包含协程对象的各个状态。</p></li>
<li><p><code>future</code>:代表将要执行或者没用执行的任务的结果，实际上跟<code>task</code>没有本质区别。</p></li>
</ul>
<h3 id="准备工作">准备工作</h3>
<p>要求<code>Python3.5及以上</code>。</p>
<h3 id="定义协程">定义协程</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Number:'</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Coroutine:'</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling execute'</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling loop'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x000001E51B12C110&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Number: 1</span><br><span class="line">After calling loop</span><br><span class="line">D:\PythonProject\异步爬虫\定义协程.py:12: DeprecationWarning: There is no current event loop</span><br><span class="line">  loop = asyncio.get_event_loop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>防止DeprecationWarning: There is no current event
loop警报，请这样写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">loop = asyncio.new_event_loop()</span><br><span class="line">asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line">asyncio.ensure_future(task,loop=loop)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先引入<code>asyncio</code>包，这样才可以使用<code>async</code>和<code>await</code>关键词。</p>
<p>然后使用<code>async</code>定义了一个<code>execute</code>方法，传入数字参数，执行会打印这个数字。</p>
<p>然后执行<code>execute</code>方法，然而程序并没有执行程序，而是返回了一个<code>coroutine</code>协程对象，之后我们使用<code>get_event_complete</code>方法来创建一个事件循环<code>loop</code>，再调用<code>run_until_complete</code>将协程对象注册到事件循环，接着启动程序，就会打印数字了。</p>
<p>可见，协程对象只能在被注册到事件循环中之后才会执行。</p>
<p>其实在把协程对象<code>coroutine</code>传递到<code>run_until_complete</code>方法的时候，这里隐式的将<code>coroutine</code>对象封装成<code>task</code>对象，我们也可以显示声明。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Number:'</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Coroutine:'</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling execute'</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task:'</span>, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task'</span>, task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling loop'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coroutine: &lt;coroutine object execute at 0x00000164A373C110&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name='Task-1' coro=&lt;execute() running at D:\PythonProject\异步爬虫\定义协程.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task &lt;Task finished name='Task-1' coro=&lt;execute() done, defined at D:\PythonProject\异步爬虫\定义协程.py:4&gt; result=None&gt;</span><br><span class="line">After calling loop</span><br><span class="line">D:\PythonProject\异步爬虫\定义协程.py:12: DeprecationWarning: There is no current event loop</span><br><span class="line">  loop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure>
<p>会看到在没有执行的时候，task的状态时<code>pending</code>，执行完之后就是<code>finished</code>。</p>
<p><code>asyncio.ensure_future</code>方法，返回的对象也是<code>task</code>对象，这样可以不借助<code>loop</code>对象也可以构造<code>task</code>对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Number:'</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Coroutine:'</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling execute'</span>)</span><br><span class="line"></span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task:'</span>, task)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task'</span>, task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'After calling loop'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending name='Task-1' coro=&lt;execute() running at D:\PythonProject\异步爬虫\定义协程.py:4&gt;&gt;</span><br><span class="line">Number: 1</span><br><span class="line">Task &lt;Task finished name='Task-1' coro=&lt;execute() done, defined at D:\PythonProject\异步爬虫\定义协程.py:4&gt; result=None&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure>
<h3 id="绑定回调">绑定回调</h3>
<p><code>task</code>对象可以绑定一个<code>回调方法</code></p>
<blockquote>
<p>回调（Callback）是一种常见的编程模式，用于在异步操作完成后通知调用方或执行额外的操作。它是一种通过函数或对象来实现的机制，用于处理异步操作的结果。</p>
<p>在回调模式中，当执行一个异步操作时，可以提供一个回调函数或回调对象作为参数。当异步操作完成时，系统会调用回调函数或回调对象的特定方法，并通过参数传递操作的结果或错误信息。</p>
<p>回调模式的优点是它可以允许程序在进行异步操作时不需要等待结果，而是通过回调函数异步地接收结果，并在结果可用时进行处理。这样可以避免阻塞主线程或导致长时间的等待。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">loop = asyncio.new_event_loop()</span><br><span class="line">asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    url = <span class="string">'https://www.helloxiunneg.com.cn'</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Status:'</span>, task.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = request()</span><br><span class="line">task = asyncio.ensure_future(coroutine, loop=loop)</span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task:'</span>, task)</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task:'</span>, task)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Task: &lt;Task pending name='Task-1' coro=&lt;request() running at D:\PythonProject\异步爬虫\绑定回调.py:8&gt; cb=[callback() at D:\PythonProject\异步爬虫\绑定回调.py:14]&gt;</span><br><span class="line">Status: 200</span><br><span class="line">Task: &lt;Task finished name='Task-1' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\绑定回调.py:8&gt; result=200&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先定义协程对象<code>request</code>，函数会请求博客网址，获得请求状态码，<code>callback</code>方法，方法接受一个<code>task</code>对象，在这个方法中打印出<code>task</code>对象的结果。</p>
<p>两者怎么关联呢?</p>
<p>用<code>add_done_callback</code>方法将<code>callback</code>方法传递给封装好的<code>task</code>对象，每当<code>task</code>对象执行完毕后就可以调用<code>callback</code>方法了。</p>
<h3 id="多任务协程">多任务协程</h3>
<p>如果想多次执行请求怎么办？</p>
<p>可以定义一个<code>task</code>列表，然后使用<code>asyncio</code>的<code>wait</code>方法，再注册到事件循环中就行了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">loop = asyncio.new_event_loop()</span><br><span class="line">asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    url = <span class="string">'https://www.helloxiunneg.com.cn'</span></span><br><span class="line">    status = requests.get(url).status_code</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request(), loop=loop) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task:'</span>, tasks)</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Task'</span>, tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Rusult:'</span>,task.result())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Task: [&lt;Task pending name='Task-1' coro=&lt;request() running at D:\PythonProject\异步爬虫\多任务协程.py:8&gt;&gt;, &lt;Task pending name='Task-2' coro=&lt;request() running at D:\PythonProject\异步爬虫\多任务协程.py:8&gt;&gt;, &lt;Task pending name='Task-3' coro=&lt;request() running at D:\PythonProject\异步爬虫\多任务协程.py:8&gt;&gt;, &lt;Task pending name='Task-4' coro=&lt;request() running at D:\PythonProject\异步爬虫\多任务协程.py:8&gt;&gt;, &lt;Task pending name='Task-5' coro=&lt;request() running at D:\PythonProject\异步爬虫\多任务协程.py:8&gt;&gt;]</span><br><span class="line">Task [&lt;Task finished name='Task-1' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\多任务协程.py:8&gt; result=200&gt;, &lt;Task finished name='Task-2' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\多任务协程.py:8&gt; result=200&gt;, &lt;Task finished name='Task-3' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\多任务协程.py:8&gt; result=200&gt;, &lt;Task finished name='Task-4' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\多任务协程.py:8&gt; result=200&gt;, &lt;Task finished name='Task-5' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\多任务协程.py:8&gt; result=200&gt;]</span><br><span class="line">Rusult: 200</span><br><span class="line">Rusult: 200</span><br><span class="line">Rusult: 200</span><br><span class="line">Rusult: 200</span><br><span class="line">Rusult: 200</span><br></pre></td></tr></table></figure>
<h2 id="协程实现">协程实现</h2>
<p>知道如何编写协程的代码了，我们再来实现以下对强制请求事件的网站，看看协程编程的用处。</p>
<p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    format='%(asctime)s - %(levelname)s : %(message)s')</span><br><span class="line"></span><br><span class="line">loop = asyncio.new_event_loop()</span><br><span class="line">asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line">TOTAL_NUMBER = 10</span><br><span class="line">URL = 'https://www.httpbin.org/delay/5'</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line">async def request():</span><br><span class="line">    print('Waiting for,', URL)</span><br><span class="line">    response = requests.get(URL)</span><br><span class="line">    print('Get response from', URL, 'response', response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request(), loop=loop) for _ in range(TOTAL_NUMBER)]</span><br><span class="line"></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">end_time = time.time()</span><br><span class="line">logging.info('total time %s second', end_time - start_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">2023-07-18 21:30:35,390 - INFO : total time 290.7061789035797 second</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到事件并没有加速，反而还更慢了！！！</p>
<p>其实要实现异步处理，先得有<code>挂起</code>操作</p>
<p>当一个任务需要等待<code>IO结果</code>时，可以挂起当前任务，转而进行其他任务这样才能更好的利用资源。</p>
<p>要实现异步，就要用<code>await</code>关键词，它可以将耗时等待的操作挂起，让出控制权。</p>
<p>如果协程再执行的时候遇到了<code>await</code>，事件循环就会将本协程挂起，转去执行其他的协程，知道协程挂起或者选择完毕。</p>
<p>改写代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Waiting for,'</span>, URL)</span><br><span class="line">    response = requests.get(URL)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Get response from'</span>, URL, <span class="string">'response'</span>, response)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-07-18 21:46:14,566 - ERROR : Task exception was never retrieved</span><br><span class="line">future: &lt;Task finished name='Task-1' coro=&lt;request() done, defined at D:\PythonProject\异步爬虫\协程延时访问.py:18&gt; exception=TypeError("object Response can't be used in 'await' expression")&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "D:\PythonProject\异步爬虫\协程延时访问.py", line 20, in request</span><br><span class="line">    response = await requests.get(URL)</span><br><span class="line">               ^^^^^^^^^^^^^^^^^^^^^^^</span><br></pre></td></tr></table></figure>
<p>但是这次却发生了错误，意思是<code>requests</code>返回的<code>Response</code>对象不能和<code>await</code>一起使用。</p>
<p><code>await</code>在官方文档中，<code>await</code>后面的对象必须是以下格式之一：</p>
<ul>
<li><p>一个原生协程对象</p>
<blockquote>
<p>原生协程对象（Native Coroutine
Object）是指使用<code>async</code>关键字定义的协程函数生成的协程对象。</p>
<p>在Python中，可以使用<code>async def</code>语法定义一个原生协程函数。原生协程函数可以包含<code>await</code>关键字来等待其他协程完成。当调用原生协程函数时，它将返回一个原生协程对象。</p>
</blockquote></li>
<li><p>一个由<code>types.coroutine</code>修饰的生成器，这个生成器可以返回协程对象</p>
<blockquote>
<p><code>types.coroutine</code>是一个装饰器函数，用于将生成器函数转换为原生协程对象。在Python中，生成器函数是一种特殊类型的函数，使用<code>yield</code>关键字来定义迭代器对象。</p>
<p>使用<code>types.coroutine</code>装饰器可以将生成器函数转换为原生协程对象，使其可以像其他原生协程函数一样被调度执行。</p>
</blockquote></li>
<li><p>由一个包含<code>__await__</code>特殊方法的对象返回的迭代器</p>
<blockquote>
<p>包含<code>__await__</code>特殊方法的对象返回的迭代器在Python中被称为可迭代的等待对象（awaitable
object）。</p>
<p>可迭代的等待对象是那些实现了<code>__await__</code>方法的对象。这个方法必须返回一个迭代器对象，该迭代器对象会在被await时被调用。</p>
<p>通常情况下，可迭代的等待对象可以是原生协程对象或异步上下文管理器对象。</p>
</blockquote>
<p>所以只要将返回的结果改成原生协程对象就可以了吗？</p>
<p>试一下！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">URL</span>):</span><br><span class="line">    <span class="keyword">return</span> requests.get(URL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Waiting for,'</span>, URL)</span><br><span class="line">    response = <span class="keyword">await</span> get(URL)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Get response from'</span>, URL, <span class="string">'response'</span>, response</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [504]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">Waiting for, https://www.httpbin.org/delay/5</span><br><span class="line">Get response from https://www.httpbin.org/delay/5 response &lt;Response [200]&gt;</span><br><span class="line">total time %s second 133.18833374977112</span><br></pre></td></tr></table></figure>
<p>可以看到还是没有实现异步操作，所以仅仅将<code>IO</code>操作封装到async修饰的方法还是不行的。</p>
<p>只有<strong>支持异步操作的请求方法财可以实现真正的异步</strong>。</p></li>
</ul>
<h2 id="使用aiohttp">使用aiohttp</h2>
<p><code>aiohttp</code>库是一个支持异步请求的库，它和<code>asycnio</code>库配合使用，可以使我们非常方便地实现异步请求操作。</p>
<p><code>aiohttp</code>的官方文档链接为：(https://aiohhtp.readthedocs.io/)</p>
<p>它分为两个部分，一部分为Client,另一部分时Server。</p>
<h3 id="安装aiohttp">安装aiohttp</h3>
<p>终端输入<code>pip install aiohttp</code>即可。</p>
<p>请确保<strong>网络</strong>通畅！</p>
<h3 id="改写代码">改写代码</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">TOTAL_NUMBER = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url</span>):</span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    <span class="keyword">await</span> response.text()</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():</span><br><span class="line">    url = <span class="string">'https://www.httpbin.org/delay/5'</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Waiting for'</span>, url)</span><br><span class="line">    response = <span class="keyword">await</span> get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Get responses from'</span>, url, <span class="string">'response'</span>, response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(TOTAL_NUMBER)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Cost Time:'</span>, end - start)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Waiting for https://www.httpbin.org/delay/5</span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:50 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:51 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:52 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:53 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [504 Gateway Time-out]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Server': 'awselb/2.0', 'Date': 'Tue, 18 Jul 2023 15:30:53 GMT', 'Content-Type': 'text/html', 'Content-Length': '132', 'Connection': 'keep-alive')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:54 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:30:54 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:31:15 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:31:19 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Get responses from https://www.httpbin.org/delay/5 response &lt;ClientResponse(https://www.httpbin.org/delay/5) [200 OK]&gt;</span><br><span class="line">&lt;CIMultiDictProxy('Date': 'Tue, 18 Jul 2023 15:31:29 GMT', 'Content-Type': 'application/json', 'Content-Length': '369', 'Connection': 'keep-alive', 'Server': 'gunicorn/19.9.0', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Credentials': 'true')&gt;</span><br><span class="line"></span><br><span class="line">Cost Time: 47.753435373306274</span><br></pre></td></tr></table></figure>
<p>可以看到真正的异步请求在时间效率上远远高于单线程的请求。</p>
<h3 id="原理解析">原理解析</h3>
<p>开始运行时，时间循环会运行第一个<code>task</code>,对于第一个<code>task</code>来说，当执行到第一个<code>await</code>跟着的<code>get</code>方法时，它会被挂起，但这个方法第一步时非阻塞的，挂起后会立马唤醒，立即又进行执行，并创建了<code>ClientSession</code>对象。</p>
<p>接着又遇到了第二个<code>await</code>，调用<code>session.get</code>方法，又被挂起，但是由于请求的时间很长，第一个被挂起的请求还处于被挂起状态，之后怎么办呢？</p>
<p>事件循环会寻找当前未被挂起的协程继续运行，以此类推。</p>
<p>那么当所有的<code>task</code>都被挂起了怎么办？</p>
<p>只能等待了，当排在前面的请求响应后，之后的<code>task</code>会被唤醒，以此类推。</p>
<h2 id="总结">总结</h2>
<p>异步操作的便捷之处就是，当遇到阻塞型操作时，task被挂起，程序接着去处理其他协程，充分的利用CPU，提高时间效率。</p>
<p>但是响应的处理时间的影响因素不只在于程序是由是异步还是同步，还在于服务器的处理能力，服务器处理高并发的任务的能力也是影响程序请求时间的重要因素。</p>
</p>]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax分析与爬取实战【爬虫】</title>
    <url>/2023/07/18/Ajax%E5%88%86%E6%9E%90%E4%B8%8E%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="ajax分析与爬取实战">Ajax分析与爬取实战</h1>
<p>Ajax的前置知识参在博文:<a href="https://helloxiunneg.com.cn/2023/07/18/Ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/#more">Ajax数据爬取</a></p>
<span id="more"></span>
<h2 id="准备工作">准备工作</h2>
<ul>
<li>安装好Python3</li>
<li>了解<code>requests</code>库</li>
<li>了解<code>Ajax</code>的基础知识和分析<code>Ajax</code>的基本方法</li>
</ul>
<h2 id="爬取目标">爬取目标</h2>
<p>爬取的链接为：<code>https://spa1.scrape.center/</code>，这网站的数据请求是由Ajax完成的，页面的内容是有JavaScript渲染出来的。</p>
<p>需要完成的目标：</p>
<ul>
<li>分析页面数据的加载逻辑</li>
<li>用requests库实现对Ajax数据的爬取</li>
<li>将每部电影的数据分别保存到MongoDB数据库</li>
</ul>
<h2 id="探索ajax页面的html文档">探索Ajax页面的HTML文档</h2>
<p>先尝试用requests库来简单的爬取页面，看看会有什么结果。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;&lt;meta charset=utf-<span class="number">8</span>&gt;&lt;meta http-equiv=X-UA-Compatible content=<span class="string">"IE=edge"</span>&gt;&lt;meta name=viewport content=<span class="string">"width=device-width,initial-scale=1"</span>&gt;&lt;link rel=icon href=/favicon.ico&gt;&lt;title&gt;Scrape | Movie&lt;/title&gt;&lt;link href=/css/chunk-700f70e1<span class="number">.1126</span>d090.css rel=prefetch&gt;&lt;link href=/css/chunk-d1db5eda<span class="number">.0</span>ff76b36.css rel=prefetch&gt;&lt;link href=/js/chunk-700f70e1<span class="number">.0548</span>e2b4.js rel=prefetch&gt;&lt;link href=/js/chunk-d1db5eda.b564504d.js rel=prefetch&gt;&lt;link href=/css/app.ea9d802a.css rel=preload <span class="keyword">as</span>=style&gt;&lt;link href=/js/app<span class="number">.17</span>b3aaa5.js rel=preload <span class="keyword">as</span>=script&gt;&lt;link href=/js/chunk-vendors<span class="number">.683</span>ca77c.js rel=preload <span class="keyword">as</span>=script&gt;&lt;link href=/css/app.ea9d802a.css rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;strong&gt;We<span class="string">'re sorry but portal doesn'</span>t work properly without JavaScript enabled. Please enable it to <span class="keyword">continue</span>.&lt;/strong&gt;&lt;/noscript&gt;&lt;div <span class="built_in">id</span>=app&gt;&lt;/div&gt;&lt;script src=/js/chunk-vendors<span class="number">.683</span>ca77c.js&gt;&lt;/script&gt;&lt;script src=/js/app<span class="number">.17</span>b3aaa5.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，与之前爬取到的<code>html</code>文档，这次由Ajax渲染的页面的<code>html</code>文档简短了很多。</p>
<p>但是看到的内容却与<code>https://ssr1.scrape.center/</code>的一模一样。</p>
<h2 id="爬取列表页">爬取列表页</h2>
<h3 id="分析列表页">分析列表页</h3>
<p>想要爬取Ajax页面就要先分析Ajax的接口逻辑。</p>
<p>打开页面的开发者模式，在<code>NetWork</code>中过滤出XHR。</p>
<p>在每次切换到下一页面时，都会监听到XHR请求。</p>
<p><img src="https://img.nickyam.com/file/d11f3a25d3e31df8225da.png"></p>
<p>打开第一个Ajax请求查看详情页</p>
<p><img src="https://img.nickyam.com/file/bf0a62e3bedd5b9e67b6c.png"></p>
<p>发现其Ajax接口的请求URL为<code>https://spa1.scrape.center/api/movie/?limit=10&amp;offset=10</code></p>
<p>可以看到有两个参数：</p>
<ul>
<li><strong>limit = 10</strong></li>
<li><strong>offset = 40</strong></li>
</ul>
<p>如果观察多个页面的Ajax请求，可以发现<code>limit</code>参数时每个页面最多的10条数据，<code>offset</code>是页面的参数，页面加1，<code>offset</code>+10。</p>
<p>再查看响应的内容：</p>
<p><img src="https://img.nickyam.com/file/b835ea9b5fa4f8d403d21.png"></p>
<p>返回的是一些JSON数据，其中<code>results</code>字段是一个列表，列表的元素都是一个字典，字典内容正是对应的电影数据的字段，而且这些数据都是高度结构化的，就是我们想要的数据。</p>
<p>所以只需要构造出所有的页面的Ajax接口，就可以轻松的获取所有页面的数据了。</p>
<h3 id="代码编写">代码编写</h3>
<p>首先引入<code>requests库</code>和<code>logging库</code>。</p>
<p>首先定义了logging的基本配置,再设置了初始的页面<code>INDEX_URL</code>,预留了<code>{limit}</code>和<code>{message}</code>的占位符。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa1.scrape.center/api/movie/?limit={limit}&amp;offset={offset}'</span></span><br></pre></td></tr></table></figure>
<p>再定义一个通用的爬取方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">"""爬取页面的接口"""</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_api</span>(<span class="params">url</span>):</span><br><span class="line">    logging.info(<span class="string">'scrape %s...'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">        logging.error(<span class="string">'get invalid status code %s while scraping %s'</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">'error occurred while scaping %s'</span>, url, exc_info=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这里由于是处理Ajax的数据，再之前的分析中，考率到Ajax的数据格式是JSON，所以这里是将返回的数据是经过<code>.json</code>的处理，转化成JSON类型。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line"><span class="string">"""构造多个页面的url并爬取"""</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_index</span>(<span class="params">page</span>):</span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=(page - <span class="number">1</span>) * LIMIT)</span><br><span class="line">    <span class="keyword">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>
<p>由于我们得到的数据是JSON文件，所以并不用解析数据了。</p>
<h2 id="爬取详情页">爬取详情页</h2>
<h3 id="分析详情页">分析详情页</h3>
<p>点击任意一部电影，分析其页面的组成和页面的URL。</p>
<p>点击<a href="https://spa1.scrape.center/detail/6">唐伯虎点秋香</a>页面，可以看到这个页面的URL的是</p>
<p><code>https://spa1.scrape.center/detail/6</code></p>
<p>同时刷新页面也可以看到接受到了XHR的请求。</p>
<p><img src="https://img.nickyam.com/file/01412d43123f7202b52d6.png"></p>
<p><img src="https://img.nickyam.com/file/202a0007a220f9b89766b.png"></p>
<p>请求的URL是：<code>https://spa1.scrape.center/api/movie/6/</code>，所以可以推导出页面的详情页的统一URL为：<code>https://spa1.scrape.center/api/movie/id/</code>其中<code>id</code>是电影的序号，而<code>index</code>的获取可以在Ajax列表页<code>id</code>中找到。</p>
<p>打开预览也是结构化的JSON，这也方便了我们的爬取。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DETAIL_URL = <span class="string">'https://spa1.scrape.center/api/movie/{id}'</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""详情页的爬取"""</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">return</span> scrape_api(url)</span><br></pre></td></tr></table></figure>
<h2 id="运行代码">运行代码</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">'%(asctime)s - %(levelname)s : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://spa1.scrape.center/api/movie/?limit={limit}&amp;offset={offset}'</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">DETAIL_URL = <span class="string">'https://spa1.scrape.center/api/movie/{id}'</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""爬取页面的接口"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_api</span>(<span class="params">url</span>):</span><br><span class="line">    logging.info(<span class="string">'scrape %s...'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">        logging.error(<span class="string">'get invalid status code %s while scraping %s'</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">'error occurred while scraping %s'</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""构造多个页面的url"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_index</span>(<span class="params">page</span>):</span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=(page - <span class="number">1</span>) * LIMIT)</span><br><span class="line">    <span class="keyword">return</span> scrape_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""详情页的爬取"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">return</span> scrape_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_data = scrape_index(page)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">'results'</span>):</span><br><span class="line">            <span class="built_in">id</span> = item.get(<span class="string">'id'</span>)</span><br><span class="line">            detail_data = scrape_detail(<span class="built_in">id</span>)</span><br><span class="line">            logging.info(<span class="string">'detail data %s'</span>, detail_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的会依次爬取每一个列表页的Ajax接口，然后依次爬取每一步电影的详情页的Ajax接口，并打印每部电影的Ajax接口响应接口，而且都是JSON格式。</p>
<h2 id="保存数据">保存数据</h2>
<p>JSON的格式，用非关系型数据型的MongoDB的数据库十分便于存储JSON文件。</p>
<p>首先确保MongoDB服务打开并且正确连接到MongoDB数据库，这里使用本地的默认的端口<code>27017</code>。</p>
<p>配置一下数据库并实现数据保存到数据库：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="string">"""MongoDB数据库配置"""</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'movies'</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">'movies'</span></span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line"><span class="string">"""数据保存到数据库"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    collection.update_one({<span class="string">'name'</span>: data.get(<span class="string">'name'</span>)}, {<span class="string">'$set'</span>: data}, upsert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MONGO_CONNECTION_STRING</code>:MongoDB的连接字符串，定义了MongoDB的<code>host</code>、<code>端口</code>，还可以设置用户名和密码。<br>
</li>
<li><code>MONGO_DB_NAME</code>:MongoDB数据库的名称</li>
<li><code>MONGO_COLLECTION_NAM</code>:MongoDB数据库的集合</li>
</ul>
<blockquote>
<p>这段代码使用<code>update_one</code>函数将数据保存到数据库中。它使用<code>data</code>中的<code>name</code>字段作为查询条件，如果存在匹配的记录，则使用<code>$set</code>操作符将<code>data</code>的内容更新到该记录；如果没有匹配的记录，则将整个<code>data</code>插入到数据库中。</p>
<p><code>upsert</code>是一个数据库操作的选项之一，它是 “update” 和
“insert” 两个词的组合。</p>
<p>当执行更新操作时，<code>upsert</code>选项表示：如果找到了匹配的记录，则执行更新操作；如果没有找到匹配的记录，则插入一条新的记录。</p>
</blockquote>
<p>成功爬取到了数据：</p>
<p><img src="https://img.nickyam.com/file/5954d23e9d4432f15af3b.png"></p>
<h2 id="总结">总结</h2>
<p>网页的数据可能并不会直接放在html文档中，有些可能会使用Ajax，所以爬取网页时都要先去分析网页。</p>
<p>Ajax返回的数据类型都是JSON格式的类型，所以一定程度上减少了数据解析的工作。</p>
<p>JSON格式的数据可以选用非关系型的数据库来存储。</p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫实战案例</category>
      </categories>
      <tags>
        <tag>爬虫实战</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax简介</title>
    <url>/2023/07/18/Ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="ajax数据爬取">Ajax数据爬取</h1>
<p>我们用<code>requests</code>爬取数据时，爬取的<code>HTML</code>文档,但是浏览器的页面是JavaSript处理数据之后生成的结果。</p>
<p>这种数据的来源有两种：</p>
<ul>
<li>通过Ajax加载的</li>
<li>经过JavaScript和特定的算法计算后生成的</li>
</ul>
<span id="more"></span>
<h2 id="什么是ajax">什么是Ajax？</h2>
<p><code>Ajax</code>,<code>Asynchronous JavaScipt and XML</code>,异步的JavaScipt和XML。</p>
<p>它是利用JavaScript在保证页面不被刷新，页面链接不改变的情况下与服务器交换数据并更新部分网页内容的技术。</p>
<p>有了Ajax，可以在页面不被全部刷新的情况下更新。</p>
<p>这个过程其实是页面在后台与服务器进行了数据交换，获取数据后，再利用JavaScript改变网页。</p>
<p><a href="https://www.w3school.com.cn/js/js_ajax_http_send.asp">AJAX -
XMLHttpRequest (w3school.com.cn)</a></p>
<h3 id="示例">示例</h3>
<p>比如许多的信息流页面仅仅会在开始时只有几条推文，但是我们下拉到底部之后会出现”加载中“，之后就会出现新的内容。</p>
<p>其实页面地址并没有变化，但是网页中却多了新的内容，这就是通过Ajax获取新数据并呈现的过程。</p>
<h3 id="基本原理">基本原理</h3>
<p>Ajax的请求到网页更新可以分为3步——发送请求、解析内容和渲染网页。</p>
<ul>
<li><p><strong>发送请求</strong></p>
<p>以下是Ajax实现的交互功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line">if (window.XMLHttpRequest){</span><br><span class="line">    xmlhttp=new XMLHttpRequest();</span><br><span class="line">}else{ // code for IE6 IE5</span><br><span class="line">    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");</span><br><span class="line">}</span><br><span class="line">xmlhttp.onreadystatechange=function(){</span><br><span class="line">    if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status == 200){</span><br><span class="line">        document.getElementById("myDiv").innerHTML=xmlhttp.responseText;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">xmlhttp.open("POST","/ajax/",true)</span><br><span class="line">xmlhttp.send()</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>这段代码使用XMLHttpRequest对象向服务器发送POST请求，并将服务器的响应文本展示在一个拥有id为"myDiv"的HTML元素内。</p>
<p>注意，这段代码存在一些问题，尤其在IE6和IE5浏览器上。这是因为IE6和IE5使用ActiveXObject来创建XMLHttpRequest对象，而其他现代浏览器使用window.XMLHttpRequest。在现代浏览器中，ActiveXObject并不是必需的</p>
</blockquote>
<ul>
<li>发送请求</li>
</ul>
<p>​ 这是 JavaScript 对 Ajax 最底层的实现，实际上就是新建了
<code>XMLHttpRequest</code> 对象，然后调用
<code>onreadystatechange</code>属性设置了<code>监听</code>，然后调用<code>open()</code>
和 <code>send()</code> 方法向某个链接（也就是服务器）发送了请求。前面用
Python
实现请求发送之后，可以得到响应结果，但这里请求的发送变成<code>JavaScript</code>来完成。由于设置了监听，所以当服务器返回响应时，<strong>onreadystatechange
对应的方法便会被触发</strong>，然后在这个方法里面解析响应内容即可。</p>
<ul>
<li>解析内容</li>
</ul>
<p>​ 得到响应之后，<code>onreadystatechange</code>
属性对应的方法便会被触发，此时利用 xmlhttp 的 <strong>responseText
属性便可取到响应内容</strong>。这类似于 Python 中利用 requests
向服务器发起请求，然后得到响应的过程。那么返回内容可能是 HTML，可能是
JSON，接下来只需要在方法中用 JavaScript 进一步处理即可。比如，如果是
JSON 的话，可以进行解析和转化。</p>
<ul>
<li>渲染网页</li>
</ul>
<p>​ JavaScript 有改变网页内容的能力，解析完响应内容之后，就可以调用
JavaScript 来针对解析完的内容对网页进行下一步处理了。比如，通过
<strong>document.getElementById().innerHTML
这样的操作，便可以对某个元素内的源代码进行更改</strong>，这样网页显示的内容就改变了，这样的操作也被称作
<strong>DOM 操作，即对 Document
网页文档进行操作，如更改、删除等</strong>。</p>
<h2 id="ajax分析方法">Ajax分析方法</h2>
<p>Ajax有着特殊的请求类型——<code>xhr</code>，当我们在开发者工具中观察，type为xhr的话，这就是一个Ajax的请求。</p>
<p>在Ajax请求的请求头中有一个信息的为<code>X-Requested-With:XMLHttpRequest</code>。</p>
<ul>
<li><p>过滤请求</p>
<p>开发者模式可以筛选出全部的XHR请求。</p></li>
</ul>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB文档存储</title>
    <url>/2023/07/17/MongoDB%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="mongodb文档存储">MongoDB文档存储</h1>
<p><code>NoSQL</code>，Not Only
SQL，不仅仅是SQL，泛指非关系型数据库，它是基于键值对的，而且不需要经过SQL层的解析，数据之间没有<code>耦合性</code>，性能很高。</p>
<span id="more"></span>
<blockquote>
<p>在计算机科学中，耦合性（Coupling）是指模块或组件之间互相依赖的程度。它描述了一个模块与其他模块之间的关系强度。</p>
<p>耦合性越强，表示模块之间的依赖关系越紧密，一个模块的改动可能会影响到其他模块。耦合性强的系统通常比较难于维护和修改，因为一个小的改动可能会导致系统的其他部分出现意外的行为。</p>
<p>耦合性可以分为两种类型：松散耦合（loose coupling）和紧密耦合（tight
coupling）。</p>
<p>松散耦合意味着模块之间的依赖关系较弱，模块之间通过接口进行通信，彼此的内部实现可以独立地修改而不会影响到其他模块。这种设计可以提高系统的可维护性和可扩展性。</p>
<p>紧密耦合则是模块之间的依赖关系很强，一个模块的改动可能会牵扯到其他模块的修改。紧密耦合的系统往往比较难以维护和扩展，因为修改一个模块可能需要对整个系统进行全面的测试和验证。</p>
<p>设计良好的软件系统应该尽量减少模块之间的耦合性，以提高系统的灵活性、可维护性和可扩展性。为了达到这个目标，可以采用一些设计原则和模式，例如面向接口编程、依赖注入等。这些方法可以帮助将模块解耦，降低系统的复杂度，提高代码的可读性和可测试性。</p>
</blockquote>
<p>爬虫爬取的数据，一条数据可能存在应某些字段的缺失，或者需要随时的调整，数据之间可能会嵌套。使用关系型数据库存储这些数据，首先需要提前建表，再是如果数据之间有嵌套的话，还需要进行序列化操作才能存储。</p>
<p>而使用非关系型的数据库就可以有限的避免这些问题。</p>
<p><code>MongoDB数据库</code>干刚好可以满足这个需求。</p>
<p>mongoDB数据库是由C++编写的非关系型的数据库，是一个基于分布式文件存储的开源数据库系统。</p>
<p>其内容的存储形式类似为JSON格式。</p>
<h2 id="安装mongodb与pymongo库">安装MongoDB与PyMongo库</h2>
<p>MongoDB<a
href="https://www.mongodb.com/try/download/community">官网</a>:https://www.mongodb.com/try/download/community</p>
<p>安装<code>PymongoDB</code>,在终端输入：</p>
<p><code>pip install pymongo</code></p>
<p>但是新版的PyMongo的有些操作变换了，还是建议下载旧版的PyMongo。</p>
<p><code>pip uninstall pymongo</code></p>
<p><code>pip install pymongo==3.9</code></p>
<h2 id="连接mongodb">连接MongoDB</h2>
<p>连接MongoDB时，需要用到PyMongo库中的<code>MongoClient</code>方法，需要输入<code>IP</code>和<code>端口</code>即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为数据库运行在本地所以主机名为<code>localhost</code>，MongoDB的默认端口为<code>27017</code>。</p>
<h2 id="指定数据库">指定数据库</h2>
<p>在MongoDB中可以建立多个数据库，所以需要指定操作那个数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line">db = client.test <span class="comment"># 写法1</span></span><br><span class="line"><span class="comment"># db = client[&#x27;test&#x27;] # 写法2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指定集合">指定集合</h2>
<p>每个数据库又包含了许多的集合(collection),这些集合类似于关系型数据库的表。</p>
<p>指定需要操作哪些集合，这里指定一个集合，名称为students。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">collection = db.students <span class="comment"># 写法1</span></span><br><span class="line">collection = db[<span class="string">&#x27;students&#x27;</span>] <span class="comment"># 写法2</span></span><br></pre></td></tr></table></figure>
<h2 id="插入数据">插入数据</h2>
<p>在students这个集合时，新建一条学生数据，这条数据以字典的形式表示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line">db = client.test <span class="comment"># 写法1</span></span><br><span class="line">collection = db.students </span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10001&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Xiunneg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10002&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;JR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student3 = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10003&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dzk&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert_one(student1)</span><br><span class="line">result1 = collection.insert_many([student2,student3])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.inserted_id)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="built_in">print</span>(result1.inserted_ids)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pymongo.results.InsertOneResult object at 0x000001202D5603D0&gt;</span><br><span class="line">64b531f13a4551b361617446</span><br><span class="line">&lt;pymongo.results.InsertManyResult object at 0x000001202D560640&gt;</span><br><span class="line">[ObjectId(&#x27;64b531f13a4551b361617447&#x27;), ObjectId(&#x27;64b531f13a4551b361617448&#x27;)]</span><br></pre></td></tr></table></figure>
<p><code>insert_one</code>用于插入一条数据，产生的<code>_id</code>类型为<code>InsertOneResult object</code>，调用<code>inserted_id</code>可以获得插入数据的<code>_id</code>值。</p>
<p><code>insert_many</code>用于插入多条数据，接受list类型,产生的<code>_id</code>类型为<code>InsertManyResult object</code>,调用<code>inserted_ids</code>属性可以获得插入数据的<code>_id</code>值</p>
<p>在MongoDB中，每条数据都会有<code>_id</code>属性作为<code>唯一标识</code>，如果没有显式指明该属性，满MongoDB会自动产生一个<code>ObjectID</code>类型的<code>_id</code>属性，两种insert方法执行完之后返回<code>_id</code>值。</p>
<h2 id="查找">查找</h2>
<p>插入数据后可以利用<code>find_one</code>或者<code>find</code>方法进行查询，前者查询到的是单个结果，而后者则是会返回一个<code>生成器类型</code>。</p>
<blockquote>
<p>生成器（Generator）是Python中一种特殊的迭代器（Iterator）类型。与普通的函数不同，生成器函数使用<code>yield</code>关键字来暂停函数的执行，并在需要时恢复执行。</p>
<p>生成器函数在被调用时并不立即执行，而是返回一个生成器对象。通过不断迭代这个生成器对象，可以逐个获取生成器函数中使用<code>yield</code>语句返回的值。每次迭代时，生成器函数会从上一次<code>yield</code>语句暂停的位置继续执行，直到下一次<code>yield</code>语句，并将<code>yield</code>后的值返回。</p>
<p>生成器的主要优点是它们可以按需生成数据，而不需要一次性生成并存储所有的值。这使得它们非常适合处理大量数据或无序数据流。通过生成器，可以将一个大型问题分解成一系列小问题，逐个解决。</p>
<p>生成器可以使用两种方式定义：</p>
<ol type="1">
<li>生成器函数：是一种使用关键字<code>yield</code>的函数，当调用该函数时返回一个生成器对象。</li>
<li>生成器表达式：类似于列表推导式，使用圆括号而不是方括号，可以在需要时生成迭代的值。</li>
</ol>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Xiunneg&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b52fc4da436e2ccbdf4f2d&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以用<code>bson</code>库里面的<code>objectid</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;64b52fc4da436e2ccbdf4f2d&#x27;</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b52fc4da436e2ccbdf4f2d&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到返回的类型都是字典类型。</p>
<p>查询多条数据可以使用<code>find</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">results = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pymongo.cursor.Cursor object at 0x000001BF7F17C490&gt;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b52fc4da436e2ccbdf4f2d&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b52fcf413f9b3216556a95&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b5316a1b342a8f859867df&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b53171d22d845fea877328&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b5318d0d2c327acaf55a92&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b531937eab1e93681b9cdc&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b531a16d18424659abff4a&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line">&#123;&#x27;_id&#x27;: ObjectId(&#x27;64b531f13a4551b361617446&#x27;), &#x27;id&#x27;: &#x27;10001&#x27;, &#x27;name&#x27;: &#x27;Xiunneg&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>find</code>返回<code>Cursor</code>类型，相当于一个生成器。</p>
<p>查询大于20的数据，写法为:</p>
<p><code>results = collection.find(&#123;'age': &#123;'$gt': 20&#125;&#125;)</code></p>
<p>其他符号:</p>
<table>
<thead>
<tr class="header">
<th>符　　号</th>
<th>含　　义</th>
<th>示　　例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$lt</code></td>
<td>小于</td>
<td><code>&#123;'age': &#123;'$lt': 20&#125;&#125;</code></td>
</tr>
<tr class="even">
<td><code>$gt</code></td>
<td>大于</td>
<td><code>&#123;'age': &#123;'$gt': 20&#125;&#125;</code></td>
</tr>
<tr class="odd">
<td><code>$lte</code></td>
<td>小于等于</td>
<td><code>&#123;'age': &#123;'$lte': 20&#125;&#125;</code></td>
</tr>
<tr class="even">
<td><code>$gte</code></td>
<td>大于等于</td>
<td><code>&#123;'age': &#123;'$gte': 20&#125;&#125;</code></td>
</tr>
<tr class="odd">
<td><code>$ne</code></td>
<td>不等于</td>
<td><code>&#123;'age': &#123;'$ne': 20&#125;&#125;</code></td>
</tr>
<tr class="even">
<td><code>$in</code></td>
<td>在范围内</td>
<td><code>&#123;'age': &#123;'$in': [20, 23]&#125;&#125;</code></td>
</tr>
<tr class="odd">
<td><code>$nin</code></td>
<td>不在范围内</td>
<td><code>&#123;'age': &#123;'$nin': [20, 23]&#125;&#125;</code></td>
</tr>
</tbody>
</table>
<p>还有正则匹配查询，语句为：</p>
<p><code>results = collection.find(&#123;'name': &#123;'$regex': '^X.*'&#125;&#125;)</code></p>
<p>更多的的功能符号：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">符　　号</th>
<th style="text-align: center;">含　　义</th>
<th style="text-align: center;">示　　例</th>
<th style="text-align: center;">示例含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>$regex</code></td>
<td style="text-align: center;">匹配正则表达式</td>
<td style="text-align: center;">{'name': {'<code>$regex</code>':
'^M.*'}}</td>
<td style="text-align: center;">name 以 M 开头</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>$exists</code></td>
<td style="text-align: center;">属性是否存在</td>
<td style="text-align: center;">{'name': {'<code>$exists</code>':
True}}</td>
<td style="text-align: center;">name 属性存在</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>$type</code></td>
<td style="text-align: center;">类型判断</td>
<td style="text-align: center;">{'age': {'<code>$type</code>':
'int'}}</td>
<td style="text-align: center;">age 的类型为 int</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>$mod</code></td>
<td style="text-align: center;">数字模操作</td>
<td style="text-align: center;">{'age': {'<code>$mod</code>': [5,
0]}}</td>
<td style="text-align: center;">年龄模 5 余 0</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>$text</code></td>
<td style="text-align: center;">文本查询</td>
<td style="text-align: center;">{'<code>$text</code>':
{'<code>$search</code>': 'Mike'}}</td>
<td style="text-align: center;">text 类型的属性中包含 Mike 字符串</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>$where</code></td>
<td style="text-align: center;">高级条件查询</td>
<td style="text-align: center;">{'<code>$where</code>': 'obj.fans_count
== obj.follows_count'}</td>
<td style="text-align: center;">自身粉丝数等于关注数</td>
</tr>
</tbody>
</table>
<h2 id="计数">计数</h2>
<p>统计查询结果包含多少条数据，可以调用<code>count_documents()</code>方法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">count = collection.count_documents(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Xiunneg&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(count))</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<p>排序时直接调用<code>sort</code>方法，并传入排序的字段即升降标志即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(results))</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pymongo.cursor.Cursor&#x27;&gt;</span><br><span class="line">[&#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="偏移">偏移</h2>
<p>如果我们只想取某几个元素，这时可以利用<code>skip()</code>方法偏移几个位置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(results))</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pymongo.cursor.Cursor&#x27;&gt;</span><br><span class="line">[&#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;Dzk&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;JR&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;, &#x27;Xiunneg&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更新">更新</h2>
<p>更新数据时，使用<code>updata</code>方法。</p>
<p>可以指定更新的条件和更新后的数据即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dzk&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">10</span></span><br><span class="line">result = collection.update(condition,student)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = red size = 12>但是！</font></p>
<p><code>update</code>方法并不是官方推荐的方法，官方推荐的方法时<code>update_one()</code>和<code>update_many()</code>，它们有更严格的参数，第二个参数必须是<code>$</code>类型操作符作为字典的键名。</p>
<p><code>update_one示例</code>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">10</span>&#125;&#125;</span><br><span class="line">result = collection.find_one(condition, &#123;<span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.matched_count, result.modified_count)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先，你连接到本地的MongoDB实例并选择了一个数据库和一个集合。然后，你定义了一个条件来筛选出年龄大于10岁的文档，并使用<code>find_one</code>方法找到其中的一个文档。你还使用了<code>$inc</code>操作符来将该文档的年龄加1。</p>
<p>在最后，你打印了更新后的文档和<code>matched_count</code>（匹配的文档数量）以及<code>modified_count</code>（修改的文档数量）。</p>
<p>请注意，<code>find_one</code>方法返回一个文档对象，它不具有<code>matched_count</code>和<code>modified_count</code>属性。如果你想获取匹配的文档数量和修改的文档数量，可以使用<code>update_one</code>方法，并检查返回的<code>UpdateResult</code>对象的属性。</p>
<p><code>update_many</code>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">condition = &#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">10</span>&#125;&#125;</span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.matched_count, result.modified_count)</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<p>删除操作直接调用<code>remove</code>方法即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">result = collection.remove(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dzk&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;n&#x27;: 0, &#x27;ok&#x27;: 1.0&#125;</span><br></pre></td></tr></table></figure>
<p>同样官方推荐了<code>delete_one</code>和<code>delete_many</code>方法。</p>
<p><code>delete_one</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;JR&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.deleted_count)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pymongo.results.DeleteResult object at 0x0000024C622445C0&gt;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><code>delete_many</code>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">collection = db.students</span><br><span class="line"></span><br><span class="line">result = collection.delete_many(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;JR&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.deleted_count)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pymongo.results.DeleteResult object at 0x000001753BDD4640&gt;</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="更多的操作">更多的操作</h2>
<p>另外，PyMongo 还提供了一些组合方法，如
find_one_and_delete()、find_one_and_replace() 和
find_one_and_update()，它们是查找后删除、替换和更新操作，其用法与上述方法基本一致。</p>
<p>另外，还可以对索引进行操作，相关方法有
create_index()、create_indexes() 和 drop_index() 等。</p>
<p>关于 PyMongo 的详细用法，可以参见官方文档：<a
href="http://api.mongodb.com/python/current/api/pymongo/collection.html">http://api.mongodb.com/python/current/api/pymongo/collection.html</a>。</p>
<h2 id="总结">总结</h2>
<p>MongoDB的增删改查操作已经基本熟悉。</p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
        <category>数据库</category>
        <category>Python高级编程</category>
        <category>MOngoDB</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>MOngoDB</tag>
        <tag>Python高级编程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中MySQL的使用【爬虫】</title>
    <url>/2023/07/17/Python%E4%B8%ADMySQL%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="mysql-的存储">MySQL 的存储</h1>
<p>关系型数据库是基于关系模型的数据库，关系模型是通过二维表来保存的，所以关系型数据库中的数据的存储方式就是行列组成的表，每一列代表一个字段，每一行代表一个记录。</p>
<p><code>Python</code>关于操作<code>MySQL</code>的库是<code>PyMySQL</code>。</p>
<span id="more"></span>
<h2 id="pymysql和mysql的安装">PyMySQL和MySQL的安装</h2>
<p>MySQL的安装可以直接去<a
href="https://dev.mysql.com/downloads/mysql/">官网</a>下载:(https://dev.mysql.com/downloads/mysql/)</p>
<p>PyMySQL的安装：</p>
<p>在终端输入：</p>
<p><code>pip install pymysql</code></p>
<h2 id="连接到数据库">连接到数据库</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,port=<span class="number">3306</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT VERSION()&#x27;</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Database version:&#x27;</span>,data)</span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8mb4&quot;</span>)</span><br><span class="line"></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>首先通过PyMySQL的<code>connect</code>方法声明了一个<code>MySQL</code>连接对象<code>db</code>，参数对照如下：</p>
<ul>
<li><code>host</code>:主机地址，由于数据库在机器本地，所以使用<code>localhost</code>。</li>
<li><code>user</code>:用户名，使用数据库默认的<code>root</code>的用户。</li>
<li><code>password</code>:用户密码。</li>
<li><code>port</code>:数据库端口，数据库默认<code>port</code>为3306</li>
</ul>
<p>连接成功后，调用<code>cursor</code>方法获得<code>MySQL</code>的操作游标，利用游标可以操作SQL语句。</p>
<p>这里首先执行了MySQL的当前版本，<code>fetchone()</code>方法获得第一条数据。</p>
<blockquote>
<p><code>fetchone()</code>
是一种用于从数据库查询结果集中检索下一行的方法。在编程中，它通常用于与数据库连接和执行
SQL 查询的过程中。</p>
</blockquote>
<p>之后再用SQL语句创建了一个数据库<code>spiders</code>。</p>
<h2 id="创建表">创建表</h2>
<p>确保数据库保持开启状态，且python程序已经连接到了数据库。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,port=<span class="number">3306</span>,db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&#x27;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL,name VARCHAR(255) NOT NULL,&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;age INT NOT NULL, PRIMARY KEY (id))&#x27;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字段名</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">id</td>
<td style="text-align: center;">学号</td>
<td style="text-align: center;">varchar</td>
</tr>
<tr class="even">
<td style="text-align: center;">name</td>
<td style="text-align: center;">姓名</td>
<td style="text-align: center;">varchar</td>
</tr>
<tr class="odd">
<td style="text-align: center;">age</td>
<td style="text-align: center;">年龄</td>
<td style="text-align: center;">int</td>
</tr>
</tbody>
</table>
<p>在实际的操作中，会根据爬取的结果来设计特定的字段。</p>
<h2 id="插入数据">插入数据</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;待添加的信息&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">id</span> = <span class="string">&#x27;20210101&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;修能&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,port=<span class="number">3306</span>,db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO students(id,name,age) value(%s,%s,%s)&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql,(<span class="built_in">id</span>,name,age))</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>sql语句可以用格式化的字符来简易的构造，之后在输入元组即可对应参数。</p>
<p><font color = red>注意：在插入数据后要使用<code>.commit()</code>来保存数据。</font></p>
<blockquote>
<p>在数据库操作中，<code>commit()</code>
是一个方法，用于将挂起的事务保存并永久地应用于数据库。它将事务中的所有更改持久化，使其成为数据库的一部分。</p>
<p>当您执行插入、更新或删除等修改操作时，这些更改会在事务中进行缓冲，而不会立即应用到数据库中。这样可以确保一系列相关操作的原子性，即要么全部成功应用，要么全部回滚。例如，在一个事务中插入多个记录，如果其中任何一条插入失败，可以回滚整个事务，以保持数据的一致性。</p>
<p>而 <code>commit()</code>
方法的作用是显式地提交事务，将事务中的更改应用到数据库。一旦调用了
<code>commit()</code>，所做的更改将永久保存在数据库中，并且不可逆转。</p>
<p>在使用某些数据库引擎或框架时，如果不显式地调用
<code>commit()</code>，所做的更改可能不会立即生效，而是在事务结束时自动提交。但是，对于某些数据库引擎，如
SQLite，在默认情况下，每个 SQL
语句都会自动成为一个事务，并在执行完毕后自动提交。</p>
<p>因此，根据您使用的数据库引擎和使用的事务模式，<code>commit()</code>
的具体用法可能会有所不同。在大多数情况下，当您的事务完成且您确认要将更改永久保存到数据库时，调用
<code>commit()</code> 是一个好的实践。</p>
</blockquote>
<p>异常处理是一个很好的习惯，一旦发生异常，不会让我们的数据库遭到破坏，<code>.rollback()</code>是让操作回滚的方法，相当于什么都没有发生过。</p>
<blockquote>
<p>在数据库操作中，<code>.rollback()</code>
是一个方法，用于撤销挂起的事务并回滚（取消）对数据库所做的所有更改。</p>
<p>事务是数据库操作的逻辑单元，可以包含多个操作（例如插入、更新或删除数据）。如果在事务过程中发生错误或不满足某些条件，您可能希望撤销该事务并恢复到操作前的状态。这时就可以使用
<code>.rollback()</code> 方法。</p>
<p>当调用 <code>.rollback()</code>
方法时，将撤销事务中的所有更改，并将数据库恢复到事务开始时的状态。这样，所有更改都被取消，数据库中的数据将回滚到之前的状态。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>属　　性</th>
<th>解　　释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>原子性（atomicity）</td>
<td>事务是一个<code>不可分割</code>的工作单位，事务中包括的诸操作要么都做，要么都不做</td>
</tr>
<tr class="even">
<td>一致性（consistency）</td>
<td>事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</td>
</tr>
<tr class="odd">
<td>隔离性（isolation）</td>
<td>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</td>
</tr>
<tr class="even">
<td>持久性（durability）</td>
<td>持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</td>
</tr>
</tbody>
</table>
<p>所以一般的标准更改(插入、删除和更新)操作，一般的代码为：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:	</span><br><span class="line">    db.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br></pre></td></tr></table></figure>
<p>但是这样的插入方法比较麻烦，作为通用方法，只需要传入一个动态的字典就可以了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220202&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;JR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">33</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">keys = <span class="string">&#x27;,&#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line">sql = <span class="string">f&#x27;INSERT INTO <span class="subst">&#123;table&#125;</span> (<span class="subst">&#123;keys&#125;</span>) VALUES (<span class="subst">&#123;values&#125;</span>)&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql,<span class="built_in">tuple</span>(data.values())):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Successful!&#x27;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys:id,name,age</span><br><span class="line">values:%s,%s,%s</span><br><span class="line">sql:INSERT INTO students (id,name,age) VALUES (%s,%s,%s)</span><br></pre></td></tr></table></figure>
<p><code>values = ','.join(['%s'] * len(data))</code>安装值的数量生成相应数量<code>%S</code>占位符。</p>
<h2 id="更新数据">更新数据</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;UPDATE students SET age = %s WHERE name = %s&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="number">1009</span>, <span class="string">&#x27;JR&#x27;</span>))</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>灵活的字典：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220202&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;JR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">33</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">keys = <span class="string">&#x27;,&#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line">sql = <span class="string">f&#x27;INSERT INTO <span class="subst">&#123;table&#125;</span> (<span class="subst">&#123;keys&#125;</span>) VALUES (<span class="subst">&#123;values&#125;</span>) ON DUPLICATE KEY UPDATE &#x27;</span></span><br><span class="line">update = <span class="string">&#x27;,&#x27;</span>.join([<span class="string">f&quot;<span class="subst">&#123;key&#125;</span> = %s&quot;</span> <span class="keyword">for</span> key <span class="keyword">in</span> data])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sql += update</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql,<span class="built_in">tuple</span>(data.values()) * <span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Successful!&#x27;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>在插入语句中，加入<code>ON DUPLICATE KEY UPDATE</code>语句的作用是：<font color = blue>如果主键存在，就执行更新操作。</font></p>
<p>完整的SQL的语句是：</p>
<p><code>INSERT INTO students (id,name,age) VALUES (%s,%s,%s) ON DUPLICATE KEY UPDATE id = %s,name = %s,age = %s ('20220202', 'JR', 33, '20220202', 'JR', 33)</code></p>
<h2 id="删除数据">删除数据</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">condition = <span class="string">&#x27;age &gt; 22&#x27;</span></span><br><span class="line"></span><br><span class="line">sql = <span class="string">f&#x27;DELETE FROM <span class="subst">&#123;table&#125;</span> WHERE <span class="subst">&#123;condition&#125;</span>&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>就是简单删除语句。</p>
<h2 id="查询语句">查询语句</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;SELECT * FROM students WHERE age &gt;= 20&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Count:&#x27;</span>,cursor.rowcount)</span><br><span class="line">    one = cursor.fetchone()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;One:&#x27;</span>,one)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Result:&#x27;</span>,results)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ResultType:&#x27;</span>,<span class="built_in">type</span>(results))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Count: 4</span><br><span class="line">One: (&#x27;20210101&#x27;, &#x27;修能&#x27;, 20)</span><br><span class="line">Result: ((&#x27;20220202&#x27;, &#x27;JR&#x27;, 33), (&#x27;20220203&#x27;, &#x27;DZK&#x27;, 23), (&#x27;20220204&#x27;, &#x27;GKH&#x27;, 32))</span><br><span class="line">ResultType: &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">(&#x27;20220202&#x27;, &#x27;JR&#x27;, 33)</span><br><span class="line">(&#x27;20220203&#x27;, &#x27;DZK&#x27;, 23)</span><br><span class="line">(&#x27;20220204&#x27;, &#x27;GKH&#x27;, 32)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>fetchall()</code>
是一种用于从数据库查询结果集中检索所有行的方法。它将返回一个包含所有行的列表，每个行都以元组的形式表示</p>
</blockquote>
<figure>
<img src="https://img.nickyam.com/file/d9d709156bb70d1a41b30.png"
alt="数据库" />
<figcaption aria-hidden="true">数据库</figcaption>
</figure>
<h3 id="更简约的查找">更简约的查找</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;SELECT * FROM students WHERE age &gt;= 20&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Count:&#x27;</span>,cursor.rowcount)</span><br><span class="line">    row = cursor.fetchone()</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Row:&#x27;</span>,row)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Count: 4</span><br><span class="line">Row: (&#x27;20210101&#x27;, &#x27;修能&#x27;, 20)</span><br><span class="line">Row: (&#x27;20220202&#x27;, &#x27;JR&#x27;, 33)</span><br><span class="line">Row: (&#x27;20220203&#x27;, &#x27;DZK&#x27;, 23)</span><br><span class="line">Row: (&#x27;20220204&#x27;, &#x27;GKH&#x27;, 32)</span><br></pre></td></tr></table></figure>
<p>用while循环加<code>fetchone()</code>来获取所有的数据，而不是<code>fetchall()</code>全部获取出来。</p>
<p>因为<code>fetchall</code>会将结果以元组的形式全部返回，如果数据过多，资源的占用会比较大。</p>
<p>用while这种写法，每获取一次数据指针就会向下偏移一次，比较简答高效，资源的占用也比较小。</p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
        <category>数据库</category>
        <category>Python高级编程</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python高级编程</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据的文本存储【爬虫】</title>
    <url>/2023/07/15/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="数据的存储">数据的存储</h1>
<p>用解析器解析完数据之后，想办法让解析后的数据存储起来就成了一个问题。</p>
<p>一般有两种存储的方式：<br />
- 文本的存储形式，如TXT、JSON、CSV。<br />
- 或者将数据存储在数据库中。</p>
<span id="more"></span>
<h2 id="txt文本文件存储">TXT文本文件存储</h2>
<p>txt文本几乎可以兼容任何平台，但是缺点是不利于检索。<br />
所以追求方便txt文件时第一选择。</p>
<h3 id="基本实例">基本实例</h3>
<p>实例的目标：爬取网站：<code>https://ssr1.scrape.center/</code>中首页的10部电影的数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://ssr1.scrape.center/&#x27;</span></span><br><span class="line">html = requests.get(url).text</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.el-card&#x27;</span>).items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># file = open(&#x27;movies_TXT.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    <span class="comment">#电影名称</span></span><br><span class="line">    name = item.find(<span class="string">&#x27;a &gt; h2&#x27;</span>).text()</span><br><span class="line">    <span class="comment">#file.write(f&#x27;名称：&#123;name&#125;\n&#x27;)</span></span><br><span class="line">    <span class="comment"># 类别</span></span><br><span class="line">    categories = [item.text() <span class="keyword">for</span> item <span class="keyword">in</span> item.find(<span class="string">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class="line">    <span class="comment">#file.write(f&#x27;类别：&#123;categories&#125;\n&#x27;)</span></span><br><span class="line">    <span class="comment"># 上映时间</span></span><br><span class="line">    published_at_text = item.find(<span class="string">&#x27;.info:contains(上映)&#x27;</span>).text()</span><br><span class="line">    published_at = re.search(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)&#x27;</span>,published_at_text).group(<span class="number">1</span>) \</span><br><span class="line">        <span class="keyword">if</span> published_at_text <span class="keyword">and</span> re.search(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)&#x27;</span>,published_at_text) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment">#file.write(f&#x27;上映时间：&#123;published_at&#125;\n&#x27;)</span></span><br><span class="line">    <span class="comment"># 评分</span></span><br><span class="line">    sorce =  item.find(<span class="string">&#x27;p.score&#x27;</span>).text()</span><br><span class="line">    <span class="comment">#file.write(f&#x27;评分：&#123;sorce&#125;\n&#x27;)</span></span><br><span class="line">    <span class="comment">#file.write(f&#x27;&#123;&quot;=&quot; * 50&#125;\n&#x27;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;movies_TXT.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br><span class="line">        file.write(<span class="string">f&#x27;类别：<span class="subst">&#123;categories&#125;</span>\n&#x27;</span>)</span><br><span class="line">        file.write(<span class="string">f&#x27;上映时间：<span class="subst">&#123;published_at&#125;</span>\n&#x27;</span>)</span><br><span class="line">        file.write(<span class="string">f&#x27;评分：<span class="subst">&#123;sorce&#125;</span>\n&#x27;</span>)</span><br><span class="line">        file.write(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;=&quot;</span> * <span class="number">50</span>&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="代码分析">代码分析</h4>
<p>这段代码使用了<code>requests</code>库发送HTTP请求，使用了<code>pyquery</code>库解析HTML文档。</p>
<p>它首先发送GET请求获取网页内容，然后使用<code>pyquery.PyQuery</code>将HTML文档加载到<code>doc</code>对象中。
接下来，它使用<code>.items()</code>方法选择所有带有<code>.el-card</code>类的元素，并以迭代方式处理每个元素。对于每个元素，它从<code>a &gt; h2</code>选择器中获取电影名称，并将其写入到<code>movies_TXT.txt</code>文件中。
类似地，它使用<code>'.categories button span'</code>选择器获取类别信息，并使用列表推导式将其写入文件。
剩下的代码依次获取上映时间和评分，并将这些信息写入文件中。</p>
<p>请确保已经安装了<code>requests</code>和<code>pyquery</code>库，并且可以在运行该脚本的环境中使用它们。此外，还要注意确保<code>movies_TXT.txt</code>文件所在的目录可写。</p>
<h4 id="a-h2-是什么意思">a &gt; h2 是什么意思？</h4>
<p><code>a &gt; h2</code>是CSS选择器的一种形式，用于选择HTML文档中<code>&lt;a&gt;</code>标签下的直接子元素<code>&lt;h2&gt;</code>。</p>
<p>在这个代码片段中，<code>item.find('a &gt; h2')</code>根据CSS选择器找到<code>item</code>元素下的第一个直接子元素是<code>&lt;a&gt;</code>标签，然后在该<code>&lt;a&gt;</code>标签的直接子元素中找到第一个<code>&lt;h2&gt;</code>标签。</p>
<p>换句话说，<code>item.find('a &gt; h2').text()</code>的作用是在<code>item</code>元素的子元素中查找第一个<code>&lt;a&gt;</code>标签，然后获取该<code>&lt;a&gt;</code>标签下的第一个<code>&lt;h2&gt;</code>标签的文本内容。</p>
<h3 id="文件的打开方式">文件的打开方式</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>'r'</code></td>
<td>读取模式（默认）。打开文件后，可以从文件中读取内容。如果文件不存在，抛出<code>FileNotFoundError</code>错误。</td>
</tr>
<tr class="even">
<td><code>'w'</code></td>
<td>写入模式。打开文件后，可以向文件中写入内容。如果文件存在，则清空文件内容；如果文件不存在，则创建新文件。</td>
</tr>
<tr class="odd">
<td><code>'a'</code></td>
<td>追加模式。打开文件后，可以在文件末尾追加内容。如果文件不存在，则创建新文件。</td>
</tr>
<tr class="even">
<td><code>'x'</code></td>
<td>创建模式。打开文件用于写入内容，如果文件已存在，则抛出<code>FileExistsError</code>错误。</td>
</tr>
<tr class="odd">
<td><code>'b'</code></td>
<td>二进制模式。用于处理二进制文件（如图片、音频文件等）。在这种模式下，文件内容被以字节的形式处理。</td>
</tr>
<tr class="even">
<td><code>'t'</code></td>
<td>文本模式（默认）。用于处理文本文件。在这种模式下，文件内容被以字符串的形式处理。</td>
</tr>
<tr class="odd">
<td><code>'+'</code></td>
<td>读写模式。打开文件后，既可以读取内容也可以写入内容。</td>
</tr>
</tbody>
</table>
<h3 id="with的使用">with的使用</h3>
<p>文件的写入还有一种<code>with as</code>的方法。<br />
当with模块结束时自动关闭文件，就不用每次都<code>.close()</code>方法了。<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;movies_TXT.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="string">f&#x27;类别：<span class="subst">&#123;categories&#125;</span>\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="string">f&#x27;上映时间：<span class="subst">&#123;published_at&#125;</span>\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="string">f&#x27;评分：<span class="subst">&#123;sorce&#125;</span>\n&#x27;</span>)</span><br><span class="line">    file.write(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;=&quot;</span> * <span class="number">50</span>&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意要使用<code>a</code>附加模式，否则每次都会覆盖上次读取的内容。</p>
<h2 id="json文件存储">JSON文件存储</h2>
<p><code>JSON</code>(JavaScript Object Notation),JavaScript
对象标记，通过对象和数组的组合来表示数据。</p>
<h3 id="对象和数组">对象和数组</h3>
<p>对象在JavaScript中是指花括号<code>&#123;&#125;</code>包围起来的内容，数据结构都是键对值结构，数组则是由<code>[]</code>包围起来的内容。</p>
<h3 id="读取json">读取JSON</h3>
<p>Python有简单易用的JSON库，<code>loads</code>方法将JSON文本转化为JSON对象，<code>dump()</code>方法将JSON对象转化为文本字符串。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;:&quot;Bob&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;:&quot;male&quot;,</span></span><br><span class="line"><span class="string">    &quot;birthday&quot;:&quot;1992-10-18&quot;</span></span><br><span class="line"><span class="string">&#125;,&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;:&quot;Selina&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;:&quot;female&quot;,</span></span><br><span class="line"><span class="string">    &quot;birthday&quot;:&quot;1995-10-18&quot;</span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>))</span><br><span class="line">data = json.loads(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">1</span>][<span class="string">&#x27;birthday&#x27;</span>])</span><br></pre></td></tr></table></figure> <strong>Result:</strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;gender&#x27;: &#x27;male&#x27;, &#x27;birthday&#x27;: &#x27;1992-10-18&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;Selina&#x27;, &#x27;gender&#x27;: &#x27;female&#x27;, &#x27;birthday&#x27;: &#x27;1995-10-18&#x27;&#125;]</span><br><span class="line">Bob</span><br><span class="line">1995-10-18</span><br></pre></td></tr></table></figure></p>
<p>注意：在JSON中数据都是由<code>双引号</code>包括的。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">str</span> = file.read()</span><br><span class="line">    data = json.loads(<span class="built_in">str</span>)</span><br><span class="line">    <span class="built_in">print</span>(data[<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 简写</span></span><br><span class="line">data = json.load(<span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">0</span>][<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bob</span><br></pre></td></tr></table></figure>
<h3 id="输出json">输出JSON</h3>
<p><code>dumps()</code>将JSON对象转化成字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = [&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;蒋锐&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;1992-10-18&quot;</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(json.dumps(data,indent=<span class="number">2</span>,ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>
<p><code>indent=2</code>缩进字符的个数，如果想要保存中文字符，使参数<code>ensure_ascii=False</code>即可。</p>
<h2 id="csv文件存储">CSV文件存储</h2>
<p><code>CSV</code>,<code>Comma-Separated Values</code>，即逗号分隔符，文件以纯文本的形式
存储存储<code>表格</code>数据。</p>
<h3 id="写入">写入</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10001&#x27;</span>,<span class="string">&#x27;Mike&#x27;</span>,<span class="number">20</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10002&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="number">22</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10003&#x27;</span>,<span class="string">&#x27;Selina&#x27;</span>,<span class="number">43</span>])</span><br><span class="line">    writer.writerows([[<span class="string">&#x27;10004&#x27;</span>,<span class="string">&#x27;Liu&#x27;</span>,<span class="number">33</span>],[<span class="string">&#x27;10005&#x27;</span>,<span class="string">&#x27;Jiang&#x27;</span>,<span class="number">25</span>],[<span class="string">&#x27;10006&#x27;</span>,<span class="string">&#x27;Xintong&#x27;</span>,<span class="number">19</span>]])<span class="comment">#多行写入</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id,name,age</span><br><span class="line"></span><br><span class="line">10001,Mike,20</span><br><span class="line"></span><br><span class="line">10002,Bob,22</span><br><span class="line"></span><br><span class="line">10003,Selina,43</span><br><span class="line"></span><br><span class="line">10004,Liu,33</span><br><span class="line"></span><br><span class="line">10005,Jiang,25</span><br><span class="line"></span><br><span class="line">10006,Xintong,19</span><br></pre></td></tr></table></figure>
<p>也可以使用pandas库来进行CSV的存储。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = [</span><br><span class="line">    &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;蒋欣彤&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10002&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;刘杰&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;,</span><br><span class="line">]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.to_csv(<span class="string">&#x27;pandas_csv.csv&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="读取">读取</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.reader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class="line">[&#x27;10001&#x27;, &#x27;蒋锐&#x27;, &#x27;20&#x27;]</span><br><span class="line">[&#x27;10002&#x27;, &#x27;刘杰&#x27;, &#x27;22&#x27;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>数据存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据模型【Python语言】</title>
    <url>/2023/07/14/Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E3%80%90Python%E8%AF%AD%E8%A8%80%E3%80%91/</url>
    <content><![CDATA[<h1 id="python数据模型">Python数据模型</h1>
<p>数据模型其实是对Python框架的描述，他规范了这们语言自身构造模块的接口，这些模块包括但不限于序列、迭代器、函数、类和上下文管理器。</p>
<p>Python解释器在碰到特殊的句法时，会使用<code>特殊方法</code>去激活一些基本的对象操作，这些方法都是以<code>__</code>双下划线开口和结尾的。</p>
<span id="more"></span>
<h2 id="用纸牌来引入">用纸牌来引入</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>,[<span class="string">'rank'</span>,<span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck</span>:</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = [<span class="string">'黑桃'</span>,<span class="string">'方片'</span>,<span class="string">'梅花'</span>,<span class="string">'红桃'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._cards = [Card(rank,suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                      <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,position</span>):</span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个这个程序中，首先引入了<code>collections库</code>。<br>
&gt;
Python中的collections库是一个内置库，提供了一些有用的数据结构，用于解决一些常见的编程问题。</p>
<p>之后用<code>collections.namedtuple()</code>创建了一个简单的类来表示纸牌。<br>
&gt;collections.namedtuple()是collections库中的一个函数，用于创建一个具有字段名的元组（可命名元组）类。
&gt;命名元组是一种类似于元组的数据结构，每个字段都有一个唯一的名称，并且可以像访问对象的属性一样访问它们。使用命名元组可以提高代码的可读性，并且比普通的元组更加方便。</p>
<p>实现特殊方法来利用Python数据模型有两个好处。<br>
- 不必记住标准操作的名称 -
更加方便的利用Python标准库，不必重新造轮子。</p>
<p><code>__getitem__()</code>方法直接调用list对象的<code>[]</code>操作符，所以deck类自动支持了切片操作，同时纸牌直接可以变成可迭代的了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">reversed</span>(deck):</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br></pre></td></tr></table></figure>
<p>同时查找操作也因为此也可以通过<code>in</code>运算符来实现。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Card(<span class="string">'1'</span>,<span class="string">'spades'</span>) <span class="keyword">in</span> deck)</span><br><span class="line"><span class="built_in">print</span>(Card(<span class="string">'2'</span>,<span class="string">'spades'</span>) <span class="keyword">in</span> deck)</span><br></pre></td></tr></table></figure>
<p>也可以指定排序规则来调用<code>sorted()</code>排序接口。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">suit_values = <span class="built_in">dict</span>(spades=<span class="number">3</span>, hearts=<span class="number">2</span>,diamonds=<span class="number">1</span>,cluds=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spades_high</span>(<span class="params">card</span>):</span><br><span class="line">        rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">        <span class="keyword">return</span> rank_value * <span class="built_in">len</span>(suit_values) + suit_values[card.suit]</span><br></pre></td></tr></table></figure>
<p>虽然FrenchDeck隐式地继承了object类，但是功能不是继承而来的，而是通过数据结构和一些合成来实现这些功能。</p>
<h2 id="重载python运算符">重载Python运算符</h2>
<p>在C++中，程序员可以在类中通过重载运算符来定义类的自定义运算。<br>
而在Python中，可以通过更简单的<code>特殊方法</code>来重载。</p>
<h3 id="vector类实例">Vector类实例</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x=<span class="number">0</span>,y=<span class="number">0</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Vector(<span class="subst">{self.x}</span>,<span class="subst">{self.y}</span>)'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> hypot(self.x,self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x,y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self,scalar</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar,self.y * scalar)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>math库中的hypot函数可以计算亮点之间的距离。</p>
<p><code>__repr__()</code>函数,特殊方法，用于定义类的字符串表达类型。</p>
<p><code>__abs__()</code>函数，用于外部直接调用<code>abs()</code>使用。</p>
<p><code>__add__()</code>和<code>__mul__()</code>的直接放回一个新的对象。</p>
<h3 id="自定义的bool值">自定义的bool值</h3>
<p>每个类都有属于自己的bool值，可以通过<code>__bool__()</code>特殊方法来设置。</p>
<h3 id="字符串的表达形式">字符串的表达形式</h3>
<p>Python中有两种自定义的字符串的特殊方法，一种是<code>__repr__()</code>方法，一种是<code>__str__()</code>方法。</p>
<p>他们之间的区别是，
<code>__str()__</code>方法是在<code>str()</code>中被使用，或者在<code>print()</code>函数中才被调用。</p>
]]></content>
      <categories>
        <category>Python高级编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>parsel的使用【爬虫】</title>
    <url>/2023/07/14/parsel%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="parsel库">parsel库</h1>
<p>parsel库结合了Xpath的写法和CSS选择器的写法。</p>
<span id="more"></span>
<h2 id="parsel简述">parsel简述</h2>
<p>parsel库可以解析HTML和XML,并且支持XPath和CSS选择器，同时还融合了正则表达式的提取功能。</p>
<p>parsel库同时也是最流行的爬虫框架Scrapy的底层支持。</p>
<h2 id="安装parsel库">安装parsel库</h2>
<p>再终端输入<code>pip install parsel</code>,下载parsel库。</p>
<h2 id="初始化parsel">初始化parsel</h2>
<p>引入parsel库中的Selector这个类声明Selector对象。<br>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line">selector = Selector(text=html)</span><br></pre></td></tr></table></figure></p>
<p>
<p>之后可以使用css和xpath的方法分别传入xpath和css选择器的内容提取。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">items = selector.css(<span class="string">'.item-0'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(items),<span class="built_in">type</span>(items),items)</span><br><span class="line">items2 = selector.xpath(<span class="string">'//li[contains(@class,"item-0")]'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(items),<span class="built_in">type</span>(items2),items)</span><br></pre></td></tr></table></figure>
<p><code>type()</code>显示css和xpath返回的对象都是<code>&lt;class 'parsel.selector.SelectorList'&gt;</code></p>
<h2 id="提取文本">提取文本</h2>
<p>提取的结果都是一个<code>SelectorList</code>,所以可以遍历操作。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div id="container"&gt;</span></span><br><span class="line"><span class="string">    &lt;ul class="list"&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">items = selector.css(<span class="string">'.item-0'</span>)</span><br><span class="line"><span class="string">"""xpath方法"""</span></span><br><span class="line"><span class="comment"># for item in items:</span></span><br><span class="line"><span class="comment">#     text = item.xpath('.//text()').get()</span></span><br><span class="line"><span class="comment">#     print(text)</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""css方法"""</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    text = item.css(<span class="string">'.item-0 *::text'</span>).getall()</span><br><span class="line">    <span class="built_in">print</span>(text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first item</span><br><span class="line">third item</span><br><span class="line">fifth item</span><br></pre></td></tr></table></figure>
<p><code>.get()</code>方法可以将SelectorList的Selector对象的内容提取出来。
<code>.getall()</code>方法可以依次获取Selector对象对应的结果。</p>
<p><code>.item-0 *::text</code>
里面的<code>*</code>是选取该节点下的所有子节点，<code>::text</code>提取文本。</p>
<h2 id="提取属性">提取属性</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div id="container"&gt;</span></span><br><span class="line"><span class="string">    &lt;ul class="list"&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0.active a::attr(href)'</span>).get()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result1 = selector.xpath(<span class="string">'//li[contains(@class,"item-0") and contains(@class,"active")]/a/@href'</span>).get()</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link3.html</span><br><span class="line">link3.html</span><br></pre></td></tr></table></figure>
<h2 id="正则提取">正则提取</h2>
<p>Select对象还提供正则表达式提取方法。<br>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div id="container"&gt;</span></span><br><span class="line"><span class="string">    &lt;ul class="list"&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result = selector.css(<span class="string">'.item-0.active a::attr(href)'</span>).get()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">result1 = selector.xpath(<span class="string">'//li[contains(@class,"item-0") and contains(@class,"active")]/a/@href'</span>).get()</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">result2 = selector.css(<span class="string">'.item-0'</span>).re(<span class="string">'(link3.html).*?'</span>)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br></pre></td></tr></table></figure></p>
<p><code>re_first()</code>来提取第一个符合规则的结果。</p>
</p>]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>数据解析</tag>
        <tag>parsel</tag>
      </tags>
  </entry>
  <entry>
    <title>pyquery的使用【爬虫】</title>
    <url>/2023/07/14/pyquery%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="pyquery的使用">pyquery的使用</h1>
<p>pyquery是CSS选择器的Python库，相较于Beautiful
Soup，puquery的CSS选择器更强大！</p>
<span id="more"></span>
<h2 id="使用pyquery的准备">使用pyquery的准备</h2>
<p>确保已经安装了pyquery库，使用pip安装<br />
<code>pip install pyquery</code></p>
<h2 id="pyquery初始化">pyquery初始化</h2>
<p>在用<code>pyquery库</code>解析<code>HTML文本</code>的时候，需要先将器初始化为一个<code>PyQuery对象</code>。</p>
<ul>
<li><p>字符串初始化
可以直接把HTML的内容当作初始化参数，来初始化PyQuery对象。<br />
Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>
<li><p>URL初始化 使用<code>url参数</code> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">&#x27;https://cuiqingcai.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>
<li><p>文件初始化 使用<code>filename参数</code>进行初始化。<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(filename=<span class="string">&#x27;demo.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;li&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="基本的css选择器">基本的CSS选择器</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;#container .list li&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(doc(<span class="string">&#x27;#container .list li&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">&#x27;#container .list li&#x27;</span>).items():</span><br><span class="line">    <span class="built_in">print</span>(item.text())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     </span><br><span class="line">&lt;class &#x27;pyquery.pyquery.PyQuery&#x27;&gt;</span><br><span class="line">first item</span><br><span class="line">second item</span><br><span class="line">third item</span><br><span class="line">fourth item</span><br><span class="line">fifth item</span><br></pre></td></tr></table></figure>
<p>在初始化PyQuery对象之后，传入一个CSS对象选择器<code>#container .list li</code>，意为先读取<code>id</code>为<code>container</code>的节点，再选取器其内部<code>class</code>为<code>list</code>的节点内部的所有的<code>li</code>节点.</p>
<p>遍历元素，带有text输出文本内容。</p>
<h2 id="查找节点">查找节点</h2>
<ul>
<li><p>子节点 <code>find()</code>方法,参数是CSS选择器。</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;ul class=&quot;list&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;first item&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1 active&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.list&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(items))</span><br><span class="line"><span class="built_in">print</span>(items)</span><br><span class="line">lis = items.find(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(lis))</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> &#x27;<span class="attr">pyquery.pyquery.PyQuery</span>&#x27;&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0 active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1 active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> &#x27;<span class="attr">pyquery.pyquery.PyQuery</span>&#x27;&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0 active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bold&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1 active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>find()其实是找到了所有的子孙节点。</p>
<p>只想查找子节点，用<code>children()</code>即可。
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lis = items.children(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(lis))</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br></pre></td></tr></table></figure></p></li>
<li><p>父节点 <code>parent()</code>即可。<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(<span class="string">&#x27;.list&#x27;</span>)</span><br><span class="line">container = items.parent()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(container))</span><br><span class="line"><span class="built_in">print</span>(container)</span><br></pre></td></tr></table></figure></p>
<p><code>parents()</code>方法可以寻找到所有的祖先节点。</p>
<p>如果想要筛选某个祖先节点,只要向里传入CSS选择器就可以了。<br />
</p></li>
<li><p>兄弟节点
先选择节点，之后用<code>siblings()</code>就可以得到获得所有的兄弟节点。<br />
向里面传入CSS选择器就可以筛选出想要的兄弟节点。</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">li = doc(<span class="string">&#x27;.list .item-0.active&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(li.siblings(<span class="string">&#x27;.active&#x27;</span>))</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="遍历节点">遍历节点</h2>
<p>pyquery库的选择结果可能是多个节点，也可能是单个节点。其类型都是<code>PyQuery</code>类型，返回的并不是列表。</p>
<p>如果是多个元素就只能遍历获取。</p>
<p>对获得的结果调用.items()方法，得到的类型是一个生成器。</p>
<p>遍历的话就可以逐个多的结果。</p>
<ul>
<li><p>获取属性
得到节点后用<code>attrs()</code>方法就可以获得其属性。</p></li>
<li><p>获得文本<br />
得到节点之后使用<code>text()</code>方法，就可以获得文本。</p></li>
</ul>
<p>如果想要获得html文件就使用html方法。</p>
<p>如果我们选中多个节点的话，<code>text()</code>和<code>html()</code>会返回什么？</p>
<p><code>html()</code>返回的是第一个节点的内容，<code>text()</code>返回的是节点内部的纯文本（字符串对象）</p>
<p>想要获取到全部的htnl，就要遍历items（生成器类型）。</p>
<h2 id="节点操作">节点操作</h2>
<p>有些时候，为某个节点添加或者删除一个节点会让我们提取信息的时候提高效率。</p>
<ul>
<li><p><code>addClass()</code> 和 <code>removeClass()</code>
先选中节点，再使用<code>addClass()</code> 和 <code>removeClass()</code>
传入想要操作的值。<br />
每次操作之后都会打印一遍操作之后的文本。</p></li>
<li><p><code>attr</code>、<code>text</code>和<code>html</code>
<code>attr</code>方法可以对属性进行操作
<code>attr('name','link')</code>第一个参数是要修改或者新增的属性，第二参数就是该属性的内容。<br />
<code>text</code>方法可以修改节点中文本的值。<br />
<code>html</code>方法可以修改节点内部的html值。
<code>text</code>和<code>html</code>只需要传值就可以了。</p></li>
<li><p><code>remove</code> html = '''</p>
<div class="wrap">
<pre><code>  Hello, World
  &lt;p&gt;This is a paragraph.&lt;/p&gt;</code></pre>
</div>
<p>''' from pyquery import PyQuery as pq doc = pq(html) wrap =
doc('.wrap') print(wrap.text()) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">现在想提取 Hello, World 这个字符串，而不要 p 节点内部的字符串，需要怎样操作呢？</span><br><span class="line"></span><br><span class="line">这里直接先尝试提取 class 为 wrap 的节点的内容，看看是不是我们想要的。运行结果如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">Hello, World This is a paragraph.</span><br></pre></td></tr></table></figure></p>
<p>这个结果还包含了内部的 p 节点的内容，也就是说 text
把所有的纯文本全提取出来了。如果我们想去掉 p
节点内部的文本，可以选择再把 p
节点内的文本提取一遍，然后从整个结果中移除这个子串，但这个做法明显比较烦琐。</p>
<p>这时 remove 方法就可以派上用场了，我们可以接着这么做:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wrap.find(<span class="string">&#x27;p&#x27;</span>).remove()</span><br><span class="line"><span class="built_in">print</span>(wrap.text())</span><br></pre></td></tr></table></figure></p>
<p>首先选中 p 节点，然后调用了 remove() 方法将其移除，然后这时 wrap
内部就只剩下 Hello, World 这句话了，然后再利用 text()
方法提取即可。</p></li>
</ul>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>pyquery</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器【爬虫】</title>
    <url>/2023/07/14/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="css选择器">CSS选择器</h1>
<p>CSS（层叠样式表）选择器是一种用于选择HTML（或XML）文档中的特定元素的模式。它们允许您根据元素的类型、属性、层级关系和其他条件来选择和样式化元素。</p>
<span id="more"></span>
<p>CSS选择器有多种类型，常见的包括：</p>
<ul>
<li><p>元素选择器：通过元素类型选择元素。例如，<code>p</code>选择器选择所有<code>&lt;p&gt;</code>段落元素。</p></li>
<li><p>类选择器：通过元素的class属性选择元素。类选择器以<code>.</code>符号开头，后面跟随类名。例如，<code>.highlight</code>选择所有具有<code>highlight</code>类的元素。</p></li>
<li><p>ID选择器：通过元素的id属性选择元素。ID选择器以<code>#</code>符号开头，后面跟随id名称。例如，<code>#logo</code>选择具有id为<code>logo</code>的元素。</p></li>
<li><p>属性选择器：通过元素的属性值选择元素。属性选择器可以选择具有特定属性、特定属性值或特定属性值模式的元素。例如，<code>[type="submit"]</code>选择所有<code>type</code>属性值为<code>submit</code>的元素。</p></li>
<li><p>后代选择器：选择某个元素下的所有后代元素。后代选择器使用空格分隔元素。例如，<code>div p</code>选择所有在<code>&lt;div&gt;</code>元素下的<code>&lt;p&gt;</code>元素。</p></li>
<li><p>子元素选择器：选择某个元素的直接子元素。子元素选择器使用<code>&gt;</code>符号分隔元素。例如，<code>ul &gt; li</code>选择所有<code>&lt;ul&gt;</code>列表下的直接子元素<code>&lt;li&gt;</code>。</p></li>
</ul>
<p>此外，还有伪类选择器（如<code>:hover</code>、<code>:first-child</code>）、伪元素选择器（如<code>::before</code>、<code>::after</code>）等。</p>
<p>CSS选择器的组合和嵌套使用可以更精确地选择和样式化特定的元素，使您能够以灵活和精细的方式控制文档的样式。</p>
<h2 id="简单理解">简单理解</h2>
<p>CSS选择器简单来说就是选择HTML元素的工具。<br>
为了准确的选择元素，就要使用到CSS选择器。</p>
<p>有以下6个类别：</p>
<ul>
<li><p>ID选择器：<br>
给元素颁发<code>id</code>,给予其唯一标识。<br>
一般适用与单个元素。<br>
</p></li>
<li><p>标签选择器： 直接给相同类别的元素打上标签。<br>
适用与多个相同的元素。<br>
</p></li>
<li><p>类选择器 给元素标注上<code>别名</code>。 适用于大量的数据。<br>
</p></li>
<li><p>伪类选择器 伪类选择器不可随便起名。<br>
一般翻译不可被轻松可靠检测到的元素或者状态，进行选择是用<code>:</code>标注即可。</p></li>
<li><p>属性选择器 用<code>[]</code>包裹。</p></li>
<li><p>结构选择器 根据树结构进行选择。</p></li>
</ul>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Beautiful_Soup的使用【爬虫】</title>
    <url>/2023/07/14/Beautiful-Soup%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="beatiful-soup">Beatiful Soup</h1>
<p><code>Beautiful Soup</code>是一个强大的解析工具，凭借<strong>网页的结构和属性等特性</strong>来解析网页。</p>
<span id="more"></span>
<h2 id="beatiful-soup概述">Beatiful Soup概述</h2>
<p>Beatiful Soup 是 Python
中的一个用来解析HTML和XML的一个解析库，利用它可以省去编辑正则表达式的时间，提升效率。</p>
<h2 id="依赖于解析器">依赖于解析器</h2>
<p>Beatiful Soup
解析是依赖解析器的，不仅支持Python官方的解释器，还支持一些第三方的解释器。</p>
<p>一般使用LXML的解析器，<code>速度快</code>，<code>容错高</code>。</p>
<p>LXML解析器的使用方法： <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">BeautifulSoup(makeup,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">BeautifulSoup(makeup,<span class="string">&#x27;xml&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="使用beautifulsoup的准备">使用BeautifulSoup的准备</h2>
<p>确保已经安装了好了<code>Beautiful Soup</code>和<code>lxml</code>这两个库。</p>
<p><code>pip install Beautifulsoup4</code></p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br><span class="line"><span class="built_in">print</span>(soup.title.string)</span><br></pre></td></tr></table></figure></p>
<code>Beautifulsoup()</code>传入两个参数，第一个参数是待解析的html字符串对象<font color = blue size = 2>注意到html文章其实并不是一个完整的html格式，
<body>
<p>节点并没有闭合</font>，第二个参数是解释器的类型。</p>
<p>将解析完的对象赋予soup，其实这时soup之中存储的是完整的html格式了，因为Beatifulsoup会自动补全格式。</p>
<p><code>prettify()</code>将html格式的文件进行标准格式的缩进输出。</p>
<p><code>soup.title.string</code>是输出html文件中的title节点的内容。</p>
<p>通过几个属性就能快速的获取节点中的内容，效率相较于正则表达式明显提升。</p>
<h2 id="beautifulsoup节点选择器">Beautifulsoup节点选择器</h2>
<p>就像在上个例子中，直接选择节点的名称之后调用<code>string</code>方法就可以直接得到节点的值。</p>
<p>在单个节点的结构十分清晰时，这种方法时第一选择。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种方式有个缺点，再有很多的相同节点时，只会选择第一个节点的内容。</p>
<p><a id="bs4.element.tag"></a>
<code>bs4.element.tag</code>是Beautifulsoup中的一个比较重要的数据结构，经过选择器选择的结构都是这种Tag类型。</p>
<h2 id="如何提取节点的信息">如何提取节点的信息</h2>
<ul>
<li><p>获取名称 使用<code>name</code>属性，可以获取节点的名称。<br />
</p></li>
<li><p>获取属性
一个节点可能有多个属性，先选择到这个节点，调用attrs获取其所有属性，之后用<code>[]</code>现在可以获取到所选属性的值。
<strong>Code:</strong><br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.p.attrs)</span><br><span class="line"><span class="built_in">print</span>(soup.p.attrs[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">```  </span><br><span class="line">**Result:**</span><br></pre></td></tr></table></figure> {'class': ['title'], 'name': 'dromouse'} dromouse
```</p></li>
<li><p>获取内容 就是<code>.string</code>方法。</p></li>
<li><p>嵌套选择 已知所有的返回结构都是<a
href="#bs4.element.tag">bs4.element.Tag</a>类型,所以Tag对象可以进行选择，可以调用其内部的节点。</p></li>
</ul>
<h2 id="关联选择">关联选择</h2>
<p>有时不能直接就选到想要的节点，这时就可以通过先选择一个节点，在选择它的子节点、父节点、兄弟节点。</p>
<ul>
<li><p>子节点和子孙节点
<code>contents</code>属性可以获得节点的直接子节点，放回直接子节点的列表。<br />
<code>children</code>属性也可以得到相应的结果，但是返回的是<font color = blue size = 1><待完善></font>生成器类型。<br />
<code>descendants</code>属性可以得到所有的子孙节点。
放回生成器类型。</p></li>
<li><p>父节点和祖先节点
<code>parent</code>属性可以获得节点的父节点。<br />
<code>parents</code>属性可以获得全部的祖先节点。<br />
返回值都是生成器类型。</p></li>
<li><p>兄弟节点 <code>next_sibing</code>属性返回该节点的下一个兄弟节点。
<code>previous_sibing</code>属性返回该节点的上一个兄弟节点。<br />
<code>next_sibings</code>属性返回该节点的后面所有兄弟节点。
<code>previous_sibings</code>属性返回该节点的前面所有兄弟节点。</p></li>
</ul>
<h2 id="提取信息">提取信息</h2>
<p>Tag类型直接调用string,attrs属性，生成器类型先转换成列表，再用<code>[]</code>进行选择。</p>
<h2 id="方法选择器">方法选择器</h2>
<ul>
<li>find_all()
<code>find_all(name ,attrs ,recursive, text, **kwargs)</code>
<ul>
<li>name
根据<code>name参数</code>查询元素。返回列表类型，每个元素都是<code>Tag</code>类型,用<code>[]</code>指定元素。<br />
</li>
<li>attrs 根据<code>attrs参数</code>节点名，传入一些属性进行查询。<br />
<code>attrs=&#123;'id':'list-1'&#125;</code></li>
<li>text <code>text参数</code>查询节点的文本。</li>
</ul></li>
<li>find() <code>find()</code>方法返回第一个匹配的节点。</li>
</ul>
<h2 id="css选择器待学习">CSS选择器（待学习）</h2>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Beautiful Soup</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath的使用【爬虫】</title>
    <url>/2023/07/14/XPath%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="xpath的使用">XPath的使用</h1>
<p><code>XPath</code>的全称是XML Path
Language,即XML路径语言，用来在XML文档中查找信息，同样也可以适用于HTML文档的搜索。</p>
<h2 id="xpath概述">XPath概述</h2>
<p>XPath的选择功能十分强大，它提供了非常简洁明了的<code>路径选择表达式</code>,几乎所有的我们想要定位的节点，都可以用XPath来选择。</p>
<span id="more"></span>
<h2 id="xpath的常见规则">XPath的常见规则</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">表达式</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><code>nodename</code></td>
<td style="text-align: left;">选取此节点的所有子节点</td>
</tr>
<tr class="even">
<td style="text-align: right;"><code>/</code></td>
<td style="text-align: left;">从当前节点选取直接子节点</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><code>//</code></td>
<td style="text-align: left;">从当前节点选取子孙节点</td>
</tr>
<tr class="even">
<td style="text-align: right;"><code>.</code></td>
<td style="text-align: left;">选取当前节点</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><code>..</code></td>
<td style="text-align: left;">选取当前节点的父节点</td>
</tr>
<tr class="even">
<td style="text-align: right;"><code>@</code></td>
<td style="text-align: left;">选取属性</td>
</tr>
</tbody>
</table>
<p>Example:<br />
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//title[@lang=&#x27;eng&#x27;]</span><br></pre></td></tr></table></figure></p>
<p>以上示例代表:<strong>选取所有名称为<code>title</code>，同时属性<code>lang</code>为<code>eng</code>的节点</strong>。</p>
<h2 id="安装lxml库">安装lxml库</h2>
<p>在终端使用pip安装lxml库。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure></p>
<h2 id="简单实例">简单实例</h2>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line"><span class="built_in">print</span>(result.decode(<span class="string">&#x27;UTF-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用参数让etree.HTML()方法不补全代码  </span></span><br><span class="line"><span class="comment"># html = etree.HTML(text,etree.HTMLParser())</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link1.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link2.html&quot;</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-inactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link3.html&quot;</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link4.html&quot;</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item-0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link5.html&quot;</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
使用lxml库中的etree模块，在实例中html的文本是缺失的，可以注意到最后以
<li>
节点的没有闭合，但是etree模块是可以自动修正文本的，所以在结果中
<li>
<p>节点自动修正复原了。</p>
<p>经过<code>etree.HTML()</code>方法自动修复的html代码，之后调用调用<code>tostring()</code>方法输出修复后的代码，但是此时的代码是<code>bytes</code>形式的，之后用<code>decode('utf-8')</code>方法还原成str类型。</p>
<h2 id="所有节点">所有节点？</h2>
<p>一般使用以<code>//</code>开头的XPath规则来选所有符合要求的节点。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//*&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure> <strong>Result：</strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;Element html at 0x26d86380bc0&gt;, &lt;Element body at 0x26d86914b80&gt;, &lt;Element div at 0x26d869147c0&gt;, &lt;Element ul at 0x26d86914900&gt;, &lt;Element li at 0x26d86914800&gt;, &lt;Element a at 0x26d86914a80&gt;, &lt;Element li at 0x26d869148c0&gt;, &lt;Element a at 0x26d86914c00&gt;, &lt;Element li at 0x26d86914c40&gt;, &lt;Element a at 0x26d86914ac0&gt;, &lt;Element li at 0x26d86914c80&gt;, &lt;Element a at 0x26d86914cc0&gt;, &lt;Element li at 0x26d86914d00&gt;, &lt;Element a at 0x26d86914d40&gt;]</span><br></pre></td></tr></table></figure></p>
<p>注意到result是一个<code>list</code>，元素的类型都是<code>Element</code>,后面跟着节点的类型<code>html</code>、<code>ul</code>之类的。</p>
<h2 id="子节点">子节点？</h2>
<p>使用<code>/</code>、<code>//</code>即可查找元素的子节点或者子孙节点。</p>
<p>试着获取以下<code>li节点</code>下的<code>a节点</code>。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;Element a at 0x269122c4c40&gt;, &lt;Element a at 0x269122c4880&gt;, &lt;Element a at 0x269122c49c0&gt;, &lt;Element a at 0x269122c48c0&gt;, &lt;Element a at 0x269122c4b80&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>/</code>只能获取节点的直接子节点，想要获取子孙节点的时候就必须要使用<code>//</code>来获取。</p>
<h2 id="父节点">父节点？</h2>
<p>知道了子节点符合获取父节点呢？</p>
<p>用<code>..</code>可以实现该功能。</p>
<p>例如获取<code>href属性</code>为<code>link4.html</code>的<code>a节点</code>，尝试获取其父节点。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//a[@href=&quot;link4.html&quot;]/../@class&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;item-1&#x27;]</span><br></pre></td></tr></table></figure></p>
<p><code>'//a[@href="link4.html"]/../@class'</code>的意思是：首先选中<code>href属性</code>为<code>link4.html</code>的节点，然后获取其节点，再获取<code>父节点中class属性的值</code>。</p>
<h2 id="属性匹配">属性匹配？</h2>
<p>再选取节点时，用<code>@</code>来过滤属性。</p>
<p>试着选取<code>class属性</code>为<code>item-0</code>的<code>li节点</code>。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[@class=&quot;item-0&quot;]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;Element li at 0x1b39b294840&gt;, &lt;Element li at 0x1b39b294980&gt;]</span><br></pre></td></tr></table></figure></p>
<h2 id="文本获取">文本获取？</h2>
<p>XPath中<code>text()方法</code>可以获取节点中的文本。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[@class=&quot;item-0&quot;]/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;\r\n     &#x27;]</span><br></pre></td></tr></table></figure></p>
<p>这不是节点中的值啊，为什么会读取到这个呢？</p>
<p>因为在<code>text()方法</code>前面选取了<code>/</code>，所以我们选取的节点实际上时<code>li节点</code>而并非是<code>a节点</code>，而文本时在a节点里面的。</p>
<p>一般是这样写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="string">&quot;&quot;&quot;1. 具体的选取到节点&quot;&quot;&quot;</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[@class=&quot;item-0&quot;]/a/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;2. 选取到全部的子孙节点&quot;&quot;&quot;</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[@class=&quot;item-0&quot;]//text()&#x27;</span>) <span class="comment">#会包含a节点的内容</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;first item&#x27;, &#x27;fifth item&#x27;]</span><br><span class="line"></span><br><span class="line">[&#x27;first item&#x27;, &#x27;fifth item&#x27;, &#x27;\r\n     &#x27;] </span><br></pre></td></tr></table></figure></p>
<h2 id="属性获取">属性获取？</h2>
<p><code>@</code>依旧可以获取属性的值。</p>
<p><strong>Code：</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.parse(<span class="string">&#x27;./text.html&#x27;</span>,etree.HTMLParser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li/a/@href&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p><strong>Rusult:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;link1.html&#x27;, &#x27;link2.html&#x27;, &#x27;link3.html&#x27;, &#x27;link4.html&#x27;, &#x27;link5.html&#x27;]</span><br></pre></td></tr></table></figure></p>
<p>可以看到获取了全部的<code>li节点</code>下<code>a节点</code>中<code>href属性</code>的值。</p>
<h2 id="属性多值获取">属性多值获取？</h2>
<p>上面的方法值只适用于只有一个属性的情况。</p>
<p>那如果多个属性怎么办呢？</p>
<p>这就要使用到<code>contains()方法</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot; name=&quot;item1&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot; name=&quot;item2&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[contains(@class,&quot;li&quot;)]/a/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;first item&#x27;, &#x27;first item&#x27;]</span><br></pre></td></tr></table></figure></p>
<p><code>contains()方法</code>的第一个参数是要匹配的属性，第二个参数是属性包含的值，之后就好检索所有待查找属性中包含查找值的节点并获取其中的值。</p>
<h2 id="多属性匹配">多属性匹配？</h2>
<p>依旧是使用<code>contains()方法</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot; name=&quot;item1&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;li li-first&quot; name=&quot;item2&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[contains(@class,&quot;li&quot;) and @name=&quot;item1&quot;] /a/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;first item&#x27;]</span><br></pre></td></tr></table></figure></p>
<p>使用<code>and</code>连接的两个属性即可。</p>
<h2 id="按序选择">按序选择？</h2>
<p>但匹配到多个节点时，用<code>[]</code>
和<code>position()</code>来进行选择或者切片。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;body&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;second item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-inactive&quot;&gt;&lt;a href=&quot;link3.html&quot;&gt;third item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link4.html&quot;&gt;fourth item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">         &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;fifth item&lt;/a&gt;</span></span><br><span class="line"><span class="string">     &lt;/li&gt;&lt;/ul&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result1 = html.xpath(<span class="string">&#x27;//li[1]/a/text()&#x27;</span>)</span><br><span class="line">result2 = html.xpath(<span class="string">&#x27;//li[position()&lt;3]/a/text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br></pre></td></tr></table></figure></p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;first item&#x27;]</span><br><span class="line">[&#x27;first item&#x27;, &#x27;second item&#x27;]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>基础爬虫实战【爬虫】</title>
    <url>/2023/07/12/%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="基础爬虫实战-抓取静态网页的信息">基础爬虫实战：
抓取静态网页的信息</h1>
<p>实现一个爬虫来爬取一个静态网页的信息。</p>
<p>完整代码请参见本文末尾,或<a
href="https://helloxiunneg.com.cn/2023/07/12/%E5%9F%BA%E7%A1%80%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/#Allcode">点击此处</a>，或者进入<a
href="https://github.com/Lxiunneg/My_Python_Spider_Study/tree/main/%E5%AE%9E%E6%88%981_%E7%88%AC%E5%8F%96%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5">GitHub自取</a></p>
<span id="more"></span>
<h2 id="项目概述">项目概述</h2>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>Python3.6及以上,并且环境配置完全。<br />
</li>
<li><font color = blue size = 0.1><待完善></font>了解Python多进程的基本原理</li>
<li>了解PythonHTTP请求库requests的基本用法。</li>
<li>了解正则表达式的用法和Python中正则表达式re的基本用法。 ### 爬取目标
需要爬取的<a
href="https://ssr1.scrape.center/">链接</a>是：<code>https://ssr1.scrape.center/</code>,这个网站包含了一些电影信息。</li>
</ul>
<p><img
src="https://img.nickyam.com/file/4e96a6a56db12c4d4be10.png" /></p>
<p>我们点击其中一部电影就可以看到详细的信息。</p>
<h3 id="要完成的目标">要完成的目标</h3>
<ul>
<li>利用requests库爬取这个站点每一页的电影列表，顺着列表在爬取每个电影的详情页。<br />
</li>
<li>用正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等内容。</li>
<li>把以上爬取的内容保存为JSON文件。<br />
</li>
<li>使用多进程实现爬取的加速。</li>
</ul>
<h2 id="开始爬取">开始爬取</h2>
<h3 id="爬取列表页">爬取列表页</h3>
<h4 id="第一步-分析页面">第一步： 分析页面</h4>
<p>要想爬取一个网站我们就要了解要爬取网站的构成。<br />
使用开发者工具查看页面。</p>
<p><img
src="https://img.nickyam.com/file/6d92dae364f61199598cf.png" /></p>
<p>发现每部电影对应的是一个<code>div</code>节点，而且这些节点的<code>class</code>属性都有<code>el-card</code>这个值。</p>
<p><img
src="https://img.nickyam.com/file/e5555cb409975b6102763.png" /></p>
<p>注意到每个列表有十个<code>div</code>节点，说明一页有十部电影。</p>
<p>选中第一个电影的名称，可以发现这个名称其实是一个<code>h2</code>节点<font color = blue size = 1>（其实就是这个节点中的二级标题）</font>，在h2节点的外面包含一个<code>a</code>节点，a节点有一个<code>href</code>属性,这是一个超链接，其中的<code>href</code>的值为：<code>/detail/1</code>，这是一个相对于网站的根URL的地址，可以还原成：<code>https://ssr1.scrape.center/detail/1</code>,这就是详情页的URL。所以得出结论：<strong>只要获取到了<code>href</code>属性的值，我们就可以获取到电影的详情页URL。</strong>，之后我们就可以在详情页中进行爬取信息了。</p>
<h4 id="第二步-分析翻页的操作逻辑">第二步： 分析翻页的操作逻辑</h4>
<p>进行翻页时，我们可以观察到网站的URL从<code>https://ssr1.scrape.center/page/1</code>转换成了<code>https://ssr1.scrape.center/page/2</code>,这就是翻页的逻辑，我们也顺利的得到了各页的URL。</p>
<h4 id="代码实现">代码实现</h4>
<p>完成对列表页的爬取的实现，步骤是： -
遍历所有页码，构造出10页的索引页URL。 -
从每个索引页中分析提取出每个电影的详情页URL。</p>
<p><strong>Code：</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########part_1###########</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line"><span class="comment">###########part_2###########</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname) : %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://ssr1.scrape.center&#x27;</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>在<font color = green>part_1</font>中，我们引入了<code>requests库</code>来进行网页的抓取、<code>logging库</code>来输出信息、<code>re库</code>来实现正则表达式对页面信息的匹配和<code>urllib.parse.urljoin()方法</code>来做对URL的拼接。</p>
<p>在<font color = green>part_2</font>中，首先是使用<code>logging.basicConfig()方法</code>定义日志输出级别和输出格式，<code>BASE_PAGE</code>为当前爬取站点的根URL，<code>TOTAL_PAGE</code>设定了需要爬取页面的总数.</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########part_3###########</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_page</span>(<span class="params">url</span>):</span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s...&#x27;</span>,url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while scraping %s&#x27;</span></span><br><span class="line">                      ,response.status_code,url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occured while scraping %s&#x27;</span>,url,exc_info=<span class="literal">True</span>)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_index</span>(<span class="params">page</span>):</span><br><span class="line">    index_url = <span class="string">f&#x27;<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> scrape_page(index_url)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_index</span>(<span class="params">html</span>):</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?class=&quot;name&quot;&gt;&#x27;</span>)</span><br><span class="line">    items = re.findall(pattern,html)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL,item)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail url %s&#x27;</span>,detail_url)</span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        logging.info(<span class="string">&#x27;detail urls %s&#x27;</span>,<span class="built_in">list</span>(detail_urls))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>这是一个较为通用的爬取页面方法,<code>sreape_page</code>,接受一个<code>url</code>参数，返回页面的HTML代码。如果状态码是不是<code>200</code>，如果是直接返回页面的HTML代码，如果不是,则输出对应的错误日志信息。</p>
<p><code>scrape_index(page)</code>方法就是列表页的爬取方法，按照翻页的逻辑，实现URL的拼接。</p>
<p><code>parse_index(html)</code>方法接受一个参数html，级列表页的HTML的代码。<br />
<code>pattern参数</code>指明了正则表达式的匹配模式，即提取<code>a节点</code>中<code>参数href</code>的值，然后通过<code>yield</code>逐个返回详情页的URL。</p>
<p>最后将上述的函数组合就可以爬取到详情页了。</p>
<p><strong>Result:</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-07-12 21:18:00,427 - INFO : scraping https://ssr1.scrape.center/page/1...</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/1</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/2</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/3</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/4</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/5</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/6</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/7</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/8</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/9</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : get detail url https://ssr1.scrape.center/detail/10</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : detail urls [&#x27;https://ssr1.scrape.center/detail/1&#x27;, &#x27;https://ssr1.scrape.center/detail/2&#x27;, &#x27;https://ssr1.scrape.center/detail/3&#x27;, &#x27;https://ssr1.scrape.center/detail/4&#x27;, &#x27;https://ssr1.scrape.center/detail/5&#x27;, &#x27;https://ssr1.scrape.center/detail/6&#x27;, &#x27;https://ssr1.scrape.center/detail/7&#x27;, &#x27;https://ssr1.scrape.center/detail/8&#x27;, &#x27;https://ssr1.scrape.center/detail/9&#x27;, &#x27;https://ssr1.scrape.center/detail/10&#x27;]</span><br><span class="line">2023-07-12 21:18:00,593 - INFO : scraping https://ssr1.scrape.center/page/2...</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>详情页爬取成功了。</p>
<h3 id="爬取详情页">爬取详情页</h3>
<h4 id="第一步-分析页面-1">第一步： 分析页面</h4>
<p>通过开发者工具分析发现以下特征：<br />
- 封面：
<code>img节点</code>,<code>class</code>属性为<code>cover</code>,<code>src属性</code>为封面图片的URL。
- 名称： <code>h2节点</code>，其内容是电影名称。<br />
- 类别：
<code>span节点</code>,其内容是电影的名称。其外层是<code>button节点</code>，再外层是<code>div节点</code>，其<code>class属性</code>是<code>categories</code>。<br />
- 上映时间：
<code>span节点</code>，其内容是上映的时间+“上映”，提取时注意去掉“上映”两字。外层是<code>div节点</code>,其<code>class属性</code>是<code>m-v-sm info</code>,正则匹配时匹配<code>info</code>。
- 评分：
<code>p节点</code>,其内容是评分，<code>class属性</code>为<code>score</code>。
- 剧情简介：
<code>p节点</code>,其内容是剧情简介。其外层是<code>h3节点</code>,其内容是“剧情简介”。再外层是属性为<code>drama</code>的<code>div节点</code>。</p>
<h4 id="代码实现-1">代码实现</h4>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########part_4###########</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> scrape_page(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>(<span class="params">html</span>):</span><br><span class="line">    cover_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;item.*?&lt;img.*?src=&quot;(.*?)&quot;.*?class=&quot;cover&quot;&gt;&#x27;</span>,re.S)</span><br><span class="line">    name_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>)</span><br><span class="line">    categories_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;button.*?category.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/button&gt;&#x27;</span>,re.S)</span><br><span class="line">    published_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)\s?上映&#x27;</span>)</span><br><span class="line">    drama_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;div.*?drama.*?&gt;.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>,re.S)</span><br><span class="line">    score_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;p.*?score.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>,re.S)</span><br><span class="line"></span><br><span class="line">    cover = re.search(cover_pattern,html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(cover_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    name = re.search(name_pattern,html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(name_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    categories = re.findall(categories_pattern,html) <span class="keyword">if</span> re.findall(categories_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    published_at = re.search(published_at_pattern,html).group(<span class="number">1</span>) <span class="keyword">if</span> re.search(published_at_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama_at = re.search(drama_at_pattern,html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(drama_at_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    score = <span class="built_in">float</span>(re.search(score_pattern,html).group(<span class="number">1</span>).strip())<span class="keyword">if</span> re.search(score_pattern,html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;published_at&#x27;</span>: published_at,</span><br><span class="line">        <span class="string">&#x27;drmar_at&#x27;</span>: drama_at,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>定义<code>函数scrape_detail()</code>,该方法返回详情页的html代码。单独实现<code>函数scrape_detail()</code>,可以增强程序的灵活性和易读性。</p>
<p>定义<code>函数parse_detail(html)</code>，对html代码进行匹配，最后返回一个字典对象。</p>
<h4 id="将数据保存">将数据保存</h4>
<p>这里采用JSON格式来保存数据，编写以下保存函数以及初始设置。</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data,<span class="built_in">open</span>(data_path,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>),ensure_ascii=<span class="literal">False</span>,indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="运行爬虫">运行爬虫</h4>
<p>改写<code>main()</code>： <strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,TOTAL_PAGE+<span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">            detail_html = scrape_detail(detail_url)</span><br><span class="line">            data = parse_detail(detail_html)</span><br><span class="line">            logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>,data)</span><br><span class="line">            logging.info(<span class="string">&#x27;saving data to json file...&#x27;</span>)</span><br><span class="line">            save_data(data)</span><br><span class="line">            logging.info(<span class="string">&#x27;data saved successfully!^-^&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>运行结果： <img
src="https://img.nickyam.com/file/f35eb631487ff39e9e4da.png" /> <img
src="https://img.nickyam.com/file/140053265bfaaac8b4f83.png" /></p>
<h2 id="多线程加速">多线程加速</h2>
<p><font color = blue size = 1><待完善></font>将十页的爬取同时进行，为每一页开一个进程来爬取。而且因为这10个列表页面正好可以提前构造成一个列表，所以选用多进程里面的进程池Pool来实现这个过程。</p>
<p>改写<code>main()</code>：</p>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">page</span>):</span><br><span class="line">    index_html = scrape_index(page)</span><br><span class="line">    detail_urls = parse_index(index_html)</span><br><span class="line">    <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">        detail_html = scrape_detail(detail_url)</span><br><span class="line">        data = parse_detail(detail_html)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, data)</span><br><span class="line">        logging.info(<span class="string">&#x27;saving data to json file...&#x27;</span>)</span><br><span class="line">        save_data(data)</span><br><span class="line">        logging.info(<span class="string">&#x27;data saved successfully!^-^&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该代码还需学习</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure></p>
<p><a id="Allcode"></a></p>
<h2 id="完整代码">完整代码</h2>
<p><strong>Code:</strong> <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########part_1###########</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment">###########part_2###########</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://ssr1.scrape.center&#x27;</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###########part_3###########</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_page</span>(<span class="params">url</span>):</span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s...&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while scraping %s&#x27;</span></span><br><span class="line">                      , response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occured while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_index</span>(<span class="params">page</span>):</span><br><span class="line">    index_url = <span class="string">f&#x27;<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> scrape_page(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_index</span>(<span class="params">html</span>):</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?class=&quot;name&quot;&gt;&#x27;</span>)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL, item)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail url %s&#x27;</span>, detail_url)</span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###########part_4###########</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scrape_detail</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> scrape_page(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>(<span class="params">html</span>):</span><br><span class="line">    cover_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;item.*?&lt;img.*?src=&quot;(.*?)&quot;.*?class=&quot;cover&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line">    name_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>)</span><br><span class="line">    categories_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;button.*?category.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/button&gt;&#x27;</span>, re.S)</span><br><span class="line">    published_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)\s?上映&#x27;</span>)</span><br><span class="line">    drama_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;div.*?drama.*?&gt;.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line">    score_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;p.*?score.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line">    cover = re.search(cover_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(cover_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    name = re.search(name_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(name_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    categories = re.findall(categories_pattern, html) <span class="keyword">if</span> re.findall(categories_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    published_at = re.search(published_at_pattern, html).group(<span class="number">1</span>) <span class="keyword">if</span> re.search(published_at_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama_at = re.search(drama_at_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(drama_at_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    score = <span class="built_in">float</span>(re.search(score_pattern, html).group(<span class="number">1</span>).strip()) <span class="keyword">if</span> re.search(score_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;published_at&#x27;</span>: published_at,</span><br><span class="line">        <span class="string">&#x27;drmar_at&#x27;</span>: drama_at,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">data</span>):</span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">page</span>):</span><br><span class="line">    index_html = scrape_index(page)</span><br><span class="line">    detail_urls = parse_index(index_html)</span><br><span class="line">    <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">        detail_html = scrape_detail(detail_url)</span><br><span class="line">        data = parse_detail(detail_html)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, data)</span><br><span class="line">        logging.info(<span class="string">&#x27;saving data to json file...&#x27;</span>)</span><br><span class="line">        save_data(data)</span><br><span class="line">        logging.info(<span class="string">&#x27;data saved successfully!^-^&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该代码还需学习</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫实战案例</category>
      </categories>
      <tags>
        <tag>爬虫实战</tag>
      </tags>
  </entry>
  <entry>
    <title>httpx的使用【爬虫】</title>
    <url>/2023/07/12/httpx%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="httpx">httpx</h1>
<h2 id="httpx概述">httpx概述</h2>
<p>urlib库和requests库以及可以爬取绝大多数网站的数据，但是由于它们只支持<code>HTTP/1.1</code>协议，对于某些强制使用<code>HTTP/2.0</code>协议的网站会被拒绝访问，这时就要使用支持<code>HTPP/2.0</code>的库来进行访问。<br />
<code>httpx库</code>就能达到这个目的，它可以达到几乎<code>requests库</code>的所有要求。</p>
<span id="more"></span>
<h2 id="简单实例">简单实例</h2>
<p>已知：<code>https://spa16.scrape.center/</code>是一个强制使用h2协议的网站。<br />
先试下用requests库来进行爬取试下。</p>
<p>Example: <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://spa16.scrape.center/&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>Reusult:<br />
<font color = red >Error: urllib3.exceptions.ProtocolError: ('Connection
aborted.', RemoteDisconnected('Remote end closed connection without
response'))</font></p>
<p>可见requests库无法请求到该url，并且提示ProtocalError。</p>
<h2 id="安装httpx库">安装httpx库</h2>
<p>安装要求：<br />
- Python3.6及以上。 - pip3工具</p>
<p>在cmd中执行以下语句：<br />
<code>pip install httpx</code></p>
<figure>
<img src="https://img.nickyam.com/file/fc4df6d3d6267ea9a90e9.png"
alt="pip安装httpx" />
<figcaption aria-hidden="true">pip安装httpx</figcaption>
</figure>
<h2 id="httpx库的基本使用">httpx库的基本使用</h2>
<p>httpx库的API与reuqests库有很多的相似之处。</p>
<h3 id="基本实例">基本实例</h3>
<p>Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla 5, Windows NT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = httpx.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br><span class="line"><span class="built_in">print</span>(r.headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>Reusult: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200</span><br><span class="line">Headers(&#123;&#x27;date&#x27;: &#x27;Wed, 12 Jul 2023 06:47:04 GMT&#x27;, &#x27;content-type&#x27;: &#x27;application/json&#x27;, &#x27;content-length&#x27;: &#x27;315&#x27;, &#x27;connection&#x27;: &#x27;keep-alive&#x27;, &#x27;server&#x27;: &#x27;gunicorn/19.9.0&#x27;, &#x27;access-control-allow-origin&#x27;: &#x27;*&#x27;, &#x27;access-control-allow-credentials&#x27;: &#x27;true&#x27;&#125;)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;*/*&quot;, </span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;www.httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla 5, Windows NT&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-64ae4c66-2b68b708075421c6005262f0&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;110.52.208.183&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;https://www.httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="请求h2协议网站">请求H2协议网站</h3>
<p>我们再次请求强制使用<code>HTTP/2.0</code>的网站试下。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://spa16.scrape.center/&#x27;</span></span><br><span class="line"></span><br><span class="line">r = httpx.get(url)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure>
<p>Result:<br />
<font color = red>httpx.RemoteProtocolError: Server disconnected without
sending a response.</font></p>
<p><strong>但是这次又报告ProtocolError呢？</strong></p>
<p>其实httpx库的默认请求方法是<code>HTTP/1.1</code>协议的，如果想要<code>以HTTP/2.</code>0协议去请求就要先要<strong>手动声明一下</strong>才能使用。</p>
<p>Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://spa16.scrape.center/&#x27;</span></span><br><span class="line"></span><br><span class="line">client = httpx.Client(http2=<span class="literal">True</span>)  <span class="comment"># 打开h2协议请求,client变量接收一个已经支持h2请求的对象</span></span><br><span class="line">r = client.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以简化成一下形式，只不过不能重复以HTTP/2.0协议请求</span></span><br><span class="line"><span class="comment"># r = httpx.Client(http2=True).get(url)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;html lang=en&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=&quot;IE=edge&quot;&gt;&lt;meta name=viewport content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;meta name=referrer content=no-referrer&gt;&lt;link rel=icon href=/favicon.ico&gt;&lt;title&gt;Scrape | Book&lt;/title&gt;&lt;link href=/css/chunk-50522e84.e4e1dae6.css rel=prefetch&gt;&lt;link href=/css/chunk-f52d396c.4f574d24.css rel=prefetch&gt;&lt;link href=/js/chunk-50522e84.6b3e24aa.js rel=prefetch&gt;&lt;link href=/js/chunk-f52d396c.f8f41620.js rel=prefetch&gt;&lt;link href=/css/app.ea9d802a.css rel=preload as=style&gt;&lt;link href=/js/app.b93891e2.js rel=preload as=script&gt;&lt;link href=/js/chunk-vendors.a02ff921.js rel=preload as=script&gt;&lt;link href=/css/app.ea9d802a.css rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;strong&gt;We&#x27;re sorry but portal doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;&lt;/noscript&gt;&lt;div id=app&gt;&lt;/div&gt;&lt;script src=/js/chunk-vendors.a02ff921.js&gt;&lt;/script&gt;&lt;script src=/js/app.b93891e2.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>成功请求h2协议的网站。</p>
<p><strong>Tips：</strong><font color = blue size = 2>如果代码报错,可能是在安装httpx默认没有安装httpx[http2]协议，在cmd中输入<code>pip install httpx[http2]</code>下载就可以了。</font></p>
<p><font color = blue size = 1> <待完善>
</font>httpx的用法跟requests极其相似，具体可以参考<a
href="https://www.python-httpx.org/quickstart/">官方文档</a></p>
<h3 id="client对象">Client对象</h3>
<p>Client对象是httpx的一个比较独特的对象。</p>
<h4 id="简单实例-1">简单实例</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla 5.0, Windows NT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client(headers=headers) <span class="keyword">as</span> client:</span><br><span class="line">    r = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    <span class="built_in">print</span>(r.json()[<span class="string">&#x27;headers&#x27;</span>][<span class="string">&#x27;User-Agent&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上方法等价与以下方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = httpx.Client(headers=headers)</span></span><br><span class="line"><span class="comment"># try:</span></span><br><span class="line"><span class="comment">#     r = client.get(&#x27;https://www.httpbin.org/get&#x27;)</span></span><br><span class="line"><span class="comment"># finally:</span></span><br><span class="line"><span class="comment">#     client.close();</span></span><br></pre></td></tr></table></figure>
<p>Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Response [200 OK]&gt;</span><br><span class="line">Mozilla 5.0, Windows NT</span><br></pre></td></tr></table></figure></p>
<p><font color = blue size = 1> <待完善>
</font>Client的更多高级用法参照<a
href="https://www.python-httpx.org/advanced/">官方文档</a>。</p>
<h3 id="异步请求">异步请求</h3>
<p><font color = blue size = 1> <待完善>
</font>httpx还支持异步客户端请求(AsyncClient),支持Python的async请求模式。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        r = <span class="keyword">await</span> client.get(url)</span><br><span class="line">        <span class="built_in">print</span>(r.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(fetch(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>httpx</tag>
      </tags>
  </entry>
  <entry>
    <title>关于如何替换Hexo背景的操作指南</title>
    <url>/2023/07/11/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2Hexo%E8%83%8C%E6%99%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>根据设备类型显示不同的背景图片。</p>
<span id="more"></span>
<p>打开主题配置文件即themes/next下的_config.yml，将 style:
source/_data/styles.styl 取消注释。</p>
<p>打开根目录Blog/source创建文件_data/styles.styl，添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 添加背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">images/background.png</span>);//自己喜欢的图片地址</span><br><span class="line">      <span class="attribute">background-size</span>: cover;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">      <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">      <span class="attribute">background-position</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于桌面端和移动端的分辨率不同，可以设置桌面端和移动端设置不同的背景。</p>
<p>在Blog/source/_data/styles.styl中添加：<br />
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1000px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/bg.jpg</span>);</span><br><span class="line">    <span class="attribute">background-size</span>:cover;</span><br><span class="line">    <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:center;  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ios端修正：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1000px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">position</span>:fixed;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/bg2.png</span>) center <span class="number">0</span> no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>:cover;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>站点信息</category>
      </categories>
      <tags>
        <tag>站点建设</tag>
        <tag>站点美化</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式 【爬虫】</title>
    <url>/2023/07/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%90%E7%88%AC%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<h1 id="正则表达式">正则表达式</h1>
<h2 id="什么是正则表达式">什么是正则表达式？</h2>
<p>正则表达式是一种用于匹配、查找和操作文本的模式匹配工具。它由一系列字符和特殊字符组成，可以用来定义字符串的规则模式。</p>
<p>正则表达式可以用于各种编程语言和文本编辑器中，在处理文本时非常强大和灵活。它可以用于验证输入的数据，搜索和提取文本中的特定模式，替换文本，以及其他各种文本处理任务</p>
<span id="more"></span>
<h2 id="正则表达式在爬虫之中的运用">正则表达式在爬虫之中的运用</h2>
<p>可以利用正则表达式来从HTML中提取想要的信息。</p>
<h3 id="实例演示">实例演示</h3>
<p>使用开源中国提供的<a
href="https://tool.oschina.net/regex/">正则表达式测试工具</a>,输入带匹配的文本，选择常用的正则表达式，就可以出现相应的匹配结果。</p>
<p>Example:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello,my phone number is +86-10010001000 and my e-mail address is hello_xiunneg@foxmail.com,and my website is https://www.helloxiunneg.com.cn</span><br></pre></td></tr></table></figure> Result:<br />
<img src="https://img.nickyam.com/file/2261362929daf6b70885d.png"
alt="正则表达式_邮箱匹配" /></p>
<p><strong>Q：这是什么原理呢？</strong><br />
<strong>A:</strong>
因为邮箱地址是按照已知的规则组合的，对于按照一定规则的字符串，既可以编写相应正则表达式来匹配相应的字符并提取出来。
例如邮箱的正则表达式为：<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\.[\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?</span><br></pre></td></tr></table></figure></p>
<h3 id="具体的方法使用">具体的方法使用</h3>
<h4 id="match">match</h4>
<p>re.match函数</p>
<p><code>re.match(pattern, string, flags=0)</code></p>
<p>参数的详细解释如下：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>string</code>：要进行匹配的原始字符串。</li>
<li><code>flags</code>（可选）：可选的标志参数，比如<code>re.IGNORECASE</code>（忽略大小写匹配）和<code>re.MULTILINE</code>（多行模式）等。</li>
</ul>
<p><code>re.match()</code>函数尝试从<code>string</code>字符串的开头开始匹配<code>pattern</code>，如果匹配成功，则返回一个包含匹配信息的匹配对象；若匹配不成功，则返回None。</p>
<p>值得注意的是，<code>re.match()</code>函数只匹配字符串的开头部分。</p>
<p>match是常用的匹配方法，向它传入要匹配的字符串和正则表达式，就可以检测这个正则表达式是否和字符串相匹配。</p>
<p>match方法会尝试从字符串的起始位置开始匹配正则表达式，如果匹配，返回匹配成功的结果，否则，返回Node。</p>
<h5 id="简单实例">简单实例</h5>
<p>Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">41</span><br><span class="line">&lt;re.Match object; span=(0, 25), match=&#x27;Hello 123 4567 World_This&#x27;&gt;</span><br><span class="line">Hello 123 4567 World_This</span><br><span class="line">(0, 25)</span><br></pre></td></tr></table></figure></p>
<p><code>^</code>表示匹配字符串的开头，即以Hello开头。<br />
<code>\s</code>匹配任意的空白字符。（space）<br />
<code>\d</code>匹配匹配数字（digit）<br />
<code>\d&#123;4&#125;</code>表示匹配了四次数字。<br />
<code>\w&#123;10&#125;</code>表示匹配十次字母、数字或者下划线。（word）</p>
<p><code>.group()</code> 输出匹配到的内容<br />
<code>.span()</code> 输出匹配到的范围</p>
<h5 id="匹配目标">匹配目标</h5>
<p>用()进行对匹配结果进行分组，提取到想要信息。</p>
<p>Example: <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello\s(\d+)\sWorld&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40</span><br><span class="line">&lt;re.Match object; span=(0, 19), match=&#x27;Hello 1234567 World&#x27;&gt;</span><br><span class="line">Hello 1234567 World</span><br><span class="line">1234567</span><br><span class="line">(0, 19)</span><br></pre></td></tr></table></figure>
正则表达式：<code>^Hello\s(\d+)\sWorld</code></p>
<ul>
<li><code>^</code> 代表正则表达式的开始位置。</li>
<li><code>Hello</code> 代表字符串中的文本 "Hello"。</li>
<li><code>\s</code> 代表一个空白字符。</li>
<li><code>(\d+)</code> 代表一个或多个数字，<code>()</code>
表示该匹配部分可以被提取出来。</li>
<li><code>\s</code> 代表一个空白字符。</li>
<li><code>World</code> 代表字符串中的文本 "World"。</li>
</ul>
<p>因此，这个正则表达式可以匹配类似于 "Hello 123 World"
这样的字符串，其中 "123" 可以被提取出来作为匹配的数字部分。</p>
<h5 id="通用匹配">通用匹配</h5>
<p>对于每次都用精确的符号去匹配字符，其实有万能匹配<code>.*</code>去匹配，<code>.</code>代表可以匹配任意字符（除换行符）,<code>*</code>代表匹配字符无限次。</p>
<p>Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello.*Demo$&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br></pre></td></tr></table></figure></p>
<p>Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40</span><br><span class="line">&lt;re.Match object; span=(0, 40), match=&#x27;Hello 1234567 World_This is a Regex Demo&#x27;&gt;</span><br><span class="line">Hello 1234567 World_This is a Regex Demo</span><br><span class="line">(0, 40)</span><br></pre></td></tr></table></figure> ###### 贪婪与非贪婪</p>
<p>有时我们想要在通用匹配时提取出特定的字符串，但是使用<code>.*</code>会导致提取不完全，因为我们<strong>贪婪策略会把尽可能多的字符</strong>匹配，这就可能导致匹配不完全，这时使用<strong>非贪婪的通用匹配<code>.*?</code>去匹配尽可能少的字符</strong>就可以解决问题。</p>
<p>Example:<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"></span><br><span class="line">result_1 = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello.*(\d+).*Demo$&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;贪婪：&#x27;</span> + result_1.group())</span><br><span class="line"><span class="built_in">print</span>(result_1.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">result_2 = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello.*?(\d+).*Demo$&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;非贪婪：&#x27;</span> + result_2.group())</span><br><span class="line"><span class="built_in">print</span>(result_2.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">贪婪：Hello 1234567 World_This is a Regex Demo</span><br><span class="line">7</span><br><span class="line">非贪婪：Hello 1234567 World_This is a Regex Demo</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></p>
<h5 id="修饰符">修饰符</h5>
<p>可以使用修饰符来控制匹配的模式。</p>
<p>Example: <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 1234567 World_This is a \nRegex Demo&#x27;</span></span><br><span class="line"></span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello.*?(\d+).*Demo$&#x27;</span>,content,re.S)</span><br><span class="line"><span class="built_in">print</span>(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>re.S</code>表示使内容包括换行符在内的所有字符。<br />
<code>re.I</code>时匹配的字符对大小写不敏感。</p>
###### 转义字符
</h6>
<p>当正则表达式中存在正则表达式已经规定的特殊字符时，使用<code>\</code>来转义。</p>
<h4 id="search">search</h4>
<p><code>re.search(pattern, string, flags=0)</code></p>
<p>参数的详细解释如下：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>string</code>：要进行匹配的原始字符串。</li>
<li><code>flags</code>（可选）：可选的标志参数，比如<code>re.IGNORECASE</code>（忽略大小写匹配）和<code>re.MULTILINE</code>（多行模式）等。</li>
</ul>
<p><code>re.search()</code>函数在<code>string</code>字符串中搜索与<code>pattern</code>匹配的第一个出现，并返回一个包含匹配信息的匹配对象。如果找到匹配，则可以使用匹配对象的方法和属性获取相关信息。</p>
<p>值得注意的是，<code>re.search()</code>函数只返回一个匹配项。</p>
<p>match方法是从头开始匹配的，所以说如果开头不匹配的话，一开始就会失败。</p>
<p>这时使用search()方法可以避免这个问题。</p>
<p>search()方法会扫描整个字符串，返回第一个匹配成功的结果。</p>
<p>Example: <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello f 1234567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"></span><br><span class="line">result = re.search(<span class="string">&#x27;f.*?(\d+).*Demo$&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567</span><br></pre></td></tr></table></figure></p>
<h4 id="findall">findall</h4>
<p><code>re.findall(pattern, string, flags=0)</code></p>
<p>参数的详细解释如下：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>string</code>：要进行匹配的原始字符串。</li>
<li><code>flags</code>（可选）：可选的标志参数，比如<code>re.IGNORECASE</code>（忽略大小写匹配）和<code>re.MULTILINE</code>（多行模式）等。</li>
</ul>
<p><code>re.findall()</code>函数在<code>string</code>字符串中查找与<code>pattern</code>匹配的所有非重叠出现，并以列表的形式返回。</p>
<p>值得注意的是，返回的列表可能包含多个匹配项。</p>
<p>search()会返回匹配到的第一个结果，但是如果我们想要全部的匹配结果时就要使用findall()方法。</p>
<h4 id="sub">sub</h4>
<p>用于修改正则表达式中的内容，一般是替换操作（将替换的内容设置为'',就是删除）</p>
<p><code>re.sub(pattern, repl, string, count=0, flags=0)</code></p>
<p>参数的详细解释如下：</p>
<ul>
<li><code>pattern</code>：要匹配的正则表达式模式。</li>
<li><code>repl</code>：用于替换匹配到的字符串的字符串或者一个替换函数。</li>
<li><code>string</code>：要进行匹配和替换的原始字符串。</li>
<li><code>count</code>（可选）：最多替换次数。默认值为0，表示替换所有匹配。</li>
<li><code>flags</code>（可选）：可选的标志参数，比如<code>re.IGNORECASE</code>（忽略大小写匹配）和<code>re.MULTILINE</code>（多行模式）等。</li>
</ul>
<p><code>re.sub()</code>函数在<code>string</code>字符串中查找与<code>pattern</code>匹配的部分，并将其替换为<code>repl</code>参数指定的字符串或生成的值。可以通过设置<code>count</code>参数来限制替换的次数。<code>flags</code>参数用于修改正则表达式的匹配行为。</p>
<p>值得注意的是，<code>re.sub()</code>函数返回一个新的字符串，原始字符串不会被改变。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;a1s2d3f4g5h6j7k8l9;0&#x27;</span></span><br><span class="line"></span><br><span class="line">result = re.sub(<span class="string">&#x27;\d+&#x27;</span>,<span class="string">&#x27;&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asdfghjkl;</span><br></pre></td></tr></table></figure></p>
<p>通过此方法可以修改待匹配文件，简化正则表达式的写法。</p>
<h4 id="complie">complie</h4>
<p>complie()方法将正则表达式进行封装，以便于复用，还可以导入参数。</p>
<p>Example: <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">&#x27;2022-12-22 13:23&#x27;</span></span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span>,re.S)</span><br><span class="line"></span><br><span class="line">result = re.sub(pattern,<span class="string">&#x27;&#x27;</span>,content1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></p>
<p>Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-12-22</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib的使用【爬虫】</title>
    <url>/2023/07/08/urllib%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="urllib库">urllib库</h1>
<h2 id="urllib简介">urllib简介</h2>
<p>urllib库可以实现HTTP请求的发送，而且不用关心HTTP协议本身甚至更底层的实现。<br />
urllib还可以把服务器返回的响应转化为Python对象。</p>
<span id="more"></span>
<p>uillib库分为4个部分：<br />
1. request: 最基本的HTTP请求模块<br />
2. error: 异常处理<br />
3. parse: 工具模块<br />
4. robotsparser: 主要用来识别网站的robots.txt(反爬虫协议)</p>
<h2 id="request部分">request部分</h2>
<h3 id="urlopen方法">urlopen方法</h3>
<p>urlopen函数是Python中的标准库urllib中的一个函数，用于进行URL的打开操作。通过urlopen函数，我们可以实现简单的网页访问和数据获取。</p>
<p>urlopen 的API:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url,data=<span class="literal">None</span>,[timeout,]*,cafile=<span class="literal">None</span>,capath=<span class="literal">None</span>,cadefault=<span class="literal">False</span>,context=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>Example:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		location.<span class="title function_">replace</span>(location.<span class="property">href</span>.<span class="title function_">replace</span>(<span class="string">&quot;https://&quot;</span>,<span class="string">&quot;http://&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=http://www.baidu.com/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中response的类型是HTTPResponse类型的对象。<br />
response对象的方法： -
read():可以得到响应的网页内容，read()方法返回的是一个bytes对象，所以我们需要使用decode()方法将其解码为字符串使用UTF-8的编码方式翻译。
- status:返回响应的状态码 - getheaders():返回响应的头信息 -
getheader(String header):返回响应头中的header的信息。</p>
<p>Example: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br><span class="line"><span class="built_in">print</span>(response.getheader(<span class="string">&#x27;Server&#x27;</span>))</span><br></pre></td></tr></table></figure> Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200</span><br><span class="line">[(&#x27;Accept-Ranges&#x27;, &#x27;bytes&#x27;), (&#x27;Cache-Control&#x27;, &#x27;no-cache&#x27;), (&#x27;Content-Length&#x27;, &#x27;227&#x27;), (&#x27;Content-Security-Policy&#x27;, &quot;frame-ancestors &#x27;self&#x27; https://chat.baidu.com http://mirror-chat.baidu.com https://fj-chat.baidu.com https://hba-chat.baidu.com https://hbe-chat.baidu.com https://njjs-chat.baidu.com https://nj-chat.baidu.com https://hna-chat.baidu.com https://hnb-chat.baidu.com http://debug.baidu-int.com;&quot;), (&#x27;Content-Type&#x27;, &#x27;text/html&#x27;), (&#x27;Date&#x27;, &#x27;Sat, 08 Jul 2023 08:03:44 GMT&#x27;), (&#x27;P3p&#x27;, &#x27;CP=&quot; OTI DSP COR IVA OUR IND COM &quot;&#x27;), (&#x27;P3p&#x27;, &#x27;CP=&quot; OTI DSP COR IVA OUR IND COM &quot;&#x27;), (&#x27;Pragma&#x27;, &#x27;no-cache&#x27;), (&#x27;Server&#x27;, &#x27;BWS/1.1&#x27;), (&#x27;Set-Cookie&#x27;, &#x27;BD_NOT_HTTPS=1; path=/; Max-Age=300&#x27;), (&#x27;Set-Cookie&#x27;, &#x27;BIDUPSID=B2DDF506AC69764D33EB57BACA765F41; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&#x27;), (&#x27;Set-Cookie&#x27;, &#x27;PSTM=1688803424; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&#x27;), (&#x27;Set-Cookie&#x27;, &#x27;BAIDUID=B2DDF506AC69764DA32DCF9448705643:FG=1; max-age=31536000; expires=Sun, 07-Jul-24 08:03:44 GMT; domain=.baidu.com; path=/; version=1; comment=bd&#x27;), (&#x27;Strict-Transport-Security&#x27;, &#x27;max-age=0&#x27;), (&#x27;Traceid&#x27;, &#x27;168880342405518003309605580768504832005&#x27;), (&#x27;X-Ua-Compatible&#x27;, &#x27;IE=Edge,chrome=1&#x27;), (&#x27;Connection&#x27;, &#x27;close&#x27;)]</span><br><span class="line">BWS/1.1</span><br></pre></td></tr></table></figure></p>
<h4 id="api详解">API详解</h4>
<ul>
<li><p><strong>data参数</strong><br />
date接受bytes类型的数据，所以需要用bytes方法转化数据。<br />
如果传递了data参数，此时的请求方法就不是GET了而是POST方法了。</p>
<p>Example: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;germey&#x27;</span>&#125;),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>,data=data)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;data&quot;: &quot;&quot;, </span><br><span class="line">  &quot;files&quot;: &#123;&#125;, </span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;germey&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Content-Length&quot;: &quot;11&quot;, </span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;www.httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.11&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-64a91b51-5baef6d050d97ca4728a7bd0&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;json&quot;: null, </span><br><span class="line">  &quot;origin&quot;: &quot;110.52.208.181&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>timeout参数</strong><br />
用于设置超时时间，如果请求超出设置的超时时间还未得到响应，就会抛出socket.timeout类型的异常。<br />
Example: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  response = urllib.request.urlopen(<span class="string">&#x27;https://www.baidi.com&#x27;</span>,timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason,socket.timeout):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;TIME OUT&#x27;</span>)</span><br></pre></td></tr></table></figure> Result:<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIME OUT</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="request类">Request类</h2>
<p>urlopen只能发起最基本的请求，只有几个简单的参数并不能构建一个完整的请求。<br />
可以利用更强大的Request类来构造请求。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">urllib</span>.request.Request(url,data=<span class="literal">None</span>,headers=&#123;&#125;,</span><br><span class="line">                            origin_req_host=<span class="literal">None</span>,unverifiable=<span class="literal">False</span>,method=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure> url: 必选的参数<br />
data: 传数据参数<br />
headers: 字典，请求头，可以传入User-Agent来修改代理，可以伪装成浏览器。
origin_req_host:请求方的host主机或者IP地址
unverifiable:请求是否无法验证<br />
method:请求的方法（GET,POST,PUT）</p>
<p>Example： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/post&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/4.0 (compatible; MISE 5.5; Windows NT)&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;www.httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;germey&#x27;</span>&#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(<span class="built_in">dict</span>),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">req = request.Request(url=url,data=data,headers=headers,method=<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;data&quot;: &quot;&quot;, </span><br><span class="line">  &quot;files&quot;: &#123;&#125;, </span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;germey&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;, </span><br><span class="line">    &quot;Content-Length&quot;: &quot;11&quot;, </span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;www.httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/4.0 (compatible; MISE 5.5; Windows NT)&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-64a922d3-0c4207362201ce285311803e&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;json&quot;: null, </span><br><span class="line">  &quot;origin&quot;: &quot;110.52.208.181&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;https://www.httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="高级用法">高级用法</h2>
<p>为了实现Cookie处理，代理设置,就要使用跟强大的工具Handler。<br />
BaseHandler类，这是其他所有Handler类的父类。<br />
- HTTPDefaultErrorHandler: 用于处理HTTP的响应错误，抛出HTTPError。<br />
- HTTPRedirectHandler: 用于处理重定向。<br />
- HTTPCookieProcessor: 用于处理Cookie。<br />
- ProxyHandler: 由于设置代理<br />
- HTTPPassWordMgr: 用于管理密码。<br />
- HTTPBasicAuthHandler: 由于管理认证。</p>
<p>OpenerDirector类，简称Opner,相较于urlopen可以实现更高级的功能，可以利用Handler类来构造Opener类。</p>
<ol type="1">
<li><p><strong>密码验证</strong>
一般网站有登录验证的，可以用HTTPBasicAuthHandler模块来请求。<br />
Example: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, build_opener</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line">username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;https://ssr3.scrape.center/&#x27;</span></span><br><span class="line"></span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(<span class="literal">None</span>,url,username,password)</span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p)</span><br><span class="line">opener = build_opener(auth_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = opener.<span class="built_in">open</span>(url)</span><br><span class="line">    html = result.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(html)</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>获取Cookie</strong><br />
获取Cookie<br />
Example: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line"><span class="built_in">print</span>(item.name + <span class="string">&quot; = &quot;</span> + item.value)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>Result(HTTPTypeCookie): <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BD_NOT_HTTPS = 1</span><br><span class="line">BIDUPSID = 38CD2DC6F44B014DB48ECE6F8543A0E0</span><br><span class="line">PSTM = 1688807473</span><br><span class="line">BAIDUID = 38CD2DC6F44B014DDD1CDE9CA28C125F:FG=1</span><br></pre></td></tr></table></figure></p>
<p>将Cookie写入文件<br />
Example:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,http.cookiejar</span><br><span class="line"></span><br><span class="line"><span class="comment">#filename = &#x27;MozillaTypeCookie.txt&#x27;</span></span><br><span class="line"><span class="comment">#cookie = http.cookiejar.MozillaCookieJar(filename)</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;LWPTypeCookie.txt&#x27;</span></span><br><span class="line">cookie = http.cookiejar.LWPCookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>,ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理">异常处理</h3>
<ol type="1">
<li><p>URLError
URLError类来自urllib库的error模块，是error异常模块的异常的基类。<br />
reason()可以返回错误的原因。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  response = request.urlopen(<span class="string">&#x27;https://cuiqingcai.com/404&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">  <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure></li>
<li><p>HTTPError
HTTPError是URLError的子类，专门用来处理HTTP请求错误。<br />
有3个属性：</p>
<ul>
<li>code:状态码</li>
<li>reason:原因</li>
<li>headers:返回请求头</li>
</ul></li>
<li><p>解析链接</p>
<ul>
<li>urlparse(url):对url进行识别分段</li>
<li>urlunparse(): 构造url</li>
<li>urlsplit</li>
<li>urlunsplit</li>
<li>quote(),将utf-8字符转化成URL编码</li>
<li>unquote():URL编码转化成utf-8</li>
</ul></li>
</ol>
<h2 id="requests的使用">requests的使用</h2>
<p>requests是一个更强大的库，整合了urllib的方法。不同再像urllib在处理网页验证或者是Cookie时，需要写Handler类和Opener类。</p>
<h3 id="get请求">Get请求</h3>
<ol type="1">
<li><p>简单实例<br />
构造一个简单的GET请求。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"> r = requests.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"> <span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>需要添加额外的参数时:<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span> : <span class="string">&#x27;25&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.httpbin.com/get&#x27;</span>,params=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)    <span class="comment">#str</span></span><br><span class="line"><span class="built_in">print</span>(r.json())  <span class="comment">#dict</span></span><br></pre></td></tr></table></figure></p>
<p>参数params会将url构造成<code>https://ww.httpbin.com/get?age=25&amp;name=germey</code></p>
<p><strong>r.text</strong>
返回的是一个JSON格式的str，所以可以直接调用.json()将其转换成字典
对象</p></li>
<li><p>抓取网页<br />
请求返回的的是JSON格式的字符串，所以我们可以加入提取信息的逻辑来获取信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://ssr1.scrape.center/&#x27;</span>)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>,re.S) <span class="comment"># 正则表达式</span></span><br><span class="line">titles = re.findall(pattern,r.text)</span><br><span class="line"><span class="built_in">print</span>(titles)</span><br></pre></td></tr></table></figure>
<p><em>re 是 Python
中内置的正则表达式模块。它提供了一组函数和模式来处理字符串匹配和搜索操作。使用
re 模块可以实现字符串的搜索、替换、分割等操作。</em></p>
<p><strong>Result:</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;霸王别姬 - Farewell My Concubine&#x27;, &#x27;这个杀手不太冷 - Léon&#x27;, &#x27;肖申克的救赎 - The Shawshank Redemption&#x27;, &#x27;泰坦尼克号 - Titanic&#x27;, &#x27;罗马假日 - Roman Holiday&#x27;, &#x27;唐伯虎点秋香 - Flirting Scholar&#x27;, &#x27;乱世佳人 - Gone with the Wind&#x27;, &#x27;喜剧之王 - The King of Comedy&#x27;, &#x27;楚门的世界 - The Truman Show&#x27;, &#x27;狮子王 - The Lion King&#x27;]</span><br></pre></td></tr></table></figure></p></li>
<li><p>抓取二进制的数据<br />
如果我们想要获取网站上的图片、音频或者视频怎么办？</p>
<p>这时就要抓取对应的二进制数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;http://scrape.center/favicon.ico&#x27;</span>) </span><br><span class="line"><span class="comment">#ico是图片格式，存储格式是二进制</span></span><br><span class="line"><span class="built_in">print</span>(r.text) <span class="comment">#text将二进制翻译成字符串，导致乱码</span></span><br><span class="line"><span class="built_in">print</span>(r.content) <span class="comment"># 直接将二进制数据打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment">#所以用wb(二进制写入)方法将数据保持为.ico后缀的图片格式</span></span><br><span class="line">  f.write(r.content)</span><br></pre></td></tr></table></figure>
<p><strong>Result:</strong></p>
<figure>
<img src="https://img.nickyam.com/file/afe816a0d38e1c295aeef.png"
alt="favicon.ico" />
<figcaption aria-hidden="true">favicon.ico</figcaption>
</figure></li>
<li><p>添加请求头<br />
可以使用headers参数添加请求头。<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0, Windows NT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://ssr1.scrape.center/&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="post-请求">POST 请求</h3>
<ol type="1">
<li>基本实例<br />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiunneg&#x27;</span>,<span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>,data=data)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>form部分就是提交的数据</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;form&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xiunneg&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Accept&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*/*&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Accept-Encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gzip, deflate&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Content-Length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;19&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Content-Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/x-www-form-urlencoded&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;www.httpbin.org&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;User-Agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python-requests/2.31.0&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;X-Amzn-Trace-Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Root=1-64abe71a-5554056d6d41c78875af39e7&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;json&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;origin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;110.52.208.172&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="响应">响应</h3>
<p>requests库提供了内置的状态码查询对象requests.codes。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://ssr1.scrape.center/&#x27;</span>)</span><br><span class="line">exit() <span class="keyword">if</span> <span class="keyword">not</span> r.status_code == requests.codes.ok <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&#x27;Request Successful&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="高级用法-1">高级用法</h3>
<ol type="1">
<li><p>上传文件<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">file = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>,files=file)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>Result: <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data:application/octet-stream;base64,......&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;form&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Accept&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*/*&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Accept-Encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gzip, deflate&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Content-Length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4433&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Content-Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multipart/form-data; boundary=8581aa9252902a3acf65bdd40e2b3f41&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;www.httpbin.org&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;User-Agent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python-requests/2.31.0&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;X-Amzn-Trace-Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Root=1-64abeb09-649069cb0195d89f7b23b921&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;json&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;origin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;110.52.208.172&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>获取Cookie<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.cookies)</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> r.cookies.items():</span><br><span class="line">    <span class="built_in">print</span>(key + <span class="string">&#x27;=&#x27;</span> + value)</span><br></pre></td></tr></table></figure></p></li>
<li><p>Session 维持<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">&#x27;https://www.httpbin.org/cookies/set/number/123456789&#x27;</span>)</span><br><span class="line">r = s.get(<span class="string">&#x27;https://www.httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure></p>
<p>在同一次请求中设置Cookie并且获取设置的Cookie</p></li>
<li><p>SSL证书验证<br />
使用verify参数跳过SSL证书验证。<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">&#x27;https:/ssr2.scrape.center/&#x27;</span>,varify = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>超时设置<br />
通过设置timeout参数设置最长响应时间 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">r =  requests.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>,timeou=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>身份验证<br />
使用requests库自带的身份验证功能，使用
参数auth，向其传入HTTPBasicAuth(str name,str
password)对象或者传递元组对象 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://ssr3.scrape.center/&#x27;</span>,auth=(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用代理<br />
通过向proxies参数传入代理的字典对象可以实现代理 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">&#x27;http&#x27;</span> : <span class="string">&#x27;http://10.10.10.10:1080&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;https&#x27;</span> :  <span class="string">&#x27;http://10.10.10.10:1080&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r  = requests.get(<span class="string">&#x27;https:www.httpbin.org/get&#x27;</span>,proxies=proxies)</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>Python3爬虫基础</category>
        <category>爬虫基础知识</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>urllib库</tag>
      </tags>
  </entry>
</search>
